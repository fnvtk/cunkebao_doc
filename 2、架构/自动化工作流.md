# 自动化工作流文档

> 📅 最后更新：2026-01-11
> 📋 存客宝系统自动化任务和工作流详解

---

## 📋 概述

存客宝系统采用 **Workerman + Redis Queue** 架构实现任务调度和自动化工作流，支持定时任务、事件驱动任务和手动触发任务。

---

## 🏗️ 工作流架构

### 整体架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                          任务调度层                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐            │
│   │   Cron      │    │   Event     │    │   Manual    │            │
│   │   定时触发   │    │   事件触发   │    │   手动触发   │            │
│   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘            │
│          │                  │                  │                    │
│          └──────────────────┼──────────────────┘                    │
│                             ▼                                       │
│                      ┌─────────────┐                                │
│                      │ TaskScheduler│                               │
│                      │  任务调度器   │                               │
│                      └──────┬──────┘                                │
│                             │                                       │
└─────────────────────────────┼───────────────────────────────────────┘
                              │
┌─────────────────────────────┼───────────────────────────────────────┐
│                             ▼                                       │
│                      ┌─────────────┐                                │
│                      │ Redis Queue │                                │
│                      │   任务队列   │                                │
│                      └──────┬──────┘                                │
│                             │                                       │
│          ┌──────────────────┼──────────────────┐                    │
│          ▼                  ▼                  ▼                    │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐            │
│   │  Worker 1   │    │  Worker 2   │    │  Worker N   │            │
│   │  消费进程1   │    │  消费进程2   │    │  消费进程N   │            │
│   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘            │
│          │                  │                  │                    │
│          └──────────────────┼──────────────────┘                    │
│                             ▼                                       │
│                      ┌─────────────┐                                │
│                      │   执行结果   │                                │
│                      │ MySQL/MongoDB│                               │
│                      └─────────────┘                                │
│                                                                     │
│                          执行层                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 📝 任务类型

### 1. 定时任务 (Cron)

| 任务名称 | 命令 | 执行周期 | 说明 |
|----------|------|----------|------|
| 自动点赞 | `workbench:autoLike` | 每5分钟 | 自动点赞好友朋友圈 |
| 朋友圈同步 | `workbench:moments` | 每10分钟 | 同步发布朋友圈 |
| 群消息推送 | `workbench:groupPush` | 每分钟 | 群发消息任务 |
| 自动建群 | `workbench:groupCreate` | 每分钟 | 自动创建群聊 |
| 入群欢迎语 | `workbench:groupWelcome` | 每分钟 | 新成员欢迎 |
| 流量分发 | `workbench:trafficDistribute` | 每5分钟 | 流量自动分配 |
| 内容采集 | `content:collect` | 每小时 | 采集内容素材 |
| 朋友圈采集 | `moments:collect` | 每30分钟 | 采集好友朋友圈 |
| 健康分计算 | `wechat:calculate-score` | 每天凌晨 | 计算账号健康分 |
| 数据同步 | `sync:wechatData` | 每10分钟 | 同步微信数据 |

### 2. 事件驱动任务

| 事件 | 触发任务 | 说明 |
|------|----------|------|
| 新好友添加 | 自动打标签 | 根据来源自动打标签 |
| 新消息接收 | AI自动回复 | 触发AI回复流程 |
| 新成员入群 | 发送欢迎语 | 自动发送欢迎消息 |
| 好友删除 | 更新状态 | 标记好友为已删除 |
| 设备上线 | 数据同步 | 同步设备最新数据 |

### 3. 手动触发任务

| 任务 | API接口 | 说明 |
|------|---------|------|
| 立即群发 | `POST /v1/workbench/mass-send` | 立即执行群发 |
| 立即建群 | `POST /v1/workbench/auto-group` | 立即创建群聊 |
| 数据导出 | `POST /v1/export/friends` | 导出好友数据 |

---

## ⚙️ 任务调度器

### TaskScheduler 核心实现

```php
// application/command/TaskSchedulerCommand.php

class TaskSchedulerCommand extends Command
{
    // 最大并发进程数
    protected $maxConcurrent = 5;
    
    // 运行中的进程
    protected $runningProcesses = [];
    
    /**
     * 执行任务调度
     */
    protected function execute(Input $input, Output $output)
    {
        // 获取待执行任务
        $tasks = $this->getPendingTasks();
        
        // 并发执行
        $this->executeConcurrent($tasks, $output);
    }
    
    /**
     * 并发执行任务
     */
    protected function executeConcurrent($tasks, Output $output)
    {
        foreach ($tasks as $taskId => $task) {
            // 等待可用进程槽
            while (count($this->runningProcesses) >= $this->maxConcurrent) {
                $this->waitForProcesses();
                usleep(100000);
            }
            
            // 检查任务锁（防止重复执行）
            $lockKey = "scheduler_task_lock:{$taskId}";
            if (Cache::get($lockKey)) {
                continue;
            }
            
            // 创建子进程
            $pid = pcntl_fork();
            
            if ($pid == 0) {
                // 子进程执行任务
                $this->runTask($taskId, $task);
                exit(0);
            } else {
                // 父进程记录
                $this->runningProcesses[$pid] = [
                    'task_id' => $taskId,
                    'start_time' => time(),
                ];
                Cache::set($lockKey, time(), 600);
            }
        }
        
        // 等待所有子进程完成
        while (!empty($this->runningProcesses)) {
            $this->waitForProcesses();
        }
    }
}
```

### Workerman 定时器

```php
// application/common/TaskServer.php

class TaskServer extends Worker
{
    public function onWorkerStart($worker)
    {
        $adapter = new ChuKeBaoAdapter();
        
        // 进程4：处理获客任务新用户
        if ($worker->id == 4) {
            Timer::add(60, function () use ($adapter) {
                $adapter->handleCustomerTaskNewUser();
            });
        }
        
        // 进程3：处理获客任务添加后逻辑
        if ($worker->id == 3) {
            Timer::add(60, function () use ($adapter) {
                $adapter->handleCustomerTaskWithStatusIsCreated();
            });
        }
        
        // 进程2：处理获客新任务
        if ($worker->id == 2) {
            Timer::add(1, function () use ($adapter) {
                $adapter->handleCustomerTaskWithStatusIsNew();
            });
        }
        
        // 进程1：处理自动问候
        if ($worker->id == 1) {
            Timer::add(60, function () use ($adapter) {
                $adapter->handleAutoGreetings();
            });
        }
    }
}
```

---

## 📋 任务 Job 实现

### 1. 群消息推送 Job

```php
// application/job/WorkbenchGroupPushJob.php

class WorkbenchGroupPushJob
{
    const MAX_RETRY_ATTEMPTS = 3;
    
    public function fire(Job $job, $data)
    {
        try {
            $this->execute();
            $job->delete();
            return true;
        } catch (\Exception $e) {
            return $this->handleError($e, $job);
        }
    }
    
    protected function execute()
    {
        // 获取待执行的推送任务
        $tasks = WorkbenchGroupPush::where('status', 0)
            ->where('execute_time', '<=', time())
            ->limit(10)
            ->select();
        
        foreach ($tasks as $task) {
            // 获取 WebSocket 连接
            $ws = new WebSocketController($task->wechat);
            
            // 发送消息
            $result = $ws->sendChatroomMessage(
                $task->chatroom_id,
                $task->message
            );
            
            // 更新状态
            $task->status = $result['code'] == 200 ? 1 : 2;
            $task->execute_result = json_encode($result);
            $task->save();
            
            // 间隔发送（防风控）
            sleep(rand(3, 8));
        }
    }
    
    protected function handleError($e, $job)
    {
        if ($job->attempts() >= self::MAX_RETRY_ATTEMPTS) {
            Log::error('任务失败，已达最大重试次数', [
                'error' => $e->getMessage()
            ]);
            $job->delete();
            return false;
        }
        
        // 延迟重试
        $job->release(60);
        return false;
    }
}
```

### 2. 自动建群 Job

```php
// application/job/WorkbenchGroupCreateJob.php

class WorkbenchGroupCreateJob
{
    public function fire(Job $job, $data)
    {
        try {
            $task = WorkbenchGroupCreate::find($data['task_id']);
            
            // 获取 WebSocket 连接
            $ws = new WebSocketController($task->wechat);
            
            // 创建群聊
            $result = $ws->createChatroom([
                'memberWxids' => json_decode($task->member_wxids, true),
                'name' => $task->group_name,
            ]);
            
            if ($result['code'] == 200) {
                // 更新任务状态
                $task->status = 1;
                $task->chatroom_id = $result['data']['chatroomId'];
                $task->save();
                
                // 如果设置了欢迎语，触发欢迎语任务
                if ($task->welcome_message) {
                    $this->triggerWelcomeMessage($task);
                }
            }
            
            $job->delete();
        } catch (\Exception $e) {
            $this->handleError($e, $job);
        }
    }
}
```

### 3. 入群欢迎语 Job

```php
// application/job/WorkbenchGroupWelcomeJob.php

class WorkbenchGroupWelcomeJob
{
    public function fire(Job $job, $data)
    {
        $chatroomId = $data['chatroom_id'];
        $newMemberWxid = $data['new_member_wxid'];
        
        // 获取欢迎语配置
        $config = GroupWelcomeConfig::where('chatroom_id', $chatroomId)
            ->where('enabled', 1)
            ->find();
        
        if (!$config) {
            $job->delete();
            return;
        }
        
        // 延迟发送（等待入群动画完成）
        sleep($config->delay ?? 3);
        
        // 获取 WebSocket 连接
        $ws = new WebSocketController($config->wechat);
        
        // 替换变量
        $message = str_replace(
            ['{nickname}', '{date}'],
            [$data['nickname'], date('Y-m-d')],
            $config->message
        );
        
        // 发送欢迎语
        $ws->sendChatroomMessage($chatroomId, $message);
        
        $job->delete();
    }
}
```

---

## 🔄 工作流示例

### 1. 新客户获取工作流

```yaml
工作流名称: 新客户获取
触发条件: 用户扫描渠道码

步骤:
  1. 自动通过好友请求
     - 延迟: 随机 1-5 秒
     - 条件: 请求来源匹配渠道码
     
  2. 发送欢迎消息
     - 延迟: 3 秒
     - 内容: "您好，感谢关注！"
     
  3. 自动打标签
     - 标签: 渠道来源标签
     - 标签: 新客户标签
     
  4. 分配到流量池
     - 流量池: 根据渠道配置
     
  5. 推送到 CRM
     - 条件: 如果配置了 CRM 对接
```

### 2. 私域培育工作流

```yaml
工作流名称: 私域培育
触发条件: 客户添加满 3 天

步骤:
  1. 检查互动情况
     - 条件: 如果 3 天内无互动
     
  2. 发送关怀消息
     - 内容: 从内容库随机选择
     - 时间: 工作日 10:00-12:00
     
  3. 朋友圈点赞
     - 条件: 如果客户有新朋友圈
     - 数量: 最近 3 条
     
  4. 更新客户阶段
     - 阶段: 培育期 → 活跃期
```

### 3. 群运营工作流

```yaml
工作流名称: 群运营
触发条件: 每日定时

步骤:
  1. 早安问候
     - 时间: 08:30
     - 内容: 早安问候 + 今日话题
     
  2. 午间互动
     - 时间: 12:00
     - 内容: 互动话题 / 投票
     
  3. 晚间总结
     - 时间: 20:00
     - 内容: 今日精华 / 明日预告
     
  4. 活跃度统计
     - 时间: 23:00
     - 动作: 统计群活跃数据
```

---

## 📊 任务监控

### 任务状态

| 状态码 | 状态 | 说明 |
|--------|------|------|
| 0 | 待执行 | 任务已创建，等待执行 |
| 1 | 执行中 | 任务正在执行 |
| 2 | 已完成 | 任务执行成功 |
| 3 | 失败 | 任务执行失败 |
| 4 | 已取消 | 任务被取消 |
| 5 | 暂停中 | 任务暂停执行 |

### 监控指标

```php
// 任务监控数据结构
[
    'queue_length' => 100,        // 队列长度
    'processing' => 5,            // 处理中任务数
    'completed_today' => 1000,    // 今日完成数
    'failed_today' => 10,         // 今日失败数
    'avg_process_time' => 2.5,    // 平均处理时间(秒)
    'worker_status' => [          // Worker 状态
        ['id' => 1, 'status' => 'running', 'memory' => '50MB'],
        ['id' => 2, 'status' => 'running', 'memory' => '48MB'],
    ]
]
```

---

## 🛡️ 容错机制

### 1. 任务重试

```php
// 重试策略
$retryStrategy = [
    'max_attempts' => 3,           // 最大重试次数
    'delay' => [60, 300, 900],     // 重试间隔(秒)
    'backoff' => 'exponential',    // 退避策略
];
```

### 2. 死信队列

```php
// 失败任务进入死信队列
if ($job->attempts() >= $maxAttempts) {
    Queue::push('dead_letter', $job->getData());
    $job->delete();
}
```

### 3. 任务超时

```php
// 任务超时处理
$timeout = 300; // 5分钟超时
if (time() - $task->start_time > $timeout) {
    $task->status = 3; // 标记失败
    $task->error_message = '任务执行超时';
    $task->save();
}
```

---

## ⚠️ 注意事项

1. **任务幂等性**：同一任务多次执行结果应该一致
2. **并发控制**：避免同一资源被多个任务同时操作
3. **资源释放**：任务完成后及时释放锁和连接
4. **日志记录**：记录任务执行的关键节点
5. **监控告警**：任务失败率过高时及时告警
