# 合并的Markdown文档

> 合并时间：2025/5/25 20:45:52  
> 文件数量：75  

## 文件 1: 后端-标签管理-后端开发文档.md

*文件大小：14.42 KB*

---

# 标签管理模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
标签管理模块是客户关系管理 (CRM) 和用户画像系统的核心组成部分。它为系统提供了一种灵活的方式来分类、组织和细分客户（或其他实体），是实现精准营销、个性化服务和数据分析的基础。

### 1.2 设计目标
- **灵活性**: 支持创建多样化的标签，满足不同业务场景的需求。
- **易用性**: 提供简洁直观的接口和管理功能，方便运营人员使用。
- **高性能**: 高效处理大量标签数据以及客户与标签之间的关联关系。
- **可扩展性**: 易于集成新的标签类型、规则引擎或与其他业务模块联动。
- **一致性**: 保证标签数据及其关联关系在整个系统中的准确性和一致性。

## 二、模块概述 (原内容已整合和扩展)

本模块负责系统中客户标签（或其他适用实体的标签）的全生命周期管理。这包括标签的定义、创建、分类、修改、查询、停用/启用、删除，以及实体与标签之间关联关系的管理和维护。

## 三、核心数据实体/模型

为了实现标签管理功能，以下核心数据实体是必需的：

1.  **标签 (Tag)**
    *   `tag_id` (主键): 标签的唯一标识符。
    *   `name` (字符串, 必填, 唯一约束 - 可按分类或全局): 标签的显示名称。
    *   `description` (文本, 可选): 标签的详细描述。
    *   `category_id` (外键, 可选): 指向标签分类的ID，用于组织标签。
    *   `type` (枚举/字符串, 可选): 标签类型（例如：手动标签, 自动规则标签, 系统预设标签）。
    *   `color_code` (字符串, 可选): 用于UI展示的颜色代码。
    *   `status` (枚举/字符串, 默认: active): 标签状态 (例如: active, inactive, archived)。
    *   `creator_id` (外键, 可选): 创建该标签的用户或系统进程ID。
    *   `created_at` (时间戳): 创建时间。
    *   `updated_at` (时间戳): 最后更新时间。
    *   `usage_count` (整数, 可选): 该标签被关联的实体数量（可冗余或实时计算）。

2.  **标签分类 (TagCategory)**
    *   `category_id` (主键): 分类的唯一标识符。
    *   `name` (字符串, 必填, 唯一约束): 分类的显示名称。
    *   `description` (文本, 可选): 分类的详细描述。
    *   `parent_category_id` (外键, 可选): 指向父分类ID，支持层级分类。
    *   `sort_order` (整数, 可选): 用于UI展示的排序值。
    *   `created_at` (时间戳): 创建时间。
    *   `updated_at` (时间戳): 最后更新时间。

3.  **实体标签关联 (EntityTagLink)**
    *   `entity_id` (字符串/整数, 主键部分): 被打标实体的唯一标识符 (例如：客户ID, 用户ID)。
    *   `entity_type` (字符串, 主键部分, 可选): 被打标实体的类型 (例如：'customer', 'user', 'product')，用于支持多实体打标。
    *   `tag_id` (外键, 主键部分): 指向标签的ID。
    *   `assigned_at` (时间戳): 标签关联的创建时间。
    *   `assigned_by` (外键, 可选): 执行关联操作的用户或系统进程ID。
    *   (可选) `metadata` (JSON/文本): 存储与此次关联相关的额外信息。

## 四、功能模块划分

### 1. 标签定义与管理
    *   **标签CRUD**: 提供对标签实体的创建 (Create)、读取 (Read)、更新 (Update)、删除 (Delete) 操作。
        *   创建时需校验名称唯一性（可根据分类）、类型合法性。
        *   更新时需处理名称变更可能引发的冲突。
        *   删除标签时需考虑其关联关系的处理策略（例如：级联删除关联，或置空关联）。
    *   **标签分类管理**: 提供对标签分类的CRUD操作，支持层级分类。
    *   **标签状态管理**: 支持标签的启用、停用、归档等状态变更。停用的标签不应再用于新的关联。
    *   **批量操作**: 支持批量创建、更新、删除标签，以及批量修改标签状态。
    *   **导入/导出**: (可选) 支持通过文件（如CSV, Excel）批量导入标签定义，或导出标签列表。

### 2. 实体与标签关联管理
    *   **为实体打标**: 为指定的单个或多个实体关联一个或多个标签。
        *   需校验实体和标签的有效性。
        *   处理重复关联的情况（通常是忽略或返回成功）。
    *   **移除实体标签**: 移除指定实体与一个或多个标签之间的关联。
    *   **查询实体标签**: 根据实体ID查询其关联的所有标签。
    *   **查询标签下的实体**: 根据标签ID查询所有关联了该标签的实体列表（支持分页、筛选）。
    *   **批量关联/解绑**: 支持对一批实体批量添加或移除某些标签。

### 3. 自动标签 (可选，若支持)
    *   **规则定义**: (如果支持自动标签) 提供接口或机制来定义自动为实体打标的规则。
        *   规则可以基于实体的属性、行为数据或其他关联数据。
        *   例如："近30天消费超过1000元的客户自动打上'高价值客户'标签"。
    *   **规则引擎集成**: 与规则引擎交互，执行标签规则的匹配和应用。
    *   **规则执行与追溯**: 记录自动打标的执行情况和原因。

### 4. 标签查询与分析
    *   **标签列表查询**: 提供强大的标签查询接口，支持按名称、分类、类型、状态等条件筛选、排序和分页。
    *   **标签使用统计**: 统计每个标签被关联的实体数量、使用频率等。
    *   **标签关系分析**: (高级功能) 分析标签之间的共现关系、相似度等。
    *   **实体标签分布**: 查看不同实体群体中标签的分布情况。

## 五、API接口设计指导原则

所有对外暴露的API接口应遵循以下原则：

1.  **RESTful风格**: 尽可能遵循RESTful设计原则，使用标准的HTTP方法 (GET, POST, PUT, DELETE, PATCH)。
    *   `GET /tags`: 获取标签列表。
    *   `POST /tags`: 创建新标签。
    *   `GET /tags/{tag_id}`: 获取特定标签详情。
    *   `PUT /tags/{tag_id}`: 更新特定标签（全量更新）。
    *   `PATCH /tags/{tag_id}`: 部分更新特定标签。
    *   `DELETE /tags/{tag_id}`: 删除特定标签。
    *   `GET /entities/{entity_id}/tags`: 获取某实体的标签。
    *   `POST /entities/{entity_id}/tags`: 为某实体添加标签 (可批量)。
    *   `DELETE /entities/{entity_id}/tags/{tag_id}`: 移除某实体的特定标签。
2.  **统一数据格式**: 请求体和响应体主要使用JSON格式。
3.  **清晰的URL结构**: URL应直观易懂，反映资源层级。
4.  **版本控制**: API应考虑版本化 (例如：`/api/v1/tags`)，以便未来升级。
5.  **幂等性**: 对于创建、更新、删除操作，应考虑其幂等性。例如，多次执行相同的创建请求（如果资源已存在）应返回相同的成功结果或特定错误码。
6.  **参数校验**: 对所有输入参数进行严格校验（格式、类型、范围、必填项等）。
7.  **标准化响应码**: 使用标准的HTTP状态码来表示操作结果 (200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error 等)。
8.  **统一错误响应格式**: 发生错误时，响应体应包含统一的错误信息结构，如错误码、错误消息、详细描述等。
9.  **分页与排序**: 对于列表查询接口，必须支持分页 (如 `offset`, `limit` 或 `page`, `size`) 和排序 (如 `sort_by`, `order`)。
10. **筛选**: 列表查询接口应支持根据关键字段进行筛选。
11. **安全性**:
    *   **认证 (Authentication)**: 所有接口（除非明确公开）都应受保护，需要有效的用户身份认证。
    *   **授权 (Authorization)**: 根据用户角色和权限控制对标签数据的访问和操作。
12. **审计日志**: 对所有写操作（创建、更新、删除标签及关联）记录详细的审计日志，包括操作人、操作时间、操作内容等。
13. **批量操作支持**: 对可能涉及大量数据的操作（如批量打标、批量删除）提供专门的批量接口，以提高效率并减少网络开销。

## 六、主要业务流程示例

### 1. 创建新标签流程
    1.  **请求接收**: API接收到创建标签的请求，包含标签名称、分类、描述等信息。
    2.  **输入校验**: 对请求参数进行校验（例如，名称是否为空，长度是否超限，分类是否存在等）。
    3.  **权限校验**: 检查当前用户是否有创建标签的权限。
    4.  **唯一性检查**: 检查标签名称在指定范围内（例如，同一分类下或全局）是否已存在。
    5.  **数据持久化**: 若校验通过，则将新标签信息存入数据库。
    6.  **响应返回**: 返回成功信息，包含新创建标签的ID和完整信息；若失败，则返回相应的错误码和信息。
    7.  **(可选) 消息通知**: (如果需要) 发送标签创建事件消息，供其他模块消费。

### 2. 为客户打标签流程
    1.  **请求接收**: API接收到为客户打标签的请求，包含客户ID列表和标签ID列表。
    2.  **输入校验**: 校验客户ID和标签ID的有效性、是否存在。
    3.  **权限校验**: 检查用户是否有为这些客户打这些标签的权限。
    4.  **循环处理 (针对每个客户和每个标签)**:
        a.  检查关联是否已存在，若已存在可跳过或返回特定提示。
        b.  创建客户与标签的关联记录到数据库。
        c.  (可选) 更新客户的标签冗余字段或标签的使用计数。
    5.  **响应返回**: 返回操作结果（成功数量、失败数量及原因）。
    6.  **(可选) 消息通知**: 发送客户被打标事件。

### 3. 查询客户的标签列表流程
    1.  **请求接收**: API接收到查询客户标签的请求，包含客户ID。
    2.  **输入校验**: 校验客户ID的有效性。
    3.  **权限校验**: (如果需要) 检查用户是否有查看该客户标签的权限。
    4.  **数据查询**: 从数据库中查询指定客户ID关联的所有有效标签信息。
    5.  **数据格式化**: 将查询结果格式化为API响应所需的结构。
    6.  **响应返回**: 返回标签列表。

## 七、技术考量与开发注意事项

1.  **性能优化**:
    *   **数据库索引**: 为 `EntityTagLink` 表的 `entity_id`, `tag_id` 以及组合键创建合适的索引。为 `Tag` 表的 `name`, `category_id`, `status` 创建索引。
    *   **缓存策略**: 考虑缓存热门标签信息、客户的标签列表等，以减少数据库查询压力。
    *   **反规范化 (Denormalization)**: (谨慎使用) 可以在客户实体中冗余部分标签信息（如标签ID列表或标签名称字符串），以加速查询，但需处理好数据同步问题。
    *   **批量操作优化**: 批量接口应在数据库层面进行优化，避免N+1查询。
2.  **数据一致性**:
    *   删除标签时，应明确其关联的处理逻辑（级联删除关联、或阻止删除仍被使用的标签）。
    *   标签名称或分类变更时，可能需要更新相关实体的冗余信息。
    *   使用事务保证标签操作及其关联操作的原子性。
3.  **可扩展性**:
    *   设计时考虑未来可能支持的标签类型（如基于AI推荐的标签）。
    *   模块间通过清晰的接口或事件进行交互，降低耦合度。
4.  **并发控制**:
    *   对于标签使用计数等字段的更新，需要考虑并发场景下的数据准确性（如使用乐观锁或数据库原子操作）。
5.  **层级标签管理**:
    *   如果支持层级标签，需要设计合理的数据结构（如邻接表、路径枚举、闭包表）并优化层级查询性能。
6.  **标签的语义与维护**:
    *   考虑提供标签治理功能，如查找相似标签、合并废弃标签、监控标签使用情况，避免标签泛滥和混乱。
7.  **与其他模块的集成**:
    *   **客户模块**: 标签模块强依赖客户信息。
    *   **搜索/筛选模块**: 标签是重要的搜索和筛选维度。
    *   **营销活动模块**: 基于标签进行人群圈选。
    *   **数据分析模块**: 基于标签进行用户画像和行为分析。
8.  **可测试性**: 模块设计应易于单元测试和集成测试。

## 八、数据校验与错误处理

1.  **输入校验**:
    *   所有API接口的输入参数都必须经过严格校验，包括类型、格式、长度、范围、非空等。
    *   对标签名称等关键字段进行特殊字符过滤或转义，防止XSS等注入攻击。
2.  **业务规则校验**:
    *   校验标签名称的唯一性（全局或分类下）。
    *   校验标签分类的层级关系是否合法（如避免循环引用）。
    *   校验实体是否存在、标签是否存在。
3.  **错误处理机制**:
    *   定义统一的错误码和错误消息格式。
    *   对于客户端错误 (4xx)，返回清晰的错误原因，指导用户修正。
    *   对于服务端错误 (5xx)，记录详细日志，返回通用错误提示，避免暴露敏感信息。
    *   关键操作应有明确的成功和失败反馈。

## 九、安全性考量

1.  **权限控制**:
    *   基于角色/权限体系 (RBAC)，细粒度控制用户对标签及分类的创建、查看、修改、删除权限。
    *   控制用户为哪些实体打标，或查看哪些实体的标签。
    *   敏感标签（如涉及用户隐私、财务状况）应有更严格的访问控制。
2.  **数据保护**:
    *   对于可能包含敏感信息的标签描述，应考虑是否需要脱敏或加密。
    *   防止通过标签查询接口泄露未授权访问的实体信息。
3.  **操作审计**:
    *   对所有标签及关联的写操作（增删改）记录详细的审计日志，包括操作者、时间、IP地址、操作内容等，便于追溯和安全分析。
4.  **防滥用**:
    *   考虑对标签创建频率、单个实体关联标签数量等进行限制，防止恶意使用或系统过载。

## 十、未来扩展方向 (可选)

*   **AI驱动的智能标签推荐**: 基于用户行为或内容分析，自动推荐合适的标签。
*   **标签语义网络**: 构建标签之间的语义关系（同义、反义、上下位等）。
*   **标签版本控制**: 支持标签定义的版本管理和回溯。
*   **跨团队标签共享与协作**: 支持更复杂的标签治理和协作流程。

---

## 文件 2: 后端-产品管理-后端开发文档.md

*文件大小：12.28 KB*

---

# 产品管理模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
产品管理模块是电商平台、服务预订系统或任何涉及目录管理的核心组件。它负责定义、组织、存储和管理系统中所有可销售或可展示的产品、服务或项目（以下统称"产品"）。此模块为前台展示、库存控制、订单处理、营销活动等其他业务模块提供基础数据支持。

### 1.2 设计目标
- **灵活性与全面性**: 支持管理多种类型的产品，包括实体商品、虚拟商品、服务等，并能描述其复杂属性和规格。
- **易用性**: 提供清晰的数据模型和管理接口，方便运营人员录入、编辑和维护产品信息。
- **高性能**: 高效处理大量产品数据的查询和展示，支持快速搜索和筛选。
- **可扩展性**: 易于扩展新的产品类型、属性、规格，并能与其他系统（如ERP、PIM）集成。
- **数据准确性**: 保证产品信息（特别是价格、库存）的准确性和一致性。
- **标准化**: 遵循行业通用的商品模型概念（如SPU/SKU），便于理解和对接。

## 二、模块概述

本模块提供对平台产品（包括实体商品、虚拟服务、订阅等）的全生命周期管理功能。这包括产品的创建、编辑、详情描述、多规格管理 (SKU)、分类组织、价格设定、库存控制、状态管理（如上架、下架、草稿）、以及相关的图片和多媒体资源管理。

## 三、核心概念与架构组件

### 3.1 核心概念
- **SPU (Standard Product Unit, 标准产品单元)**: 产品的标准化描述单元，代表一类具有共同属性的商品集合。例如，"iPhone 15 Pro"是一个SPU，它有通用的描述、品牌、型号等。
- **SKU (Stock Keeping Unit, 库存量单位)**: 产品的最小库存管理单元，是SPU下根据不同销售属性（如颜色、尺寸、容量）组合的具体规格。例如，"iPhone 15 Pro 256GB 蓝色"是一个SKU。每个SKU有独立的价格、库存和图片（可选）。
- **产品分类 (Product Category)**: 用于组织和层级化管理产品，方便用户浏览和筛选。分类可以是多层级的。
- **产品属性 (Product Attribute)**: 描述产品特性的信息。分为：
    - *关键属性/规格属性*: 用于区分不同SKU的属性，如颜色、尺寸、内存大小。
    - *描述属性/普通属性*: 用于丰富产品描述，不影响SKU划分，如材质、产地、保修期。
- **品牌 (Brand)**: 产品的品牌信息。
- **价格 (Price)**: 产品或SKU的销售价格、市场价、成本价等。
- **库存 (Stock/Inventory)**: 特定SKU的可用数量。
- **产品状态 (Product Status)**: 产品的生命周期状态，如草稿、待审核、已上架（在售）、已下架、已删除等。

### 3.2 关键技术考量
- **商品模型设计**: 合理设计SPU与SKU的关系模型，以及属性、规格的存储方式，是模块的核心。
- **数据库选型**: 对于大量的商品数据和复杂的查询需求，需要选择合适的数据库并优化表结构和索引。
- **搜索引擎集成 (可选)**: 对于复杂的商品搜索和筛选需求（如全文搜索、多维度聚合筛选），通常会集成专门的搜索引擎（如Elasticsearch, Solr, Algolia）。
- **图片与多媒体存储**: 大量产品图片、视频等需要高效的存储和CDN分发方案。
- **缓存策略**: 缓存热点商品信息、分类信息、价格信息等，以提高读取性能。
- **库存管理机制**: 需要考虑高并发下的库存扣减准确性（如使用乐观锁、悲观锁或分布式锁，或基于消息队列的最终一致性方案）。

## 四、核心数据实体/模型

1.  **SPU (StandardProductUnit)**
    *   `spu_id` (主键): SPU唯一标识符。
    *   `name` (字符串, 必填): SPU名称 (如 "iPhone 15 Pro")。
    *   `title` (字符串, 可选): 产品营销标题/副标题。
    *   `description` (文本, 可选): 详细描述 (可支持富文本)。
    *   `category_id` (外键, 必填): 所属产品分类ID。
    *   `brand_id` (外键, 可选): 所属品牌ID。
    *   `status` (枚举: draft, active, inactive, archived): SPU状态。
    *   `default_image_url` (字符串, 可选): SPU默认主图。
    *   `attributes` (JSON/结构化数据, 可选): SPU的通用描述属性。
    *   `created_at`, `updated_at` (时间戳)。

2.  **SKU (StockKeepingUnit)**
    *   `sku_id` (主键): SKU唯一标识符。
    *   `spu_id` (外键, 必填): 关联的SPU ID。
    *   `sku_code` (字符串, 可选, 唯一): SKU编码/商家编码。
    *   `name_extension` (字符串, 可选): SKU规格名称的补充 (如 "256GB 蓝色")。
    *   `specifications` (JSON/结构化数据, 必填): 定义此SKU的规格组合 (如 `[{ "name": "颜色", "value": "蓝色" }, { "name": "容量", "value": "256GB" }]`)。
    *   `price` (十进制, 必填): 销售价格。
    *   `market_price` (十进制, 可选): 市场价/划线价。
    *   `cost_price` (十进制, 可选): 成本价。
    *   `stock_quantity` (整数, 默认: 0): 当前库存量。
    *   `low_stock_threshold` (整数, 可选): 低库存预警阈值。
    *   `status` (枚举: enabled, disabled): SKU状态。
    *   `images` (JSON数组, 可选): SKU特定的图片列表 (URL)。
    *   `weight`, `dimensions` (可选): 重量和尺寸信息。
    *   `created_at`, `updated_at` (时间戳)。

3.  **产品分类 (ProductCategory)**
    *   `category_id` (主键): 分类唯一标识符。
    *   `name` (字符串, 必填): 分类名称。
    *   `parent_category_id` (外键, 可选): 父分类ID，支持层级。
    *   `level` (整数, 可选): 分类层级。
    *   `sort_order` (整数, 可选): 排序。
    *   `icon_url` (字符串, 可选): 分类图标。
    *   `is_active` (布尔, 默认: true): 是否激活。

4.  **产品属性名 (AttributeName) / 产品属性值 (AttributeValue)** (可选的规范化设计)
    *   或直接在SPU/SKU中使用JSON存储属性。

5.  **品牌 (Brand)**
    *   `brand_id` (主键)。
    *   `name` (字符串, 必填)。
    *   `logo_url` (字符串, 可选)。

## 五、功能模块划分

1.  **SPU管理模块**
    *   SPU的创建、编辑、查看、删除。
    *   SPU基本信息、描述、通用属性维护。
    *   SPU状态管理（草稿、上架、下架等）。
2.  **SKU管理模块**
    *   基于SPU创建和管理SKU。
    *   SKU的规格组合定义。
    *   SKU独立的价格、库存、图片维护。
    *   SKU启用/禁用状态管理。
3.  **库存管理模块**
    *   SKU库存的查询、增加、扣减（需考虑并发安全）。
    *   低库存预警。
    *   (可选) 多仓库库存管理。
4.  **价格管理模块**
    *   SKU销售价、市场价、成本价的设定与调整。
    *   (可选) 定价策略、会员价、活动价管理。
5.  **分类与品牌管理模块**
    *   产品分类的层级管理（增删改查）。
    *   产品品牌的管理。
6.  **属性与规格管理模块**
    *   定义可用于SPU和SKU的属性和规格（如颜色、尺寸）。
    *   管理属性值选项。
7.  **图片与多媒体管理模块**
    *   上传、管理SPU和SKU的图片、视频等资源。
8.  **产品搜索与查询模块**
    *   提供面向运营后台的产品列表查询、筛选功能。
    *   (若需对外) 提供面向用户的前台产品搜索接口。

## 六、API接口设计指导原则

- **资源**: `products` (可理解为SPU), `products/{spu_id}/skus` (特定SPU下的SKU), `categories`, `brands`, `attributes`。
- **SPU管理API**: (示例)
    - `POST /products`: 创建新SPU (可同时创建默认SKU)。
    - `GET /products`: 获取SPU列表 (支持筛选、分页、排序)。
    - `GET /products/{spu_id}`: 获取SPU详情 (通常包含其下所有SKU信息)。
    - `PUT /products/{spu_id}`: 更新SPU信息。
    - `DELETE /products/{spu_id}`: 删除SPU (需处理关联SKU)。
    - `POST /products/{spu_id}/publish`: 上架SPU。
    - `POST /products/{spu_id}/unpublish`: 下架SPU。
- **SKU管理API**: (示例)
    - `POST /products/{spu_id}/skus`: 为指定SPU创建新SKU。
    - `GET /skus/{sku_id}`: 获取SKU详情。
    - `PUT /skus/{sku_id}`: 更新SKU信息 (如价格、库存、规格图片)。
    - `PATCH /skus/{sku_id}/stock`: 调整SKU库存 (增/减)。
- **分类API**: `GET /categories`, `POST /categories` 等。
- **通用原则**: RESTful, JSON, 标准状态码, 错误处理, 认证授权, 审计日志。

## 七、主要业务流程示例

### 1. 创建一个包含多个SKU的新产品 (SPU)
    1.  运营人员通过后台界面或API提交创建SPU的请求，包含SPU名称、描述、分类、品牌等基础信息。
    2.  API校验数据，创建SPU记录，初始状态可为"草稿"。
    3.  运营人员继续为该SPU添加SKU：
        a.  选择或定义规格属性（如颜色：红、蓝；尺寸：M、L）。
        b.  为每个规格组合（如红+M, 蓝+L）创建SKU，并分别设置价格、初始库存、SKU特定图片等。
        c.  API校验并保存每个SKU信息，关联到对应的SPU。
    4.  运营人员确认无误后，将SPU状态修改为"待上架"或直接"上架"。

### 2. 用户下单扣减SKU库存
    1.  用户在前端选择特定SKU并提交订单。
    2.  订单服务接收请求，校验订单信息。
    3.  订单服务调用产品/库存模块的接口，请求扣减指定SKU的库存。
        *   请求参数：`sku_id`, `quantity_to_deduct`。
    4.  库存模块：
        a.  查询当前SKU库存。
        b.  检查库存是否充足。
        c.  若充足，则执行库存扣减操作（注意并发安全，如使用`UPDATE product_sku SET stock = stock - ? WHERE sku_id = ? AND stock >= ?`）。
        d.  返回扣减成功或失败（如库存不足）的结果给订单服务。
    5.  若库存扣减失败，订单服务标记订单创建失败或进入待处理状态。

## 八、技术考量与开发注意事项

1.  **SPU/SKU模型设计**: 清晰区分SPU和SKU的职责和数据存储，灵活支持多规格。
2.  **库存同步与准确性**: 高并发场景下，库存扣减需保证原子性和准确性。考虑分布式锁、乐观锁或基于消息队列的最终一致性方案。
3.  **价格体系复杂性**: 若涉及多种价格类型（会员价、促销价、阶梯价），需设计灵活的价格管理和计算逻辑。
4.  **属性动态扩展**: 考虑未来新增产品属性和规格的需求，设计可扩展的属性存储方案（如EAV模型或JSON存储，需权衡查询性能）。
5.  **搜索优化**: 对于大量产品，后台管理界面的搜索筛选性能，以及前台（如果需要）的商品搜索体验至关重要。可能需要引入搜索引擎。
6.  **数据一致性**: 产品信息变更（如价格调整、SPU下架）时，需考虑对关联数据（如购物车、订单、营销活动）的影响和同步。
7.  **图片处理与CDN**: 产品图片可能很多，需要高效的上传、处理（缩放、裁剪、水印）和CDN分发方案。
8.  **与外部系统集成**: 可能需要与ERP（库存、订单）、PIM（产品信息管理）、WMS（仓储管理）等系统进行数据同步。
9.  **批量操作**: 支持批量上/下架、调价、修改库存等，提高运营效率。
10. **国际化/多语言**: 若产品面向多区域市场，需支持产品名称、描述、属性的多语言展示。

## 九、数据校验与错误处理

1.  **必填项校验**: 如SPU名称、分类、SKU价格、库存等。
2.  **格式校验**: 如价格、库存数量必须为数字，图片URL格式。
3.  **业务规则校验**: 如SKU价格不能低于成本价（如果配置了），库存不能为负数（除非业务允许预售）。
4.  **唯一性校验**: 如SKU编码的唯一性。
5.  **错误反馈**: 清晰告知用户操作失败的原因。

## 十、安全性考量

1.  **权限控制**: 严格控制对产品数据的增删改查权限，区分不同运营角色。
2.  **价格篡改防护**: 防止恶意用户通过非法手段修改商品价格。
3.  **库存超卖防护**: 严格的库存检查和扣减机制，防止超卖。
4.  **数据操作审计**: 对关键产品信息（如价格、库存）的修改操作记录审计日志。
5.  **敏感信息保护**: (如果产品信息中包含敏感内容) 进行适当处理。 

---

## 文件 3: 后端-场景获客-电话获客功能开发文档.md

*文件大小：16.22 KB*

---

# 存客宝场景获客-电话获客功能开发文档

## 1. 模块概述

电话获客功能是存客宝平台场景获客模块的一部分，主要通过自动化外呼、电话录音分析、意向客户筛选等方式，帮助用户高效获取潜在客户。后端模块负责管理电话资源、外呼任务、通话记录、录音存储及分析结果的处理。本模块与设备控制服务和AI分析服务进行交互。

## 2. API接口设计 (`/api/v1/lead-generation`)

所有接口遵循 **`../前后端接口约定.md`** 定义的 RESTful 规范、请求响应格式、错误处理和认证授权机制。所有接口需要相应的权限控制，具体权限标识符根据权限设计定义（如 `lead:call:create`, `lead:call:view`, `lead:call:edit`）。

### 2.1 创建外呼任务

- **接口路径**：`/api/v1/lead-generation/call-tasks`
- **请求方法**：`POST`
- **接口说明**：创建一个电话外呼任务。
- **权限:** `lead:call:create`
- **请求参数 (Request Body):**

| 参数名          | 类型     | 是否必需 | 说明                         | 示例值                |
|-----------------|----------|----------|------------------------------|-----------------------|
| name            | string   | 是       | 任务名称                     | 新产品推广外呼任务    |
| description     | string   | 否       | 任务描述                     | 针对潜在客户进行新产品推广 |
| phoneNumbers    | array<string> | 是       | 需要外呼的电话号码列表        | `["13800000001", "13800000002"]` |
| callScript      | string   | 是       | 外呼脚本内容                 | 您好，这里是存客宝，... |
| scheduledTime   | string   | 否       | 计划执行时间 (ISO 8601格式)  | 2023-10-26T10:00:00Z   |
| callerId        | string   | 否       | 外显号码                     | 0592-XXXXXXX         |
| deviceIds       | array<integer> | 否       | 指定执行任务的设备或线路ID列表 | `[1, 2]`              |
| tags            | array<string> | 否       | 为本次获客添加标签           | `["高意向", "新客"]`     |
| source          | string   | 否       | 线索来源 (例如: "电话外呼")  | 电话外呼              |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "taskId": 101,           // 新创建任务的ID
  "name": "新产品推广外呼任务",
  "status": "SCHEDULED", // 任务状态 (SCHEDULED, RUNNING, COMPLETED, FAILED, CANCELLED)
  "createTime": "2023-10-25T15:00:00Z"
}
```
- **可能返回状态码:** 201, 400 (参数错误), 401, 403, 422 (数据验证失败), 500

### 2.2 获取外呼任务列表

- **接口路径**：`/api/v1/lead-generation/call-tasks`
- **请求方法**：`GET`
- **接口说明**：获取外呼任务列表，支持多条件查询和分页。
- **权限:** `lead:call:view` 或 `lead:call:list`
- **请求参数 (Query Parameters):**

| 参数名       | 类型    | 是否必需 | 描述                           | 示例值                       |
|-------------|--------|----------|--------------------------------|-----------------------------|
| name        | string | 否       | 任务名称关键字 (模糊匹配)      | 推广                         |
| status      | string | 否       | 任务状态 (SCHEDULED, RUNNING...) | RUNNING                     |
| startTime   | string | 否       | 创建开始时间 (ISO 8601格式)    | 2023-10-01T00:00:00Z        |
| endTime     | string | 否       | 创建结束时间 (ISO 8601格式)    | 2023-10-31T23:59:59Z        |
| page        | integer| 否       | 页码，从1开始 (默认: 1)        | 1                           |
| size        | integer| 否       | 每页条数 (默认: 10)          | 10                          |
| sort        | string | 否       | 排序字段 (如: createTime)      | createTime                  |
| order       | string | 否       | 排序方向 (asc/desc)            | desc                        |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "taskId": 101,
      "name": "新产品推广外呼任务",
      "description": "针对潜在客户进行新产品推广",
      "status": "COMPLETED",
      "scheduledTime": "2023-10-26T10:00:00Z",
      "createTime": "2023-10-25T15:00:00Z",
      "completedTime": "2023-10-26T11:30:00Z",
      "totalCalls": 100,     // 总外呼次数
      "successfulCalls": 80, // 成功接通次数
      "intendedCustomers": 30 // 意向客户数 (根据分析结果)
      // ... 其他任务统计信息
    }
    // ... 更多任务记录
  ],
  "total": 50,            // 总记录数
  "size": 10,             // 每页大小
  "current": 1,           // 当前页码
  "pages": 5              // 总页数
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

### 2.3 获取外呼任务详情

- **接口路径**：`/api/v1/lead-generation/call-tasks/{taskId}`
- **请求方法**：`GET`
- **接口说明**：获取指定外呼任务的详情，包括任务基本信息、关联的通话记录列表等。
- **权限:** `lead:call:view`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 描述    | 示例值 |
|--------|---------|----------|---------|--------|
| taskId | integer | 是       | 任务ID  | 101    |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "taskId": 101,
  "name": "新产品推广外呼任务",
  "description": "针对潜在客户进行新产品推广",
  "status": "COMPLETED",
  "scheduledTime": "2023-10-26T10:00:00Z",
  "createTime": "2023-10-25T15:00:00Z",
  "completedTime": "2023-10-26T11:30:00Z",
  "totalCalls": 100,
  "successfulCalls": 80,
  "intendedCustomers": 30,
  "phoneNumbers": ["13800000001", "13800000002", ...], // 任务包含的电话列表
  "callScript": "您好，这里是存客宝，...",
  "callerId": "0592-XXXXXXX",
  "deviceIds": [1, 2], // 任务使用的设备列表
  "callRecords": [     // 关联的通话记录简要列表
    {
      "recordId": 201,
      "phoneNumber": "13800000001",
      "startTime": "2023-10-26T10:01:00Z",
      "duration": 60, // 秒
      "analysisStatus": "COMPLETED"
    }
    // ... 更多通话记录
  ]
}
```
- **可能返回状态码:** 200, 401, 403, 404, 500

### 2.4 获取通话记录列表

- **接口路径**：`/api/v1/lead-generation/call-records`
- **请求方法**：`GET`
- **接口说明**：获取通话记录列表，支持多条件查询、分页和按任务筛选。
- **权限:** `lead:call:view` 或 `lead:call:record:list`
- **请求参数 (Query Parameters):**

| 参数名        | 类型    | 是否必需 | 描述                     | 示例值                |
|---------------|--------|----------|--------------------------|-----------------------|
| taskId        | integer| 否       | 按任务ID过滤             | 101                   |
| phoneNumber   | string | 否       | 按电话号码过滤 (精确匹配)| 13800000001           |
| analysisStatus| string | 否       | 分析状态过滤 (PENDING...) | COMPLETED             |
| startTime     | string | 否       | 通话开始时间范围起始 (ISO 8601)| 2023-10-01T00:00:00Z |
| endTime       | string | 否       | 通话开始时间范围结束 (ISO 8601)| 2023-10-31T23:59:59Z |
| page          | integer| 否       | 页码                     | 1                     |
| size          | integer| 否       | 每页条数                 | 10                    |
| sort          | string | 否       | 排序字段                 | startTime             |
| order         | string | 否       | 排序方向                 | desc                  |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "recordId": 201,
      "taskId": 101,
      "phoneNumber": "13800000001",
      "startTime": "2023-10-26T10:01:00Z",
      "endTime": "2023-10-26T10:02:00Z",
      "duration": 60, // 秒
      "recordingUrl": "https://example.com/recordings/abc.mp3",
      "analysisStatus": "COMPLETED", // 分析状态
      "analysisResult": { // 分析结果简要信息
          "sentiment": "POSITIVE",
          "intention": "高意向"
      }
      // ... 其他通话记录详情
    }
    // ... 更多通话记录
  ],
  "total": 80,
  "size": 10,
  "current": 1,
  "pages": 8
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

### 2.5 获取通话记录详情 (包含完整分析结果)

- **接口路径**：`/api/v1/lead-generation/call-records/{recordId}`
- **请求方法**：`GET`
- **接口说明**：获取指定通话记录的详细信息，包括完整的录音分析结果。
- **权限:** `lead:call:record:view`
- **请求参数 (Path Parameters):**

| 参数名   | 类型    | 是否必需 | 描述       | 示例值 |
|----------|---------|----------|------------|--------|
| recordId | integer | 是       | 通话记录ID | 201    |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "recordId": 201,
  "taskId": 101,
  "phoneNumber": "13800000001",
  "startTime": "2023-10-26T10:01:00Z",
  "endTime": "2023-10-26T10:02:00Z",
  "duration": 60, // 秒
  "recordingUrl": "https://example.com/recordings/abc.mp3",
  "analysisStatus": "COMPLETED",
  "analysisResult": { // 完整的分析结果
    "sentiment": "POSITIVE",        // 情感分析
    "intention": "高意向",          // 意向判断
    "keywords": ["产品", "价格", "合作"], // 关键词提取
    "summary": "用户对产品表现出高意向，询问了价格和合作方式...", // 通话摘要
    "transcription": "用户：你好，请问...\n客服：您好，..." // 通话转录文本
    // ... 其他分析维度
  }
  // ... 其他通话记录详情
}
```
- **可能返回状态码:** 200, 401, 403, 404, 500

### 2.6 获取通话录音文件

- **接口路径**：`/api/v1/lead-generation/call-records/{recordId}/recording`
- **请求方法**：`GET`
- **接口说明**：获取指定通话记录的录音文件URL或直接返回文件流。
- **权限:** `lead:call:record:download`
- **请求参数 (Path Parameters):**

| 参数名   | 类型    | 是否必需 | 描述       | 示例值 |
|----------|---------|----------|------------|--------|
| recordId | integer | 是       | 通话记录ID | 201    |

- **响应数据:** 直接返回文件流或重定向到文件URL。如果返回URL，响应格式可能如下：

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "recordingUrl": "https://example.com/recordings/abc.mp3?token=..." // 带有时效性签名的URL
  }
}
```
- **可能返回状态码:** 200, 401, 403, 404, 500

### 2.7 更新外呼任务状态

- **接口路径**：`/api/v1/lead-generation/call-tasks/{taskId}/status`
- **请求方法**：`PUT`
- **接口说明**：更新外呼任务的状态（如暂停、继续、取消）。
- **权限:** `lead:call:edit`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 描述    | 示例值 |
|--------|---------|----------|---------|--------|
| taskId | integer | 是       | 任务ID  | 101    |

- **请求体 (Request Body):**

```json
{
  "status": "PAUSED" // 新的任务状态 (PAUSED, RUNNING, CANCELLED)
}
```
- **响应数据 (统一格式 `data` 字段):**

```json
{
  "updated": true // 表示更新成功
}
```
- **可能返回状态码:** 200, 400 (状态转换非法), 401, 403, 404, 500

## 3. 数据模型设计

### 3.1 主要数据表

| 表名                 | 说明          | 关键字段                     | 与其他表关系 |
|---------------------|--------------|-----------------------------|------------|
| t_call_task         | 外呼任务表    | id, name, status, scheduled_time |            |
| t_call_record       | 通话记录表    | id, task_id, phone_number, start_time, end_time, duration, recording_url, analysis_status | task_id -> t_call_task |
| t_call_analysis     | 通话分析结果表| id, record_id, sentiment, keywords, intention_score, summary, transcription | record_id -> t_call_record |
| t_call_task_phones  | 任务电话号码关联表 | task_id, phone_number      | task_id -> t_call_task |
| t_call_task_devices | 任务设备关联表 | task_id, device_id         | task_id -> t_call_task, device_id -> t_device (假设的设备表) |

补充了任务与电话号码和设备的关联表，以支持一个任务包含多个电话或使用多个设备。

## 4. 服务实现 (Service Implementation)

### 4.1 `CallTaskService`

负责外呼任务的生命周期管理：创建、查询、更新状态、删除。协调与设备控制服务和任务调度服务的交互。

- **关键方法:**
    - `createCallTask(CallTaskDTO dto)`: 创建任务记录，安排定时任务或立即执行。
    - `executeCallTask(Long taskId)`: 获取任务详情和关联电话/设备，调用设备控制服务发起外呼，更新任务状态。
    - `scheduleCallTask(CallTask task)`: 使用任务调度服务安排定时执行。
    - `getCallTaskList(CallTaskQuery query)`: 分页查询任务列表。
    - `getCallTaskDetail(Long taskId)`: 获取任务详情。
    - `updateCallTaskStatus(Long taskId, CallTaskStatus status)`: 更新任务状态。

### 4.2 `CallRecordService`

负责通话记录的管理：保存、查询。接收设备端上报的通话数据，触发录音分析。

- **关键方法:**
    - `saveCallRecord(CallRecordDTO dto)`: 保存通话记录，触发分析。
    - `getCallRecordList(CallRecordQuery query)`: 分页查询通话记录列表。
    - `getCallRecordDetail(Long recordId)`: 获取通话记录详情。
    - `getRecordingUrl(Long recordId)`: 获取录音文件URL。

### 4.3 `CallAnalysisService`

负责调用AI服务进行录音分析：转录、关键词提取、情感/意向判断、摘要生成。保存分析结果。

- **关键方法:**
    - `analyzeRecording(Long recordId, String recordingUrl)`: 调用AI服务进行分析，保存结果，更新通话记录分析状态。
    - `getAnalysisResult(Long recordId)`: 获取指定通话记录的分析结果。

### 4.4 `DeviceControlService` (依赖模块)

负责与实际外呼设备进行通信，执行外呼指令，上报通话事件和数据。

- **关键方法:**
    - `executeCommand(Long deviceId, DeviceCommand command)`: 向指定设备发送指令 (如 MAKE_CALL)。
    - `handleCallEvent(CallEvent event)`: 处理设备上报的通话事件 (如接通、挂断、录音上传)。

### 4.5 `TaskSchedulerService` (依赖模块)

负责管理定时任务的调度。

- **关键方法:**
    - `schedule(Runnable task, Date time)`: 安排一个一次性定时任务。
    - `cancel(Long taskId)`: 取消定时任务。

## 5. 数据验证

对所有接收到的请求参数和请求体进行严格验证，例如：

- 创建外呼任务时，校验 `name`, `phoneNumbers`, `callScript` 是否为空，`phoneNumbers` 是否为有效的电话号码列表。
- 更新任务状态时，校验 `status` 是否为有效的状态值。

使用 Spring Validation 框架结合注解实现。

## 6. 错误处理

遵循 `./前后端接口约定.md` 中的错误处理规范。捕获并处理常见的异常，例如：

- 参数校验失败 (`MethodArgumentNotValidException`) 返回 422。
- 资源未找到 (`TaskNotFoundException`, `RecordNotFoundException`) 返回 404。
- 权限不足 (`AccessDeniedException`) 返回 403。
- 业务逻辑错误（如设备不足、状态转换非法）返回 400 或特定的业务错误码。
- 系统内部错误返回 500。

## 7. 日志记录

记录关键操作日志，包括：

- 外呼任务的创建、更新、状态变更。
- 通话记录的保存、分析结果更新。
- 与设备控制服务和AI分析服务的交互日志。
- 异常日志。

日志应包含操作人、操作时间、任务/记录ID、操作结果等信息。

## 8. 性能与并发

- 对于大规模外呼任务，考虑将外呼执行逻辑放入消息队列进行异步处理，避免阻塞。
- 合理设计数据库索引，优化查询性能。
- 适当使用缓存（如 Redis）存储任务状态、设备状态等常用数据。

## 9. 安全性

- 所有接口必须进行认证授权校验。
- 对外显号码、外呼脚本等敏感信息进行适当的安全处理和访问控制。
- 录音文件存储和访问需要安全保障，例如使用带有时效性签名的URL。

---

> 本文档详细说明了存客宝后端场景获客-电话获客功能的设计与实现要点，开发时请严格遵循上述规范，确保系统功能完善和安全稳定。 

---

## 文件 4: 后端-场景获客-订单获客功能开发文档.md

*文件大小：15.24 KB*

---

# 存客宝场景获客-订单获客功能开发文档

## 1. 模块概述

订单获客功能旨在通过对接电商平台，自动化抓取用户的订单数据，从中识别潜在的私域客户，并进行后续的触达和转化。后端模块负责电商平台的授权管理、订单数据同步、数据清洗与分析、潜在客户识别及数据存储。本模块与客户管理、线索管理和AI智能过滤服务进行交互。

## 2. API接口设计 (`/api/v1/lead-generation/orders`)

所有接口遵循 **`../前后端接口约定.md`** 定义的 RESTful 规范、请求响应格式、错误处理和认证授权机制。所有接口需要相应的权限控制，具体权限标识符根据权限设计定义（如 `lead:order:auth`, `lead:order:sync`, `lead:order:view`）。

##### 2.1 添加电商平台授权

- **接口路径**：`/api/v1/lead-generation/orders/platforms/auth`
- **请求方法**：`POST`
- **接口说明**：添加一个电商平台的授权信息（如淘宝、京东）。
- **权限:** `lead:order:auth`
- **请求参数 (Request Body):**

| 参数名          | 类型     | 是否必需 | 说明                         | 示例值                  |
|-----------------|----------|----------|------------------------------|-------------------------|
| platformType    | string   | 是       | 电商平台类型：`TAOBAO`, `JD`, `PDD`等 | `TAOBAO`                |
| authInfo        | object   | 是       | 平台授权信息，具体结构依赖平台 | `{ "appKey": "...", "appSecret": "...", "callbackUrl": "..." }` |
| redirectUrl     | string   | 否       | 授权成功后回调前端的URL      | `https://your-frontend.com/auth/callback` |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "platformId": 201,        // 新创建的平台授权记录ID
  "platformType": "TAOBAO",
  "status": "PENDING_AUTH", // 授权状态 (PENDING_AUTH, ACTIVE, EXPIRED, INVALID)
  "authUrl": "https://auth.example.com/oauth?clientId=..." // 如果需要前端跳转授权，返回授权URL
}
```
- **可能返回状态码:** 201, 400 (参数错误), 401, 403, 422 (数据验证失败), 500

##### 2.2 获取授权列表

- **接口路径**：`/api/v1/lead-generation/orders/platforms`
- **请求方法**：`GET`
- **接口说明**：获取已添加的电商平台授权列表。
- **权限:** `lead:order:view`
- **请求参数 (Query Parameters):** 支持分页、按平台类型过滤等（根据需要补充详细参数）

| 参数名       | 类型    | 是否必需 | 描述                 | 示例值 |
|-------------|--------|----------|----------------------|--------|
| platformType| string | 否       | 按平台类型过滤       | TAOBAO |
| status      | string | 否       | 按授权状态过滤       | ACTIVE |
| page        | integer| 否       | 页码                 | 1      |
| size        | integer| 否       | 每页条数             | 10     |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "platformId": 201,
      "platformType": "TAOBAO",
      "status": "ACTIVE",
      "expiryTime": "2024-10-25T15:00:00Z",
      "createTime": "2023-10-25T15:00:00Z"
      // 授权信息（authInfo）通常不直接返回给前端，除非必要且脱敏处理
    }
    // ... 更多授权记录
  ],
  "total": 10,
  "size": 10,
  "current": 1,
  "pages": 1
}
```
- **可能返回状态码:** 200, 401, 403, 500

##### 2.3 手动触发订单同步

- **接口路径**：`/api/v1/lead-generation/orders/platforms/{platformId}/sync`
- **请求方法**：`POST`
- **接口说明**：手动触发指定电商平台的订单数据同步任务。
- **权限:** `lead:order:sync`
- **请求参数 (Path Parameters):**

| 参数名      | 类型    | 是否必需 | 描述           | 示例值 |
|-------------|---------|----------|----------------|--------|
| platformId  | integer | 是       | 电商平台授权ID | 201    |

- **请求体 (Request Body):** 通常为空或包含同步的时间范围等可选参数。

```json
{
  "startTime": "2023-10-01T00:00:00Z", // 可选：指定同步的起始时间
  "endTime": "2023-10-31T23:59:59Z"   // 可选：指定同步的结束时间
}
```
- **响应数据 (统一格式 `data` 字段):** 返回触发同步任务的结果或任务ID。

```json
{
  "syncTaskId": 301,         // 同步任务ID
  "status": "ACCEPTED"       // 任务状态：ACCEPTED, REJECTED
}
```
- **可能返回状态码:** 200, 400 (参数错误/平台状态异常), 401, 403, 404, 409 (任务已在运行), 500

##### 2.4 获取订单同步记录

- **接口路径**：`/api/v1/lead-generation/orders/sync-records`
- **请求方法**：`GET`
- **接口说明**：获取订单同步记录列表，查看同步状态和结果。
- **权限:** `lead:order:view`
- **请求参数 (Query Parameters):** 支持分页、按平台、状态、时间范围过滤。

| 参数名       | 类型    | 是否必需 | 描述                 | 示例值                       |
|-------------|--------|----------|----------------------|-----------------------------|
| platformId  | integer| 否       | 按平台授权ID过滤     | 201                         |
| status      | string | 否       | 按同步状态过滤       | COMPLETED                   |
| startTime   | string | 否       | 同步开始时间范围起始 | 2023-10-01T00:00:00Z        |
| endTime     | string | 否       | 同步开始时间范围结束 | 2023-10-31T23:59:59Z        |
| page        | integer| 否       | 页码                 | 1                           |
| size        | integer| 否       | 每页条数             | 10                          |
| sort        | string | 否       | 排序字段             | syncTime                    |
| order       | string | 否       | 排序方向             | desc                        |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "syncId": 301,
      "platformId": 201,
      "platformType": "TAOBAO",
      "syncTime": "2023-10-26T15:00:00Z",
      "status": "COMPLETED", // 同步状态 (RUNNING, COMPLETED, FAILED, CANCELLED)
      "successCount": 100, // 成功同步订单数
      "failureCount": 5,   // 同步失败订单数
      "errorMessage": ""   // 失败原因
    }
    // ... 更多同步记录
  ],
  "total": 20,
  "size": 10,
  "current": 1,
  "pages": 2
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

##### 2.5 获取潜在客户列表（来自订单）

- **接口路径**：`/api/v1/lead-generation/orders/leads`
- **请求方法**：`GET`
- **接口说明**：获取从订单数据中识别出的潜在客户列表，支持多条件查询和分页。
- **权限:** `lead:order:view`
- **请求参数 (Query Parameters):** 支持分页、按平台、时间、客户信息、处理状态等过滤。

| 参数名        | 类型    | 是否必需 | 描述                     | 示例值                |
|---------------|--------|----------|--------------------------|-----------------------|
| platformId    | integer| 否       | 按平台授权ID过滤         | 201                   |
| orderTimeStart| string | 否       | 订单时间范围起始 (ISO 8601)| 2023-10-01T00:00:00Z |
| orderTimeEnd  | string | 否       | 订单时间范围结束 (ISO 8601)| 2023-10-31T23:59:59Z |
| contactInfo   | string | 否       | 客户联系信息关键字       | 138                   |
| processStatus | string | 否       | 处理状态 (PENDING, PROCESSED) | PENDING             |
| intentionTags | array<string> | 否 | 按意向标签过滤           | `["高意向"]`         |
| page          | integer| 否       | 页码                     | 1                     |
| size          | integer| 否       | 每页条数                 | 10                    |
| sort          | string | 否       | 排序字段                 | orderTime             |
| order         | string | 否       | 排序方向                 | desc                  |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "leadId": 401,         // 潜在客户记录ID
      "orderId": "123456789",// 关联的电商订单ID
      "platformType": "TAOBAO",
      "orderTime": "2023-10-26T10:00:00Z",
      "contactInfo": "13800000001", // 客户联系信息 (可能已脱敏)
      "productInfo": "XX产品",     // 订单商品信息简要
      "intentionTags": ["高意向", "购买过"], // 识别出的意向标签
      "processStatus": "PENDING",  // 处理状态 (待处理, 已处理, 无效)
      "createTime": "2023-10-26T11:00:00Z"
      // ... 其他相关信息
    }
    // ... 更多潜在客户记录
  ],
  "total": 50,
  "size": 10,
  "current": 1,
  "pages": 5
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

---

## 3. 数据模型设计

##### 3.1 主要数据表

| 表名                       | 说明              | 关键字段                                         | 与其他表关系 |
|---------------------------|------------------|-------------------------------------------------|------------|
| t_ecom_platform_auth      | 电商平台授权表    | id, platform_type, auth_info (加密), status, expiry_time, last_sync_time |            |
| t_ecom_order_raw          | 电商原始订单数据表| id, platform_id, order_id (平台方), raw_data, sync_time, process_status | platform_id -> t_ecom_platform_auth |
| t_ecom_order_processed    | 电商处理后订单表  | id, platform_id, order_id (平台方), user_id (关联客户/线索), amount, order_time, product_info, contact_info (脱敏/加密) | platform_id -> t_ecom_platform_auth, user_id -> t_customer/t_lead |
| t_order_lead              | 订单潜在客户表    | id, order_id (系统生成), raw_order_id (关联原始订单), contact_info, intention_tags, process_status, create_time | raw_order_id -> t_ecom_order_raw |

补充了数据表之间的关系，并在字段说明中增加了加密/脱敏的提示。

#### 4. 服务实现 (Service Implementation)

简要说明核心服务的职责和关键方法。

##### 4.1 `EcomPlatformAuthService`

负责电商平台授权信息的管理：添加、更新、查询授权状态。处理 OAuth 流程，包括生成授权 URL，处理授权回调，刷新令牌等。负责授权信息的安全存储（加密）。

- **关键方法:**
    - `addPlatformAuth(EcomPlatformAuthDTO dto)`: 添加授权记录，生成授权URL。
    - `handleAuthCallback(CallbackDTO dto)`: 处理平台授权回调，获取并保存Access/Refresh Token，更新授权状态。
    - `refreshAccessToken(Long platformId)`: 刷新过期Access Token。
    - `getAuthList(AuthQuery query)`: 查询授权列表。
    - `getAuthDetail(Long platformId)`: 获取授权详情。
    - `updateAuthStatus(Long platformId, AuthStatus status)`: 更新授权状态。

##### 4.2 `OrderSyncService`

负责与电商平台API对接，定期或手动触发订单数据同步任务。协调与 `ApiService`、`OrderProcessingService`、`OrderSyncLogRepository` 的交互。处理同步过程中的异常和日志记录。

- **关键方法:**
    - `scheduledSyncOrders()`: 定时扫描并触发订单同步。
    - `manualSyncOrders(Long platformId, Date startTime, Date endTime)`: 手动触发指定时间范围的订单同步。
    - `syncOrdersFromPlatform(EcomPlatformAuth auth, Date startTime, Date endTime)`: 根据授权信息和时间范围调用 `ApiService` 获取订单，保存原始数据，触发处理。
    - `getSyncRecords(SyncRecordQuery query)`: 查询同步记录列表。

##### 4.3 `ApiService` (依赖或通用服务)

负责封装和适配不同电商平台的API调用细节，提供统一的接口供 `OrderSyncService` 调用。内部根据 `platformType` 调用不同的平台SDK或HTTP客户端。

- **关键方法:**
    - `callApi(String platformType, String apiMethod, Map<String, Object> params)`: 调用指定平台、方法的API，返回原始响应。
    - `getOrders(String platformType, Map<String, Object> queryParams)`: 封装获取订单列表的通用API调用。

##### 4.4 `OrderProcessingService`

负责对原始订单数据进行清洗、标准化，识别潜在客户信息，进行 AI 智能过滤，并保存到相应的表中（`t_ecom_order_processed`, `t_order_lead`）。可能需要调用客户管理或线索管理服务将潜在客户数据沉淀到主业务表中。

- **关键方法:**
    - `processRawOrders(List<EcomOrderRaw> rawOrders)`: 处理原始订单列表，进行清洗、转换、识别潜在客户。
    - `identifyLead(EcomOrderProcessed order)`: 根据订单信息识别是否为潜在客户，提取关键联系信息。
    - `applyAiFilter(OrderLead lead)`: 调用AI智能过滤服务对潜在客户进行过滤或意向判断。
    - `saveProcessedOrder(EcomOrderProcessed order)`: 保存处理后的订单数据。
    - `saveOrderLead(OrderLead lead)`: 保存潜在客户信息，并同步到客户/线索模块。

##### 4.5 `AiFilteringService` (依赖模块)

负责提供 AI 智能过滤能力，例如对客户联系方式进行有效性校验、判断潜在客户的意向程度等。

- **关键方法:**
    - `filterContactInfo(String contactInfo)`: 校验联系信息有效性。
    - `predictIntention(OrderLead lead)`: 预测潜在客户意向。

#### 5. 数据验证

对所有接收到的请求参数和请求体进行严格验证，例如：

- 添加授权时，校验 `platformType` 和 `authInfo` 的合法性。
- 手动触发同步时，校验 `platformId` 是否有效，时间范围是否合法。

使用 Spring Validation 框架结合注解实现。验证失败时，按照 `../前后端接口约定.md` 中的约定返回 422 状态码和详细的错误信息列表。

#### 6. 错误处理

遵循 `./前后端接口约定.md` 中的错误处理规范。捕获并处理常见的异常，例如：

- 参数校验失败 (`MethodArgumentNotValidException`) 返回 422。
- 电商平台授权相关的错误（如授权过期、Token 无效）返回 400 或特定业务错误码。
- 调用电商平台 API 失败返回 500 或特定业务错误码。
- 数据处理过程中的异常返回 500 或特定业务错误码。
- 权限不足 (`AccessDeniedException`) 返回 403。

#### 7. 日志记录

记录关键操作日志，包括：

- 电商平台授权的添加、更新。
- 订单同步任务的触发、状态变更、成功/失败数量。
- 订单数据处理过程中的关键步骤和异常。
- 潜在客户的识别和沉淀日志。
- 与外部服务（电商平台 API, AI 服务）的交互日志。

日志应包含操作人、操作时间、平台/任务ID、操作结果、错误信息等信息。

#### 8. 性能与并发

- 订单数据同步和处理可能涉及大量数据，考虑使用消息队列进行异步处理，避免阻塞请求。
- 电商平台 API 调用可能存在限流，需要实现相应的限流和重试机制。
- 数据库操作（批量插入原始订单、批量更新处理状态）需要进行性能优化。

#### 9. 安全性

- 电商平台授权信息（App Secret, Access Token, Refresh Token 等）必须进行加密存储。
- 传输过程中使用 HTTPS 保护敏感数据。
- 潜在客户的联系方式等敏感信息在存储和展示时需要进行脱敏处理。
- 所有接口必须进行认证授权校验。

---

> 本文档详细说明了存客宝后端场景获客-订单获客功能的设计与实现要点，开发时请严格遵循上述规范，确保系统功能完善和安全稳定。 

---

## 文件 5: 后端-场景获客-抖音获客功能开发文档.md

*文件大小：8.08 KB*

---

# 存客宝场景获客 - 抖音获客功能后端开发文档

## 1. 模块概述

抖音获客功能旨在通过对接抖音开放平台或相关渠道，实现从抖音平台获取潜在客户信息的能力。这可能包括用户授权、数据抓取、线索同步等。

## 2. API接口设计

### 2.1 抖音授权回调接口

- **接口路径**：`/api/v1/lead/douyin/auth/callback`
- **请求方法**：`GET`
- **接口说明**：处理抖音开放平台的授权回调请求，获取授权码并进一步获取 access_token。
- **权限:** 无需登录权限，但需要进行签名校验等安全措施。
- **请求参数 (Query Parameters):**

| 参数名  | 类型    | 是否必需 | 描述         | 示例值 |
|---------|--------|----------|--------------|--------|
| code    | string | 是       | 抖音授权码   | xxx    |
| state   | string | 是       | 状态码，用于防止 CSRF 攻击 | yyy |

- **响应数据 (统一格式 `data` 字段):** 返回授权结果或重定向到前端页面。

```json
{
  "message": "授权成功",
  "userId": 1001, // 关联的存客宝用户ID
  "douyinUserId": "抖音用户在平台的唯一标识"
}
```
- **可能返回状态码:** 200 (成功), 400 (参数错误), 500 (服务器错误)

### 2.2 获取抖音授权链接

- **接口路径**：`/api/v1/lead/douyin/auth/url`
- **请求方法**：`GET`
- **接口说明**：生成抖音授权链接，供前端引导用户进行授权。
- **权限:** `lead:douyin:auth:get_url`
- **请求参数 (Query Parameters):**

| 参数名     | 类型    | 是否必需 | 描述         | 示例值 |
|------------|--------|----------|--------------|--------|
| redirectUrl| string | 否       | 授权成功后的回调URL (前端页面) | http://your-app.com/callback |

- **响应数据 (统一格式 `data` 字段):** 返回抖音授权链接。

```json
{
  "authUrl": "https://open.douyin.com/platform/oauth/connect?client_key=xxx&redirect_uri=yyy&response_type=code&scope=zzz&state=aaa"
}
```
- **可能返回状态码:** 200, 401, 403, 500

### 2.3 同步抖音粉丝数据

- **接口路径**：`/api/v1/lead/douyin/fans/sync`
- **请求方法**：`POST`
- **接口说明**：根据用户授权，同步抖音账号的粉丝列表数据。
- **权限:** `lead:douyin:fans:sync`
- **请求参数 (Request Body):**

| 参数名      | 类型   | 是否必需 | 描述         | 示例值 |
|-------------|--------|----------|--------------|--------|
| douyinUserId| string | 是       | 抖音用户在平台的唯一标识 | "抖音用户ID" |
| syncStrategy| string | 否       | 同步策略 (INCREMENTAL, FULL) | INCREMENTAL |

- **响应数据 (统一格式 `data` 字段):** 返回同步任务状态或结果概述。

```json
{
  "taskId": "同步任务ID",
  "status": "PROCESSING", // PENDING, PROCESSING, COMPLETED, FAILED
  "message": "粉丝数据同步中"
}
```
- **可能返回状态码:** 200, 202 (已接受处理), 400, 401, 403, 500

### 2.4 查询抖音获客线索列表

- **接口路径**：`/api/v1/lead/douyin/leads`
- **请求方法**：`GET`
- **接口说明**：查询通过抖音渠道获取的线索列表。
- **权限:** `lead:douyin:leads:view`
- **请求参数 (Query Parameters):**

| 参数名      | 类型    | 是否必需 | 描述             | 示例值 |
|-------------|--------|----------|------------------|--------|
| startTime   | string | 否       | 获取时间开始 (ISO 8601) |        |
| endTime     | string | 否       | 获取时间结束 (ISO 8601) |        |
| keyword     | string | 否       | 关键字搜索 (昵称, 备注等) |        |
| page        | integer| 否       | 页码             | 1      |
| size        | integer| 否       | 每页条数         | 10     |

- **响应数据 (统一格式 `data` 字段):** 返回线索列表（支持分页）。

```json
{
  "records": [
    {
      "leadId": 1001,
      "channel": "抖音获客",
      "nickname": "抖音用户昵称",
      "avatarUrl": "头像URL",
      "douyinUserId": "抖音用户ID",
      "acquireTime": "2023-10-26T11:00:00Z", // 获取时间
      "status": "NEW", // NEW, CONTACTED, CONVERTED
      "notes": "用户备注"
    }
    // ... 更多线索
  ],
  "total": 100,
  "size": 10,
  "current": 1,
  "pages": 10
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

## 3. 数据模型设计

### 3.1 抖音授权信息表 `t_douyin_auth`

存储存客宝用户与抖音账号的授权关联信息。

| 字段名        | 类型         | 是否必需 | 说明             | 索引        |
|--------------|--------------|----------|------------------|------------|
| id           | BIGINT (PK)  | 是       | 主键             |            |
| user_id      | BIGINT (FK)  | 是       | 存客宝用户ID     | Index      |
| douyin_user_id| VARCHAR(100) | 是       | 抖音开放平台用户唯一标识 | UNIQUE Index |
| access_token | VARCHAR(255) | 是       | 抖音 API 访问令牌 |            |
| refresh_token| VARCHAR(255) | 是       | 抖音 API 刷新令牌 |            |
| expire_time  | DATETIME     | 是       | access_token 过期时间 |            |
| scope        | VARCHAR(255) | 否       | 授权范围         |            |
| create_time  | DATETIME     | 是       | 创建时间         |            |
| update_time  | DATETIME     | 是       | 更新时间         |            |

### 3.2 抖音获客线索表 `t_douyin_lead`

存储从抖音获取的线索信息。

| 字段名        | 类型         | 是否必需 | 说明             | 索引        |
|--------------|--------------|----------|------------------|------------|
| id           | BIGINT (PK)  | 是       | 主键             |            |
| lead_id      | BIGINT (FK)  | 是       | 关联到统一线索表的ID (如果存在) | Index      |
| douyin_user_id| VARCHAR(100) | 是       | 抖音开放平台用户唯一标识 | Index      |
| nickname     | VARCHAR(100) | 否       | 抖音用户昵称     |            |
| avatar_url   | VARCHAR(500) | 否       | 抖音用户头像URL  |            |
| acquire_time | DATETIME     | 是       | 线索获取时间     | Index      |
| status       | VARCHAR(20)  | 是       | 线索状态 (NEW, CONTACTED, CONVERTED) | Index      |
| notes        | TEXT         | 否       | 用户备注         |            |
| create_time  | DATETIME     | 是       | 创建时间         |            |
| update_time  | DATETIME     | 是       | 更新时间         |            |

## 4. 异常处理

- `DouyinApiException`: 调用抖音开放平台 API 异常
- `DouyinAuthException`: 抖音授权相关异常
- `DouyinLeadSyncException`: 抖音线索同步异常
- `InvalidDouyinLeadQueryException`: 查询参数无效异常

## 5. 开发注意事项和实现要点

1.  **抖音开放平台对接:**
    - 熟悉抖音开放平台的 API 文档，特别是授权、用户信息、粉丝列表等接口。
    - 处理 access_token 的获取、存储和刷新机制。
    - 确保 API 请求的安全性，包括签名、参数校验等。
2.  **授权流程:**
    - 实现 OAuth 2.0 授权流程，包括引导用户跳转到抖音授权页、处理回调、获取 access_token 和 refresh_token。
    - 使用 state 参数防止 CSRF 攻击。
3.  **数据同步:**
    - 设计稳定可靠的粉丝数据同步任务，可以采用定时任务或异步队列的方式。
    - 处理数据重复和增量更新问题。
    - 考虑抖音 API 的调用频率限制。
4.  **线索统一管理:**
    - 如果有统一的线索管理模块，需要将从抖音获取的线索数据同步到统一线索表，保持数据一致性。
    - 设计线索状态流转（如新线索 -> 已联系 -> 已转化）。
5.  **异常处理:**
    - 捕获并处理与抖音 API 交互过程中可能出现的各种异常，并记录详细日志。
    - 对于授权失败或同步失败，需要有重试或告警机制。
6.  **敏感信息:**
    - 抖音 API 的 access_token 和 refresh_token 是敏感信息，需要加密存储。
7.  **前端交互:**
    - 前端需要调用接口获取授权链接，并在用户完成授权后，由后端处理回调。
    - 前端需要调用接口查询和展示抖音获客线索列表。

--- 

---

## 文件 6: 后端-场景获客-付款码获客功能开发文档.md

*文件大小：22.66 KB*

---

# 存客宝场景获客-付款码获客功能开发文档

## 1. 模块概述

付款码获客功能通过生成带有特定参数的付款码（如微信支付、支付宝），追踪用户的支付行为，并将支付用户识别为潜在客户或现有客户的成交记录。后端模块负责付款码的生成与管理、支付结果回调处理、用户识别与关联、数据存储和统计。

## 2. API接口设计

### 2.1 生成付款码

- **接口路径**：`/api/v1/lead-generation/payment-codes`
- **请求方法**：`POST`
- **接口说明**：生成一个带有附加参数（如活动ID、渠道来源、员工ID等）的付款码。
- **请求参数 (Request Body):**

| 参数名          | 类型     | 是否必需 | 说明                         | 示例值                  |
|-----------------|----------|----------|------------------------------|-------------------------|
| paymentMethod   | string   | 是       | 支付方式：`WECHAT_PAY`, `ALIPAY` | `WECHAT_PAY`            |
| amount          | number   | 否       | 支付金额 (可选，如果需要固定金额) | 1.00                    |
| description     | string   | 是       | 支付描述，将显示给用户       | 加入社群费用            |
| metadata        | object   | 否       | 附加参数，用于追踪获客来源和关联业务数据，建议包含活动ID、渠道来源、员工ID等信息，需要序列化存储 | `{ "activityId": 101, "channel": "线下推广", "employeeId": 501 }` |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "paymentCodeId": 301,        // 后端系统生成的付款码ID
  "paymentMethod": "WECHAT_PAY", // 支付方式
  "amount": 1.00, // 支付金额 (如果设置)
  "description": "加入社群费用", // 支付描述
  "qrCodeUrl": "微信支付生成的二维码图片URL", // 前端展示的二维码URL
  "status": "ACTIVE",          // 付款码状态 (ACTIVE, INACTIVE, EXPIRED)
  "createTime": "2023-10-26T11:00:00Z", // 创建时间 (ISO 8601格式)
  "metadata": { ... }          // 附加参数
}
```
- **可能返回状态码:** 201 (创建成功), 400 (参数错误/支付网关拒绝), 401, 403, 422 (数据验证失败), 500

### 2.2 获取付款码列表

- **接口路径**：`/api/v1/lead-generation/payment-codes`
- **请求方法**：`GET`
- **接口说明**：获取已生成的付款码列表，支持按状态、支付方式、创建时间等查询和分页。
- **权限:** `lead:paymentcode:view` 或 `lead:paymentcode:list`
- **请求参数 (Query Parameters):**

| 参数名        | 类型    | 是否必需 | 描述                       | 示例值                |
|---------------|--------|----------|----------------------------|-----------------------|
| status        | string | 否       | 付款码状态过滤 (ACTIVE, INACTIVE, EXPIRED) | ACTIVE          |
| createTimeStart | string | 否       | 创建开始时间 (ISO 8601格式)    | 2023-10-01T00:00:00Z |
| createTimeEnd | string | 否       | 创建结束时间 (ISO 8601格式)    | 2023-10-31T23:59:59Z |
| page          | integer| 否       | 页码，从1开始 (默认: 1)        | 1               |
| size          | integer| 否       | 每页条数 (默认: 10)          | 10              |
| sort          | string | 否       | 排序字段 (如: createTime)      | createTime      |
| order         | string | 否       | 排序方向 (asc/desc)            | desc            |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "paymentCodeId": 301,
      "paymentMethod": "WECHAT_PAY",
      "amount": 1.00,
      "description": "加入社群费用",
      "qrCodeUrl": "微信支付生成的二维码图片URL",
      "status": "ACTIVE",
      "createTime": "2023-10-26T11:00:00Z",
      "metadata": { ... },
      "totalPayments": 5, // 关联的支付记录数
      "totalAmountPaid": 5.00 // 关联支付记录的总金额
    }
    // ... 更多付款码记录
  ],
  "total": 50,            // 总记录数
  "size": 10,             // 每页大小
  "current": 1,           // 当前页码
  "pages": 5              // 总页数
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

### 2.3 获取付款码详情

- **接口路径**：`/api/v1/lead-generation/payment-codes/{paymentCodeId}`
- **请求方法**：`GET`
- **接口说明**：根据付款码ID获取付款码详情，包括关联的支付记录简要列表。
- **权限:** `lead:paymentcode:view`
- **请求参数 (Path Parameters):**

| 参数名        | 类型    | 是否必需 | 说明           | 示例值 |
|---------------|---------|----------|----------------|--------|
| paymentCodeId | integer | 是       | 付款码ID       | 301    |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "paymentCodeId": 301,
  "paymentMethod": "WECHAT_PAY",
  "amount": 1.00,
  "description": "加入社群费用",
  "qrCodeUrl": "微信支付生成的二维码图片URL",
  "status": "ACTIVE",
  "createTime": "2023-10-26T11:00:00Z",
  "metadata": { ... },
  "paymentRecords": [ // 关联的支付记录简要列表
    {
      "recordId": 401,
      "transactionId": "WX1234567890",
      "platformUserId": "oq_xxxxxxxxxxxx", // 支付平台用户标识
      "totalAmount": 1.00,
      "paymentTime": "2023-10-26T11:05:00Z",
      "status": "SUCCESS"
    }
    // ... 更多支付记录
  ]
}
```
- **可能返回状态码:** 200, 401, 403, 404, 500

### 2.4 处理支付结果回调

- **接口路径**：`/api/v1/webhook/payment/{paymentMethod}`
- **请求方法**：`POST`
- **接口说明**：接收支付平台（微信支付、支付宝等）的支付成功/失败回调通知。后端需要进行签名验证并处理支付结果。此接口通常无需认证，但需要验证签名。
- **权限:** 无需认证，需验签
- **请求参数 (Request Body):** 具体结构完全依赖于不同支付平台的回调协议，例如微信支付的回调数据是XML格式，支付宝可能是JSON。

| 参数名         | 类型    | 说明                               | 示例值 |
|----------------|---------|------------------------------------|--------|
| payload        | string  | 支付平台推送的原始回调数据（XML/JSON等） | `<xml>...</xml>` 或 `{...}` |
| headers        | object  | HTTP请求头，包含签名信息           | `{ "Signature": "..." }` |
| paymentMethod  | string  | 支付方式（作为Path参数）           | WECHAT_PAY |

- **响应数据:** 接收成功通常返回符合支付平台要求的特定格式响应（例如微信支付要求返回`<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>`）。处理失败也需要返回相应的错误格式。

- **可能返回状态码:** 200 (处理成功), 400 (参数错误/验签失败), 500 (内部处理异常)

### 2.5 获取支付记录列表

- **接口路径**：`/api/v1/lead-generation/payment-records`
- **请求方法**：`GET`
- **接口说明**：获取支付记录列表，支持按付款码、支付状态、支付时间等查询和分页。
- **权限:** `lead:paymentrecord:view` 或 `lead:paymentrecord:list`
- **请求参数 (Query Parameters):**

| 参数名        | 类型    | 是否必需 | 描述                       | 示例值                |
|---------------|--------|----------|----------------------------|-----------------------|
| paymentCodeId | integer| 否       | 按付款码ID过滤             | 301                   |
| transactionId | string | 否       | 按支付平台交易ID过滤       | WX1234567890          |
| status        | string | 否       | 支付状态过滤 (SUCCESS, FAILED, REFUNDING, REFUNDED) | SUCCESS               |
| paymentTimeStart| string | 否     | 支付开始时间范围起始 (ISO 8601)| 2023-10-01T00:00:00Z |
| paymentTimeEnd| string | 否     | 支付开始时间范围结束 (ISO 8601)| 2023-10-31T23:59:59Z |
| page          | integer| 否       | 页码                     | 1                     |
| size          | integer| 否       | 每页条数                 | 10                    |
| sort          | string | 否       | 排序字段                 | paymentTime           |
| order         | string | 否       | 排序方向                 | desc                  |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "recordId": 401,       // 支付记录ID
      "paymentCodeId": 301,  // 关联的付款码ID
      "transactionId": "WX1234567890", // 支付平台交易ID
      "platformUserId": "oq_xxxxxxxxxxxx", // 支付平台用户标识
      "totalAmount": 1.00,   // 支付金额
      "paymentTime": "2023-10-26T11:05:00Z", // 支付时间
      "status": "SUCCESS",   // 支付状态
      "paymentMethod": "WECHAT_PAY", // 支付方式
      "metadata": { ... } // 关联付款码的metadata
      // notification_data字段不返回给前端
    }
    // ... 更多支付记录
  ],
  "total": 80,
  "size": 10,
  "current": 1,
  "pages": 8
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

## 3. 数据模型设计

### 3.1 主要数据表

| 表名                 | 说明            | 关键字段                                  |
|---------------------|----------------|------------------------------------------|
| t_payment_code      | 付款码表        | id, payment_method, amount, description, metadata (TEXT/JSON), qr_code_url, status, create_time, update_time |
| t_payment_record    | 支付记录表      | id, payment_code_id (FK), transaction_id, platform_user_id, total_amount, payment_time, status, notification_data (TEXT), user_id (FK, 关联存客宝用户/客户), create_time, update_time | payment_code_id -> t_payment_code, user_id -> t_user/t_customer |

## 4. 服务实现

### 4.1 PaymentCodeService

负责付款码的生成、管理和查询。调用外部支付平台的API生成实际的付款码（如通过支付接口获取二维码链接）。

```java
@Service
@Slf4j
public class PaymentCodeServiceImpl implements PaymentCodeService {

    @Autowired
    private PaymentCodeRepository paymentCodeRepository;
    
    @Autowired
    private PaymentGatewayService paymentGatewayService; // 调用支付网关服务生成付款码

    @Override
    @Transactional
    public PaymentCodeVO generatePaymentCode(PaymentCodeDTO dto) {
        log.info("Generating payment code for method: {}", dto.getPaymentMethod());
        
        // 1. 调用支付网关服务生成付款码（获取二维码URL等）
        PaymentCodeResult paymentCodeResult = paymentGatewayService.createPaymentCode(dto);
        
        // 2. 保存付款码记录
        PaymentCode paymentCode = new PaymentCode();
        paymentCode.setPaymentMethod(dto.getPaymentMethod());
        paymentCode.setAmount(dto.getAmount());
        paymentCode.setDescription(dto.getDescription());
        // TODO: 保存metadata，可能需要序列化为JSON
        paymentCode.setMetadata(serializeMetadata(dto.getMetadata()));
        paymentCode.setQrCodeUrl(paymentCodeResult.getQrCodeUrl());
        paymentCode.setStatus(PaymentCodeStatus.ACTIVE);
        paymentCode.setCreateTime(new Date());
        
        PaymentCode savedPaymentCode = paymentCodeRepository.save(paymentCode);
        
        return buildPaymentCodeVO(savedPaymentCode);
    }
    
    private String serializeMetadata(Map<String, Object> metadata) {
        // 实现metadata的序列化
        return null;
    }
    
    private Map<String, Object> deserializeMetadata(String metadataJson) {
         // 实现metadata的反序列化
         return null;
    }
    
    // TODO: 其他方法，如获取付款码列表、详情等
}
```

### 4.2 PaymentCallbackService

负责接收和处理来自支付平台的回调通知，进行签名验证、支付结果处理、更新支付记录、识别用户并进行后续获客流程。

```java
@Service
@Slf4j
public class PaymentCallbackServiceImpl implements PaymentCallbackService {

    @Autowired
    private PaymentCodeRepository paymentCodeRepository;
    
    @Autowired
    private PaymentRecordRepository paymentRecordRepository;
    
    @Autowired
    private PaymentGatewayService paymentGatewayService; // 用于签名验证等
    
    @Autowired
    private CustomerService customerService; // 客户服务，用于识别和关联客户
    
    @Autowired
    private LeadGenerationService leadGenerationService; // 获客服务，用于触发后续获客流程

    @Override
    @Transactional
    public void handlePaymentCallback(String paymentMethod, String payload, Map<String, String> headers) {
        log.info("Handling payment callback for method: {}", paymentMethod);
        
        try {
            // 1. 验证回调签名的合法性
            if (!paymentGatewayService.verifySignature(paymentMethod, payload, headers)) {
                log.error("Invalid payment callback signature for method: {}", paymentMethod);
                // TODO: 返回错误响应给支付平台
                return;
            }
            
            // 2. 解析回调数据，提取关键信息（如订单号、支付状态、支付金额、用户标识等）
            PaymentCallbackData callbackData = paymentGatewayService.parseCallbackData(paymentMethod, payload);
            
            // 3. 根据订单号查找对应的付款码记录
            PaymentCode paymentCode = paymentCodeRepository.findByPaymentCodeId(callbackData.getPaymentCodeId())
                    .orElseThrow(() -> new PaymentCodeNotFoundException("Payment code not found: " + callbackData.getPaymentCodeId()));
            
            // 4. 检查支付状态，如果是支付成功
            if (callbackData.isSuccess()) {
                // 5. 保存支付记录
                PaymentRecord paymentRecord = new PaymentRecord();
                paymentRecord.setPaymentCodeId(paymentCode.getId());
                paymentRecord.setTransactionId(callbackData.getTransactionId());
                paymentRecord.setPlatformUserId(callbackData.getPlatformUserId()); // 支付平台的用户标识
                paymentRecord.setTotalAmount(callbackData.getTotalAmount());
                paymentRecord.setPaymentTime(callbackData.getPaymentTime());
                paymentRecord.setStatus(PaymentStatus.SUCCESS);
                // TODO: 保存原始回调数据到notification_data字段
                paymentRecord.setNotificationData(payload);
                
                PaymentRecord savedPaymentRecord = paymentRecordRepository.save(paymentRecord);
                
                // 6. 识别并关联客户
                // 根据支付平台用户标识、付款码metadata中的信息，识别或创建存客宝客户
                Customer customer = customerService.findOrCreateCustomerFromPayment(callbackData.getPlatformUserId(), paymentCode.getMetadata());
                // TODO: 关联支付记录到客户
                // savedPaymentRecord.setUserId(customer.getId());
                // paymentRecordRepository.save(savedPaymentRecord);

                // 7. 触发后续获客流程 (如打标签、发送欢迎语等)
                leadGenerationService.processPaymentLead(customer.getId(), paymentCode.getMetadata());
                
                log.info("Payment successful and processed for payment code: {}", paymentCode.getId());
            } else {
                // TODO: 处理支付失败或退款等情况
                 log.warn("Payment callback indicates non-success status for payment code: {}", paymentCode.getId());
                 // 保存失败的支付记录或更新状态
            }
            
            // TODO: 返回成功响应给支付平台
            
        } catch (Exception e) {
            log.error("Failed to handle payment callback", e);
            // TODO: 记录异常，返回错误响应
        }
    }
    
    // TODO: 其他辅助方法
}
```

### 4.3 PaymentGatewayService

作为与外部支付平台（微信支付、支付宝等）交互的适配层，封装不同支付平台的API调用细节（如生成付款码、查询订单、退款、签名验证等）。

```java
@Service
public class PaymentGatewayServiceImpl implements PaymentGatewayService {

    @Autowired
    private ApiService apiService; // 调用通用API服务封装支付平台API
    
    @Override
    public PaymentCodeResult createPaymentCode(PaymentCodeDTO dto) {
        // TODO: 根据paymentMethod调用相应的支付平台API生成付款码
        // 使用apiService.callApi("WECHAT_PAY.createCode", request);
        return null; // 返回包含二维码URL等信息的对象
    }
    
    @Override
    public boolean verifySignature(String paymentMethod, String payload, Map<String, String> headers) {
        // TODO: 根据paymentMethod调用相应的支付平台SDK或API进行签名验证
        return false;
    }
    
    @Override
    public PaymentCallbackData parseCallbackData(String paymentMethod, String payload) {
        // TODO: 根据paymentMethod解析回调数据
        return null; // 返回包含订单号、支付状态、用户标识等信息的对象
    }
    
    // TODO: 实现查询订单、退款等方法
}
```

## 5. 流程图

```mermaid
graph TD
    A[用户在前端生成付款码] --> B[调用后端生成付款码接口]
    B --> C[后端调用PaymentGatewayService]
    C --> D{调用外部支付平台API生成付款码}
    D --> E[支付平台返回付款码信息]
    E --> F[PaymentGatewayService返回结果]
    F --> G[后端保存付款码记录]
    G --> H[后端返回付款码URL给前端]
    H --> I[用户通过付款码支付]

    J[支付平台支付成功] --> K[支付平台发送回调通知到存客宝后端Webhook]
    K --> L[后端接收回调/PaymentCallbackService]
    L --> M[验证签名]
    M -- Invalid Signature --> N[拒绝处理/记录错误]
    M -- Valid Signature --> O[解析回调数据]
    O --> P[查找对应付款码记录]
    P --> Q{判断支付状态是否成功}
    Q -- Success --> R[保存支付记录]
    R --> S[识别并关联客户]
    S --> T[触发后续获客流程]
    T --> U[返回成功响应给支付平台]
    Q -- Failure --> V[处理支付失败/记录]
    V --> U
```

## 6. 异常处理

- `PaymentCodeGenerationException`: 付款码生成失败
- `PaymentCodeNotFoundException`: 付款码记录不存在
- `InvalidSignatureException`: 支付回调签名验证失败
- `PaymentCallbackProcessingException`: 支付回调处理异常
- `PaymentGatewayApiException`: 调用支付平台API异常

## 7. 与前端的交互流程

1. 前端收集生成付款码所需信息（如金额、描述、附加参数等）。
2. 前端调用"生成付款码"接口，后端调用支付平台API生成付款码，并返回二维码URL。
3. 前端展示二维码供用户扫码支付。
4. 用户支付成功后，支付平台异步发送回调通知到存客宝后端Webhook接口。
5. 后端Webhook服务验证签名，处理支付结果，保存支付记录，识别并关联客户，触发后续获客流程。
6. 前端可以通过查询"支付记录列表"或"付款码详情"来查看支付状态和结果。 

#### 开发注意事项和实现要点

1.  **与支付平台的对接:**
    - 需要集成微信支付、支付宝等支付平台的SDK或API。
    - 实现生成付款码、处理支付回调、查询订单、退款等核心功能。
    - 特别注意支付平台的回调机制，需要实现可靠的Webhook接收和处理服务。
2.  **数据安全:**
    - 支付相关的敏感信息（如App Secret、API Key、证书、回调数据等）必须安全存储和处理。
    - 传输过程中使用HTTPS。
    - 存储的metadata字段如果包含敏感信息，需要进行加密或脱敏。
    - 支付回调接口需要进行严格的签名验证，防止伪造请求。
3.  **数据验证:**
    - 对所有接收到的请求参数进行严格验证，例如金额格式、支付方式合法性等。
    - 对支付回调数据进行格式和内容验证。
    - 使用 Spring Validation 框架结合注解进行声明式验证。验证失败时，按照 `./前后端接口约定.md` 中的约定返回 422 状态码和详细的错误信息列表。
4.  **错误处理:**
    - 遵循 `./前后端接口约定.md` 中的错误处理规范。
    - 捕获并处理与支付平台交互中可能发生的各种异常（如网络错误、API调用失败、签名错误等），返回统一的错误响应格式。
    - 支付回调处理中的异常需要记录详细日志并进行告警，但通常需要向支付平台返回成功响应，以避免重复回调（具体取决于支付平台的回调机制）。
5.  **日志记录:**
    - 记录所有关键操作日志，包括：
        - 付款码的生成。
        - 支付回调的接收、验签结果、处理状态、关键数据（脱敏后）。
        - 支付记录的保存、状态更新。
        - 用户识别与关联过程。
        - 与支付平台API的交互日志。
        - 所有异常日志。
    - 日志应包含时间、相关ID（付款码ID、交易ID）、操作类型、操作结果、错误信息等。
6.  **事务管理:**
    - 在处理支付回调时，保存支付记录、识别关联客户、触发后续流程等操作可能涉及多个数据库表和外部服务调用，需要使用 `@Transactional` 注解或其他方式确保操作的原子性，防止数据不一致。
7.  **幂等性:**
    - 支付平台可能会重复发送回调通知，后端必须实现幂等性处理，确保同一个交易ID的支付结果只处理一次，避免重复创建支付记录或触发获客流程。通常可以通过检查支付记录是否已存在（基于transaction_id）来实现。
8.  **用户识别与关联:**
    - 根据支付回调数据中提供的支付平台用户标识（如微信OpenID/UnionID, 支付宝UID）和付款码中携带的metadata信息，尝试在存客宝现有客户中进行识别。
    - 如果无法识别到现有客户，则根据metadata等信息创建新的潜在客户或用户记录。
    - 将支付记录与识别或关联到的存客宝用户/客户进行关联。
9.  **后续获客流程触发:**
    - 支付成功并识别关联客户后，根据付款码的metadata（如活动ID、渠道）触发后续的获客流程，例如：
        - 为客户打上特定标签。
        - 将客户分配给特定的员工。
        - 自动发送欢迎消息或入群邀请。
        - 更新客户的消费记录或价值评分。
10. **接口版本控制:**
    - 当前接口版本为 `/api/v1`。未来若接口发生不兼容变更，需升级版本号并维护旧版本一段过渡期。
11. **性能与并发:**
    - 支付回调接口可能面临高并发请求，需要设计为快速响应（尤其是在验签通过后），并将后续的业务处理（保存记录、识别客户、触发流程）放入消息队列进行异步处理，避免阻塞回调响应。
    - 优化数据库操作以提高性能。 

---

## 文件 7: 后端-场景获客-个人微信获客功能开发文档.md

*文件大小：61.78 KB*

---

# 存客宝场景获客-个人微信获客功能开发文档

## 1. 模块概述

个人微信获客功能通过对接个人微信号，实现好友管理、朋友圈管理、自动通过好友请求、批量打招呼、自动化聊天互动等能力，帮助用户通过个人微信建立和维护私域流量。后端模块负责个人微信号的连接与管理、好友数据同步、消息接收与处理、朋友圈管理、自动化任务执行以及数据统计。

## 2. API接口设计

### 2.1 连接个人微信号

- **接口路径**：`/api/v1/lead-generation/wechat-personal/connect`
- **请求方法**：`POST`
- **接口说明**：发起连接个人微信号的请求，通常需要返回一个登录二维码给前端展示。
- **权限:** `wechat:personal:connect`
- **请求参数 (Request Body):**

| 参数名   | 类型    | 是否必需 | 说明             | 示例值 |
|----------|---------|----------|------------------|--------|
| deviceId | integer | 是       | 指定连接的设备ID | 1      |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "taskId": "CONNECT_TASK_ID",   // 连接任务ID，用于后续查询状态
  "qrCodeUrl": "个人微信登录二维码URL", // 前端需要展示给用户扫码的二维码图片URL
  "status": "PENDING_SCAN",      // 连接任务状态 (PENDING_SCAN, SCANNED, LOGGED_IN, FAILED, CANCELLED)
  "createTime": "2023-10-26T10:00:00Z" // 任务创建时间
}
```
- **可能返回状态码:** 200 (任务发起成功), 400 (参数错误/设备状态异常), 401, 403, 409 (设备忙碌), 500

### 2.2 获取个人微信号连接任务状态

- **接口路径**：`/api/v1/lead-generation/wechat-personal/connect-tasks/{taskId}/status`
- **请求方法**：`GET`
- **接口说明**：查询指定个人微信号连接任务的当前状态（如等待扫码、已扫码未确认、已登录、失败等）。前端通过此接口轮询连接进度。
- **权限:** `wechat:personal:view` 或 `wechat:personal:connect`
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明         | 示例值 |
|--------|--------|----------|--------------|--------|
| taskId | string | 是       | 连接任务ID   | CONNECT_TASK_ID |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "taskId": "CONNECT_TASK_ID",   // 连接任务ID
  "status": "LOGGED_IN",         // 连接任务状态 (PENDING_SCAN, SCANNED, LOGGED_IN, FAILED, CANCELLED)
  "message": "登录成功",         // 状态描述信息
  "accountInfo": {               // 如果已登录，返回微信号基本信息
    "accountId": 1,            // 后端系统内的微信号ID
    "wechatId": "wxid_xxxxxxxxxxxx", // 微信内部ID
    "nickname": "用户昵称",
    "avatarUrl": "头像URL"
  },
  "qrCodeUrl": null // 如果不是等待扫码状态，二维码URL可能为空
}
```
- **可能返回状态码:** 200, 401, 403, 404 (任务不存在), 500

### 2.3 获取已连接个人微信号账号列表

- **接口路径**：`/api/v1/lead-generation/wechat-personal/accounts`
- **请求方法**：`GET`
- **接口说明**：获取当前用户已成功连接的个人微信号账号列表，支持按设备、状态等筛选和分页。
- **权限:** `wechat:personal:view`
- **请求参数 (Query Parameters):**

| 参数名   | 类型    | 是否必需 | 描述           | 示例值 |
|----------|--------|----------|----------------|--------|
| deviceId | integer| 否       | 按设备ID过滤   | 1      |
| status   | string | 否       | 账号状态过滤 (ACTIVE, OFFLINE, BANNED) | ACTIVE |
| page     | integer| 否       | 页码           | 1      |
| size     | integer| 否       | 每页条数       | 10     |
| sort     | string | 否       | 排序字段       | lastLoginTime, createTime |
| order    | string | 否       | 排序方向       | desc   |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "accountId": 1,            // 后端系统内的微信号ID
      "deviceId": 1,             // 关联的设备ID
      "wechatId": "wxid_xxxxxxxxxxxx", // 微信内部ID
      "nickname": "用户昵称",
      "avatarUrl": "头像URL",
      "status": "ACTIVE",        // 账号状态 (ACTIVE, OFFLINE, BANNED)
      "loginStatus": "LOGGED_IN", // 登录状态 (LOGGED_IN, LOGGED_OUT, SCAN_REQUIRED)
      "lastLoginTime": "2023-10-26T09:00:00Z", // 最后登录时间
      "friendCount": 500,        // 好友数量
      "groupCount": 20           // 群数量
      // ... 其他账号信息
    }
    // ... 更多账号记录
  ],
  "total": 10,
  "size": 10,
  "current": 1,
  "pages": 1
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

### 2.4 同步个人微信号好友列表

- **接口路径**：`/api/v1/lead-generation/wechat-personal/accounts/{accountId}/friends/sync`
- **请求方法**：`POST`
- **接口说明**：触发同步指定个人微信号的好友列表。这是一个异步任务，前端可以通过其他接口查询同步进度。
- **权限:** `wechat:personal:friend:sync`
- **请求参数 (Path Parameters):**

| 参数名    | 类型    | 是否必需 | 说明               | 示例值 |
|-----------|---------|----------|--------------------|--------|
| accountId | integer | 是       | 个人微信号账号ID   | 1      |

- **请求体 (Request Body):** 通常为空 `{}` 或包含同步类型等可选参数。

- **响应数据 (统一格式 `data` 字段):** 返回触发同步任务的结果或任务ID。

```json
{
  "syncTaskId": "FRIEND_SYNC_TASK_ID", // 同步任务ID
  "status": "ACCEPTED",              // 任务状态：ACCEPTED, REJECTED
  "message": "好友同步任务已触发"
}
```
- **可能返回状态码:** 200, 400 (参数错误/账号状态异常), 401, 403, 404 (账号不存在), 409 (账号正在同步), 500

### 2.5 获取个人微信号好友列表

- **接口路径**：`/api/v1/lead-generation/wechat-personal/accounts/{accountId}/friends`
- **请求方法**：`GET`
- **接口说明**：获取指定个人微信号的好友列表，支持按昵称、备注、标签、来源、添加时间等筛选、搜索和分页。
- **权限:** `wechat:personal:friend:view` 或 `wechat:personal:friend:list`
- **请求参数 (Path Parameters):**

| 参数名    | 类型    | 是否必需 | 说明               | 示例值 |
|-----------|---------|----------|--------------------|--------|
| accountId | integer | 是       | 个人微信号账号ID   | 1      |

- **请求参数 (Query Parameters):**

| 参数名      | 类型    | 是否必需 | 描述             | 示例值       |
|-------------|--------|----------|------------------|--------------|
| keyword     | string | 否       | 昵称/备注关键字  | 张三         |
| tagIds      | array<integer> | 否 | 按标签ID过滤     | `[1, 2]`     |
| source      | string | 否       | 按添加来源过滤   | 海报获客      |
| addTimeStart| string | 否       | 添加时间范围始   | 2023-10-01Z  |
| addTimeEnd  | string | 否       | 添加时间范围末   | 2023-10-31Z  |
| page        | integer| 否       | 页码             | 1            |
| size        | integer| 否       | 每页条数         | 10           |
| sort        | string | 否       | 排序字段         | addTime, lastChatTime |
| order       | string | 否       | 排序方向         | desc         |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "friendId": 1001, // 后端系统内的好友记录ID (对应客户/用户ID)
      "accountId": 1,     // 关联的个人微信号账号ID
      "customerId": 101,  // 关联的存客宝客户ID
      "wechatId": "wxid_yyyyyyyyyyyy", // 好友的微信内部ID
      "nickname": "好友昵称",
      "remark": "给好友的备注",
      "avatarUrl": "好友头像URL",
      "addTime": "2023-10-20T10:00:00Z", // 添加时间
      "lastChatTime": "2023-10-26T11:00:00Z", // 最后聊天时间
      "source": "海报获客", // 添加来源
      "tags": [{"tagId": 1, "tagName": "高意向"}] // 关联标签
      // ... 其他好友信息
    }
    // ... 更多好友记录
  ],
  "total": 500,
  "size": 10,
  "current": 1,
  "pages": 50
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404 (账号不存在), 500

### 2.6 处理新好友请求推送 (Webhook)

- **接口路径**：`/api/v1/webhook/wechat-personal/friend-request`
- **请求方法**：`POST`
- **接口说明**：接收来自设备端的新好友请求推送。后端根据配置的规则检查是否自动通过好友请求，并触发后续处理（如记录、通知、打标签等）。此接口通常无需认证，但需要验证签名。
- **权限:** 无需认证，需验签
- **请求参数 (Request Body):** 具体结构依赖于设备端推送的数据格式，通常包含：

| 参数名            | 类型    | 说明                                   | 示例值 |
|-------------------|---------|----------------------------------------|--------|
| deviceId          | integer | 推送事件的设备ID                       | 1      |
| myWechatId        | string  | 接收到好友请求的个人微信号             | wxid_xxxxxxxxxxxx |
| requesterWechatId | string  | 发起好友请求的对方微信号             | wxid_yyyyyyyyyyyy |
| verificationText  | string  | 对方填写的验证信息                     | 您好，我是通过海报添加的 |
| source            | string  | 添加来源 (如：search, qrcode, group etc.) | qrcode |
| ticket            | string  | 用于通过好友请求的ticket/v3数据        | v3_... |
| createTime        | string  | 请求时间 (ISO 8601或其他约定格式)      | 2023-10-26T11:00:00Z |
| ...               | ...     | 其他请求相关数据                       | ...    |

- **响应数据:** 接收成功通常返回简单的成功标识或符合设备端要求的特定响应。

```json
{
  "code": 200,
  "message": "received"
}
```
- **可能返回状态码:** 200, 400 (数据格式错误/验签失败), 500

### 2.7 自动通过好友请求规则管理

- **接口路径**：`/api/v1/lead-generation/wechat-personal/auto-accept-rules`
- **请求方法**：`POST` (创建), `GET` (列表), `PUT` (更新), `DELETE` (删除)
- **接口说明**：管理自动通过好友请求的规则，支持按个人微信号账号、来源渠道、验证信息关键词等设置规则。
- **权限:** `wechat:personal:friend:rule:manage`
- **请求参数 (POST/PUT Request Body):**

| 参数名       | 类型    | 是否必需 | 描述                       | 示例值 |
|--------------|--------|----------|----------------------------|--------|
| accountId    | integer| 是       | 关联的个人微信号账号ID     | 1      |
| ruleName     | string | 是       | 规则名称                   | 海报自动通过 |
| ruleType     | string | 是       | 规则类型 (SOURCE, KEYWORD) | SOURCE |
| sourceKeyword| string | 否       | 来源渠道或验证信息关键词   | 海报    |
| status       | string | 是       | 规则状态 (ACTIVE, INACTIVE) | ACTIVE |
// 其他规则条件...

- **响应数据 (统一格式 `data` 字段):** 返回规则详情或列表。

```json
{
  "ruleId": 1,             // 规则ID
  "accountId": 1,
  "ruleName": "海报自动通过",
  "ruleType": "SOURCE",
  "sourceKeyword": "海报",
  "status": "ACTIVE",
  "createTime": "2023-10-26T11:30:00Z"
}
```
- **可能返回状态码:** 200, 201, 400, 401, 403, 404, 422, 500

### 2.8 发送个人聊天消息

- **接口路径**：`/api/v1/lead-generation/wechat-personal/accounts/{accountId}/messages`
- **请求方法**：`POST`
- **接口说明**：向指定个人微信号的指定好友或群发送消息（文本、图片、文件、链接等）。这是一个异步任务。
- **权限:** `wechat:personal:message:send`
- **请求参数 (Path Parameters):**

| 参数名    | 类型    | 是否必需 | 说明               | 示例值 |
|-----------|---------|----------|--------------------|--------|
| accountId | integer | 是       | 发送消息的个人微信号账号ID | 1      |

- **请求体 (Request Body):**

| 参数名       | 类型    | 是否必需 | 描述                     | 示例值 |
|--------------|--------|----------|--------------------------|--------|
| receiverId   | integer| 是       | 接收者ID (存客宝用户/客户ID或群ID) | 1001 (好友) 或 201 (群) |
| receiverType | string | 是       | 接收者类型 (FRIEND, GROUP) | FRIEND |
| messageType  | string | 是       | 消息类型 (TEXT, IMAGE, FILE, LINK etc.) | TEXT   |
| content      | string | 否       | 文本内容                 | 你好，最近怎么样？ |
| materialId   | integer| 否       | 如果是素材库中的素材，提供素材ID | 301    |
| fileUrl      | string | 否       | 如果直接提供文件URL (考虑安全性，优先使用materialId) | http://example.com/image.jpg |
// 更多消息类型和对应字段...

- **响应数据 (统一格式 `data` 字段):** 返回发送任务的结果或任务ID。

```json
{
  "sendTaskId": "MESSAGE_SEND_TASK_ID", // 发送任务ID
  "status": "ACCEPTED",             // 任务状态：ACCEPTED, REJECTED
  "message": "消息发送任务已触发"
}
```
- **可能返回状态码:** 200, 400 (参数错误/账号状态异常), 401, 403, 404 (账号/接收者不存在), 500

### 2.9 处理个人聊天消息推送 (Webhook)

- **接口路径**：`/api/v1/webhook/wechat-personal/message`
- **请求方法**：`POST`
- **接口说明**：接收来自设备端的个人聊天消息推送。后端根据消息内容触发自动回复、关键词处理、会话管理等逻辑。此接口通常无需认证，但需要验证签名。
- **权限:** 无需认证，需验签
- **请求参数 (Request Body):** 具体结构依赖于设备端推送的数据格式，通常包含：

| 参数名           | 类型    | 说明                                   | 示例值 |
|------------------|---------|----------------------------------------|--------|
| deviceId         | integer | 推送消息的设备ID                       | 1      |
| myWechatId       | string  | 接收消息的个人微信号                   | wxid_xxxxxxxxxxxx |
| senderWechatId   | string  | 发送者微信唯一标识                     | wxid_yyyyyyyyyyyy |
| receiverWechatId | string  | 接收者微信唯一标识 (通常是myWechatId)  | wxid_xxxxxxxxxxxx |
| messageType      | string  | 消息类型 (TEXT, IMAGE, FILE etc.)      | TEXT   |
| content          | string  | 消息内容                               | 你好   |
| messageId        | string  | 消息在设备端的唯一ID (用于去重)        | msg_id_abc |
| sendTime         | string  | 消息发送时间 (ISO 8601或其他约定格式)    | 2023-10-26T14:06:00Z |
| ...              | ...     | 其他消息相关数据 (图片URL, 文件URL等) | ...    |

- **响应数据:** 接收成功通常返回简单的成功标识或符合设备端要求的特定响应。

```json
{
  "code": 200,
  "message": "received"
}
```
- **可能返回状态码:** 200, 400 (数据格式错误/验签失败), 500

### 2.10 发布朋友圈

- **接口路径**：`/api/v1/lead-generation/wechat-personal/accounts/{accountId}/moments`
- **请求方法**：`POST`
- **接口说明**：通过指定个人微信号账号发布朋友圈（文本、图片、视频、链接等）。这是一个异步任务。
- **权限:** `wechat:personal:moment:publish`
- **请求参数 (Path Parameters):**

| 参数名    | 类型    | 是否必需 | 说明               | 示例值 |
|-----------|---------|----------|--------------------|--------|
| accountId | integer | 是       | 发布朋友圈的个人微信号账号ID | 1      |

- **请求体 (Request Body):**

| 参数名       | 类型    | 是否必需 | 描述                 | 示例值 |
|--------------|--------|----------|----------------------|--------|
| content      | string | 否       | 朋友圈文本内容       | 今天天气真好 |
| materialIds  | array<integer> | 否 | 关联的素材库素材ID列表 (图片/视频) | `[301, 302]` |
| mediaUrls    | array<string> | 否 | 媒体文件URL列表 (图片/视频)，优先使用materialIds | `["http://ex.com/a.jpg", "http://ex.com/b.mp4"]` |
| linkUrl      | string | 否       | 链接URL              | http://example.com |
| linkTitle    | string | 否       | 链接标题             | 示例链接 |
| linkImageUrl | string | 否       | 链接缩略图URL        | http://ex.com/thumb.jpg |
// 其他朋友圈类型和字段...

- **响应数据 (统一格式 `data` 字段):** 返回发布任务的结果或任务ID。

```json
{
  "publishTaskId": "MOMENT_PUBLISH_TASK_ID", // 发布任务ID
  "status": "ACCEPTED",                  // 任务状态：ACCEPTED, REJECTED
  "message": "朋友圈发布任务已触发"
}
```
- **可能返回状态码:** 200, 400 (参数错误/账号状态异常), 401, 403, 404 (账号不存在), 500

### 2.11 获取朋友圈列表

- **接口路径**：`/api/v1/lead-generation/wechat-personal/accounts/{accountId}/moments`
- **请求方法**：`GET`
- **接口说明**：获取指定个人微信号账号的朋友圈列表，支持分页和筛选。
- **权限:** `wechat:personal:moment:view`
- **请求参数 (Path Parameters):**

| 参数名    | 类型    | 是否必需 | 说明               | 示例值 |
|-----------|---------|----------|--------------------|--------|
| accountId | integer | 是       | 个人微信号账号ID   | 1      |

- **请求参数 (Query Parameters):**

| 参数名       | 类型    | 是否必需 | 描述           | 示例值       |
|--------------|--------|----------|----------------|--------------|
| content      | string | 否       | 内容关键字     | 活动         |
| publishTimeStart| string | 否     | 发布时间范围始 | 2023-10-01Z  |
| publishTimeEnd  | string | 否     | 发布时间范围末 | 2023-10-31Z  |
| page         | integer| 否       | 页码           | 1            |
| size         | integer| 否       | 每页条数       | 10           |
| sort         | string | 否       | 排序字段       | publishTime, createTime |
| order        | string | 否       | 排序方向       | desc         |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "momentId": "设备端的朋友圈ID", // 设备端的朋友圈唯一标识
      "accountId": 1,             // 关联的个人微信号账号ID
      "content": "朋友圈内容",
      "mediaUrls": ["图片URL", "视频URL"], // 媒体文件URL列表
      "linkUrl": "链接URL",
      "publishTime": "2023-10-26T15:00:00Z", // 发布时间
      "likeCount": 10,            // 点赞数
      "commentCount": 5           // 评论数
      // ... 其他朋友圈信息
    }
    // ... 更多朋友圈记录
  ],
  "total": 100,
  "size": 10,
  "current": 1,
  "pages": 10
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404 (账号不存在), 500

### 2.12 朋友圈互动推送 (Webhook)

- **接口路径**：`/api/v1/webhook/wechat-personal/moment-interaction`
- **请求方法**：`POST`
- **接口说明**：接收来自设备端的朋友圈评论或点赞推送。后端记录互动数据，并可能触发通知或自动化回复。此接口通常无需认证，但需要验证签名。
- **权限:** 无需认证，需验签
- **请求参数 (Request Body):** 具体结构依赖于设备端推送的数据格式，通常包含：

| 参数名          | 类型    | 说明                               | 示例值 |
|-----------------|---------|------------------------------------|--------|
| deviceId        | integer | 推送事件的设备ID                     | 1      |
| accountWechatId | string  | 发生互动的朋友圈所属微信号           | wxid_xxxxxxxxxxxx |
| momentId        | string  | 发生互动的朋友圈ID                   | moment_id_abc |
| interactionType | string  | 互动类型 (LIKE, COMMENT)           | COMMENT |
| interactorWechatId | string  | 发起互动者微信唯一标识             | wxid_zzzzzzzzzzz |
| commentContent  | string  | 如果是评论，评论内容               | 说得好！ |
| createTime      | string  | 互动时间 (ISO 8601或其他约定格式)    | 2023-10-26T15:05:00Z |
| ...             | ...     | 其他互动相关数据                   | ...    |

- **响应数据:** 接收成功通常返回简单的成功标识或符合设备端要求的特定响应。

```json
{
  "code": 200,
  "message": "received"
}
```
- **可能返回状态码:** 200, 400 (数据格式错误/验签失败), 500

### 2.13 批量任务管理 (批量发送消息、批量加好友等)

- **接口路径**：`/api/v1/lead-generation/wechat-personal/batch-tasks`
- **请求方法**：`POST` (创建任务), `GET` (查询任务列表/详情)
- **接口说明**：创建和管理批量任务，如批量发送消息给好友、批量通过好友请求等。批量任务通常是异步执行的。
- **权限:** `wechat:personal:task:manage`
- **请求参数 (POST Request Body):**

| 参数名       | 类型    | 是否必需 | 描述                     | 示例值 |
|--------------|--------|----------|--------------------------|--------|
| taskType     | string | 是       | 任务类型 (BATCH_MESSAGE, BATCH_ADD_FRIEND etc.) | BATCH_MESSAGE |
| accountId    | integer| 是       | 执行任务的个人微信号账号ID | 1      |
| targetIds    | array<integer> | 是 | 目标对象ID列表 (如好友ID列表、待通过好友请求ID列表) | `[1001, 1002]` |
| taskConfig   | object | 是       | 任务的具体配置           | `{ "messageType": "TEXT", "content": "你好" }` |
| scheduledTime| string | 否       | 计划执行时间 (ISO 8601格式) | 2023-10-26T18:00:00Z |

- **请求参数 (GET Query Parameters for list):** 支持按类型、账号、状态、时间范围过滤和分页。

| 参数名    | 类型    | 是否必需 | 描述           | 示例值 |
|-----------|--------|----------|----------------|--------|
| taskType  | string | 否       | 任务类型过滤   | BATCH_MESSAGE |
| accountId | integer| 否       | 按账号ID过滤   | 1      |
| status    | string | 否       | 任务状态过滤   | RUNNING |
| page      | integer| 否       | 页码           | 1      |
| size      | integer| 否       | 每页条数       | 10     |
// ... 其他查询参数

- **响应数据 (统一格式 `data` 字段):** 返回任务详情或列表。

```json
{
  "records": [
    {
      "taskId": 1,               // 批量任务ID
      "taskType": "BATCH_MESSAGE",
      "accountId": 1,
      "status": "COMPLETED",     // 任务状态 (PENDING, RUNNING, COMPLETED, FAILED)
      "totalCount": 100,         // 目标总数
      "completedCount": 98,      // 已完成数
      "failedCount": 2,          // 失败数
      "createTime": "2023-10-26T17:00:00Z",
      "startTime": "2023-10-26T17:05:00Z",
      "endTime": "2023-10-26T17:10:00Z",
      "taskConfig": { ... }      // 任务配置详情
      // ... 其他任务信息
    }
    // ... 更多批量任务记录
  ],
  "total": 10,
  "size": 10,
  "current": 1,
  "pages": 1
}
```
- **可能返回状态码:** 200, 201, 400, 401, 403, 404, 422, 500

## 3. 数据模型设计

### 3.1 主要数据表

| 表名                     | 说明            | 关键字段                                           | 与其他表关系 |
|-------------------------|----------------|---------------------------------------------------|------------|
| t_wechat_personal_account | 个人微信号授权表| id (PK), device_id (FK), wechat_id, nickname, avatar_url, status, sync_time, login_status, create_time, update_time | device_id -> t_device (假设设备表) |
| t_wechat_personal_friend| 个人微信号好友表| id (PK), account_id (FK), customer_id (FK), wechat_id, alias, remark, add_time, last_chat_time, source, tags (JSON/TEXT), create_time, update_time | account_id -> t_wechat_personal_account, customer_id -> t_user/t_customer |
| t_wechat_personal_message| 个人微信消息记录表| id (PK), account_id (FK), sender_id (FK), receiver_id (FK), message_type, content, material_id (FK), send_time, create_time | account_id -> t_wechat_personal_account, sender_id -> t_user, receiver_id -> t_user/t_wechat_group, material_id -> t_material (素材库表) |
| t_friend_request_rule   | 好友请求规则表  | id (PK), account_id (FK, 可空，表示全局规则), rule_type, keyword (TEXT), source, status, create_time, update_time | account_id -> t_wechat_personal_account |
| t_wechat_personal_moment| 朋友圈记录表    | id (PK), account_id (FK), moment_id (设备端ID), content, media_urls (JSON/TEXT), link_url, link_title, link_image_url, publish_time, like_count, comment_count, create_time, update_time | account_id -> t_wechat_personal_account |
| t_moment_interaction    | 朋友圈互动记录表| id (PK), moment_id (FK), interactor_id (FK), interaction_type, comment_content, create_time | moment_id -> t_wechat_personal_moment, interactor_id -> t_user |
| t_batch_task            | 批量任务表      | id (PK), task_type, account_id (FK), total_count, completed_count, failed_count, status, task_config (JSON/TEXT), create_time, start_time, end_time, update_time | account_id -> t_wechat_personal_account |

补充了数据表之间的关系、主键(PK)和外键(FK)标识，以及时间戳字段，并增加了朋友圈互动记录表 `t_moment_interaction`。

## 4. 服务实现

### 4.1 WechatPersonalAuthService

负责个人微信号的连接、登录状态管理、以及与设备控制服务交互获取登录二维码。

```java
@Service
@Slf4j
public class WechatPersonalAuthServiceImpl implements WechatPersonalAuthService {

    @Autowired
    private WechatPersonalAccountRepository accountRepository;
    
    @Autowired
    private DeviceControlService deviceControlService; // 调用设备控制服务

    @Override
    @Transactional
    public ConnectTaskVO connectAccount(Long deviceId) {
        log.info("Initiating Wechat personal account connection for device: {}", deviceId);
        
        try {
            // 1. 调用设备控制服务，发起登录请求，获取二维码数据
            DeviceCommand command = new DeviceCommand();
            command.setType(DeviceCommandType.LOGIN_WECHAT_PERSONAL);
            command.setDeviceId(deviceId);
            // 可选参数，如超时时间等
            
            DeviceCommandResult result = deviceControlService.executeCommand(deviceId, command);
            
            // 2. 解析设备返回的二维码URL和任务ID
            String qrCodeUrl = result.getData().get("qrCodeUrl").toString();
            String taskId = result.getData().get("taskId").toString();
            
            // 3. 创建连接任务记录 (可选，用于追踪状态)
            // SaveConnectTask(taskId, deviceId, ConnectStatus.WAITING_SCAN);
            
            log.info("Wechat personal account connection initiated, task ID: {}", taskId);
            return new ConnectTaskVO(taskId, qrCodeUrl);
            
        } catch (Exception e) {
            log.error("Failed to initiate Wechat personal account connection for device: " + deviceId, e);
            throw new WechatPersonalAuthException("发起微信登录失败", e);
        }
    }
    
    @Override
    public AccountStatusVO getConnectStatus(String taskId) {
         log.info("Getting connect status for task: {}", taskId);
         // TODO: 调用设备控制服务或查询本地任务记录，获取登录状态
         // 如果设备端有状态推送，优先通过 Webhook 更新本地状态，这里直接查本地记录。
         return null; // 返回包含登录状态、微信号信息等的VO
    }

    // TODO: 实现其他方法，如处理设备端推送的登录成功/失败回调，更新 t_wechat_personal_account 表
    // 处理登录二维码扫描事件 Webhook
    // 处理登录成功/失败事件 Webhook
    // 处理账号掉线/封号事件 Webhook
}
```

### 4.2 WechatPersonalFriendService

负责个人微信号好友的同步、管理和查询。处理新好友请求。

```java
@Service
@Slf4j
public class WechatPersonalFriendServiceImpl implements WechatPersonalFriendService {

    @Autowired
    private WechatPersonalFriendRepository friendRepository;
    
    @Autowired
    private WechatPersonalAccountRepository accountRepository;
    
    @Autowired
    private DeviceControlService deviceControlService; // 调用设备控制服务同步好友
    
    @Autowired
    private CustomerService customerService; // 客户服务
    
    @Autowired
    private FriendRequestRuleService ruleService; // 好友请求规则服务

    @Override
    @Transactional
    public void syncFriends(Long accountId) {
        log.info("Syncing friends for account: {}", accountId);
        
        WechatPersonalAccount account = accountRepository.findById(accountId)
                .orElseThrow(() -> new WechatAccountNotFoundException("Wechat personal account not found: " + accountId));
        
        try {
            // 1. 调用设备控制服务，获取指定微信号的好友列表
            DeviceCommand command = new DeviceCommand();
            command.setType(DeviceCommandType.GET_FRIENDS);
            command.setDeviceId(account.getDeviceId());
            command.setParams(Collections.singletonMap("wechatId", account.getWechatId()));
            
            DeviceCommandResult result = deviceControlService.executeCommand(account.getDeviceId(), command);
            
            // 2. 解析设备返回的好友数据
            List<WechatFriendDTO> friendData = parseFriendData(result.getData());
            
            // 3. 更新或保存好友信息到数据库
            for (WechatFriendDTO friendDto : friendData) {
                 // TODO: 查找或创建存客宝客户，并获取其ID
                 Customer friendCustomer = customerService.findOrCreateCustomerByWechatId(friendDto.getWechatId());
                 
                 WechatPersonalFriend friend = friendRepository.findByAccountIdAndCustomerId(accountId, friendCustomer.getId()).orElse(new WechatPersonalFriend());
                 friend.setAccountId(accountId);
                 friend.setCustomerId(friendCustomer.getId());
                 friend.setWechatId(friendDto.getWechatId());
                 friend.setAlias(friendDto.getAlias());
                 friend.setRemark(friendDto.getRemark());
                 // TODO: 更新添加时间、最后聊天时间等
                 friendRepository.save(friend);
            }
            log.info("Friend sync completed for account: {}", accountId);
            
            // TODO: 更新账号的同步时间
             account.setSyncTime(new Date());
             accountRepository.save(account);

        } catch (Exception e) {
            log.error("Failed to sync friends for account: " + accountId, e);
            throw new WechatPersonalSyncException("同步好友失败", e);
        }
    }
    
     private List<WechatFriendDTO> parseFriendData(Object deviceResultData) {
          // 解析设备控制服务返回的好友数据，转换为内部DTO列表
          // 需要处理设备端数据格式与内部DTO的映射
          return null;
     }

    // TODO: 实现获取好友列表、详情等方法 (包括分页、筛选、排序)
    // getFriendList(FriendQuery query): 分页查询好友列表
    // getFriendDetail(Long friendId): 获取好友详情 (关联客户信息)
    // updateFriendRemark/Tags(...): 更新好友备注或标签

    @Override
    @Transactional
    public void handleFriendRequest(FriendRequestEvent event) {
        log.info("Handling friend request from: {}", event.getRequesterWechatId());

        // TODO: 1. 查找对应的个人微信号 account
         WechatPersonalAccount account = accountRepository.findByWechatId(event.getMyWechatId()).orElse(null);
         if (account == null) {
              log.warn("Received friend request for unknown account: {}", event.getMyWechatId());
              // TODO: 返回错误响应给设备端或记录异常
              return;
         }

        // 2. 识别请求者，查找或创建客户
        // 使用 customerService.findOrCreateCustomerByWechatId(event.getRequesterWechatId(), event.getSource(), event.getVerificationText());
        // 在创建或查找客户时，可以根据来源和验证信息初始化客户信息或打标签
        Customer requester = customerService.findOrCreateCustomerByWechatId(event.getRequesterWechatId()); // TODO: 完善 findOrCreateCustomerByWechatId 方法

        // 3. 根据规则检查是否自动通过
        // ruleService.checkAutoAcceptRule(account.getId(), event.getSource(), event.getVerificationText()); // 规则检查应基于账号、来源和验证信息
        boolean autoAccept = ruleService.checkAutoAcceptRule(account.getId(), event); // 根据规则判断

        if (autoAccept) {
            log.info("Auto accepting friend request from: {}", event.getRequesterWechatId());
            // 4. 调用设备控制服务，自动通过好友请求
            try {
                 DeviceCommand command = new DeviceCommand();
                 command.setType(DeviceCommandType.ACCEPT_FRIEND_REQUEST);
                 command.setDeviceId(account.getDeviceId());
                 Map<String, Object> params = new HashMap<>();
                 params.put("friendWechatId", event.getRequesterWechatId()); // 需要通过的对方微信ID
                 params.put("ticket", event.getTicket()); // 使用ticket通过
                 // params.put("v3", event.getTicket()); // 根据设备端要求可能是 v3 字段
                 command.setParams(params);
                 
                 // 设备控制服务执行异步指令，等待设备端返回通过结果 Webhook
                 deviceControlService.executeCommand(account.getDeviceId(), command);

                 // TODO: 记录自动通过尝试日志

            } catch (Exception e) {
                 log.error("Failed to auto accept friend request from " + event.getRequesterWechatId(), e);
                 // TODO: 记录失败日志和告警
                 // TODO: 返回错误响应给设备端或记录异常
            }
        } else {
            log.info("Not auto accepting friend request from: {}", event.getRequesterWechatId());
            // TODO: 记录未自动通过日志
            // TODO: 可能需要通知用户手动处理 (通过内部消息或通知模块)
        }

        // TODO: 记录好友请求日志到专门的表 t_friend_request_log
        // friendRequestLogService.logRequest(event, autoAccept);
    }

    // TODO: 处理设备端推送的好友添加成功事件 Webhook，更新好友关系 t_wechat_personal_friend，触发后续流程 (如发送欢迎语)
    // handleFriendAddedEvent(FriendAddedEvent event): 接收好友添加成功事件，更新数据库，触发欢迎语等。
    // TODO: 处理好友删除事件 Webhook handleFriendDeletedEvent(...)
}
```

### 4.3 WechatPersonalMessageService

负责个人微信消息的发送、接收和自动化回复。

```java
@Service
@Slf4j
public class WechatPersonalMessageServiceImpl implements WechatPersonalMessageService {

    @Autowired
    private WechatPersonalMessageRepository messageRepository;
    
    @Autowired
    private WechatPersonalFriendRepository friendRepository;
    
    @Autowired
    private WechatPersonalAccountRepository accountRepository;
    
    @Autowired
    private DeviceControlService deviceControlService; // 调用设备控制服务发送消息
    
    @Autowired
    private AutoReplyService autoReplyService; // 自动回复规则服务
    
    @Autowired
    private CustomerService customerService; // 客户服务

    @Override
    @Transactional
    public void sendMessage(Long accountId, Long receiverId, MessageDTO dto) {
        log.info("Sending message from account {} to receiver {}: {}", accountId, receiverId, dto.getContent());

        WechatPersonalAccount account = accountRepository.findById(accountId)
                .orElseThrow(() -> new WechatAccountNotFoundException("Wechat personal account not found: " + accountId));

        // 根据 receiverId 和 receiverType 查找对应的微信ID
        String receiverWechatId = null;
        // TODO: 根据 dto.getReceiverType() 判断是好友还是群
        if ("FRIEND".equals(dto.getReceiverType())) { // TODO: 定义常量或枚举
            WechatPersonalFriend friend = friendRepository.findById(receiverId)
                 .orElseThrow(() -> new WechatFriendNotFoundException("Friend not found: " + receiverId));
             receiverWechatId = friend.getWechatId();
        } else if ("GROUP".equals(dto.getReceiverType())) {
             // TODO: 查找对应的群信息
             // WechatGroup group = groupRepository.findById(receiverId)...;
             // receiverWechatId = group.getWechatGroupId();
             throw new UnsupportedOperationException("Sending message to group not yet supported via personal account service"); // 或者调用群消息发送服务
        } else {
             throw new IllegalArgumentException("Invalid receiver type: " + dto.getReceiverType());
        }

        try {
            // 1. 调用设备控制服务发送消息
            DeviceCommand command = new DeviceCommand();
            command.setType(DeviceCommandType.SEND_MESSAGE);
            command.setDeviceId(account.getDeviceId());
            Map<String, Object> params = new HashMap<>();
            params.put("receiverWechatId", receiverWechatId);
            params.put("messageType", dto.getMessageType());
            // 根据消息类型设置内容或素材ID/URL
            if (MessageType.TEXT.equals(dto.getMessageType())) {
                params.put("content", dto.getContent());
            } else if (MessageType.IMAGE.equals(dto.getMessageType()) || MessageType.FILE.equals(dto.getMessageType())) {
                // TODO: 处理素材ID或URL，可能需要先下载素材并提供本地路径给设备端，或提供URL由设备端自行下载
                 String materialPath = null; // TODO: get material path/url from materialId
                 params.put("materialPath", materialPath); // 或 "fileUrl"
            } else if (MessageType.LINK.equals(dto.getMessageType())) {
                 // TODO: 处理链接消息参数
            }
            // ... 其他消息类型
            command.setParams(params);

            // 设备控制服务执行异步指令
            deviceControlService.executeCommand(account.getDeviceId(), command);

            // 2. 保存消息记录 (异步)
            // saveMessage(accountId, account.getWechatId(), receiverId, receiverWechatId, dto); // TODO: 实现保存消息逻辑
            // 可以先保存一个待发送状态的记录，等设备端回调确认发送成功再更新状态。

            log.info("Message sent task triggered from {} to {}", account.getWechatId(), receiverWechatId);

        } catch (Exception e) {
            log.error("Failed to trigger message send from account {} to receiver {}", accountId, receiverId, e);
            throw new MessageSendException("发送消息失败", e);
        }
    }
    
    @Override
    @Transactional
    public void handlePersonalMessage(PersonalMessageEvent event) {
         log.info("Handling personal message from {} to {}: {}", event.getSenderWechatId(), event.getReceiverWechatId(), event.getContent());

         // TODO: 1. 查找对应的个人微信号 account (receiver)
          WechatPersonalAccount account = accountRepository.findByWechatId(event.getReceiverWechatId()).orElse(null);
          if (account == null) {
               log.warn("Received message for unknown account: {}", event.getReceiverWechatId());
               // TODO: 返回错误响应给设备端或记录异常
               return;
          }

         // TODO: 2. 识别发送者和接收者，查找或创建客户
          Customer sender = customerService.findOrCreateCustomerByWechatId(event.getSenderWechatId()); // 发送消息的客户/好友
          Customer receiver = customerService.findOrCreateCustomerByWechatId(event.getReceiverWechatId()); // 接收消息的个人微信号对应的存客宝用户

         // TODO: 3. 保存消息记录
         // saveMessage(account.getId(), sender.getId(), receiver.getId(), event); // TODO: 实现保存消息逻辑
         // 需要考虑消息去重 (使用设备端提供的 messageId)，消息类型处理 (文本、图片、文件等)
         // 更新好友的 lastChatTime
         // friendRepository.updateLastChatTime(account.getId(), sender.getId(), event.getSendTime());

         // 4. 触发自动化处理 (如自动回复)
         if (MessageType.TEXT.equals(event.getMessageType())) { // TODO: 定义消息类型常量或枚举
              // check keyword rules, auto reply rules etc.
              String autoReplyContent = autoReplyService.getPersonalAutoReply(account.getId(), sender.getId(), event.getContent());
              if (autoReplyContent != null) {
                   // 调用发送消息方法 (异步发送)
                   sendMessage(account.getId(), sender.getId(), new MessageDTO(MessageType.TEXT, autoReplyContent, "FRIEND")); // TODO: Pass receiverType correctly
              }
         }

         // TODO: 其他消息处理逻辑，如关键词处理、会话管理、敏感词检测等
         // 会话管理服务处理会话状态和记录
         // SensitiveWordService 敏感词检测
    }

    // TODO: 实现获取消息记录、自动回复规则管理等方法
    // getMessageList(MessageQuery query): 分页查询消息记录
    // getMessageDetail(Long messageId): 获取消息详情
    // saveAutoReplyRule(...): 保存自动回复规则
    // getAutoReplyRules(...): 查询自动回复规则
}
```

### 4.4 WechatPersonalMomentService

负责朋友圈的发布、同步和互动处理。

```java
@Service
@Slf4j
public class WechatPersonalMomentServiceImpl implements WechatPersonalMomentService {

    @Autowired
    private WechatPersonalMomentRepository momentRepository;
    
    @Autowired
    private WechatPersonalAccountRepository accountRepository;
    
    @Autowired
    private DeviceControlService deviceControlService; // 调用设备控制服务
    
    @Autowired
    private CustomerService customerService; // 客户服务

    @Override
    @Transactional
    public void publishMoment(Long accountId, MomentDTO dto) {
        log.info("Publishing moment for account: {}", accountId);
        
        WechatPersonalAccount account = accountRepository.findById(accountId)
                .orElseThrow(() -> new WechatAccountNotFoundException("Wechat personal account not found: " + accountId));
        
        try {
            // 1. 调用设备控制服务发布朋友圈
            DeviceCommand command = new DeviceCommand();
            command.setType(DeviceCommandType.PUBLISH_MOMENT);
            command.setDeviceId(account.getDeviceId());
            Map<String, Object> params = new HashMap<>();
            params.put("content", dto.getContent());
            // TODO: 支持图片、视频、链接等
            if (dto.getMediaUrls() != null) {
                params.put("mediaUrls", dto.getMediaUrls());
            }
            command.setParams(params);
            
            DeviceCommandResult result = deviceControlService.executeCommand(account.getDeviceId(), command);
            
            // 2. 保存朋友圈记录 (如果设备端返回朋友圈ID)
            // TODO: Parse moment ID from result and save to t_wechat_personal_moment table
            // result.getData() might contain momentId
            // WechatPersonalMoment moment = new WechatPersonalMoment();
            // moment.setAccountId(accountId);
            // moment.setMomentId(result.getData().get("momentId").toString());
            // moment.setContent(dto.getContent());
            // ... save other fields
            // momentRepository.save(moment);
            log.info("Moment publish task triggered for account: {}", accountId);

        } catch (Exception e) {
            log.error("Failed to trigger moment publish task for account: " + accountId, e);
            throw new MomentPublishException("发布朋友圈失败", e);
        }
    }
    
    @Override
    @Transactional
    public void handleMomentInteraction(MomentInteractionEvent event) {
        log.info("Handling moment interaction for moment {} type {}", event.getMomentId(), event.getInteractionType());
        
        // TODO: 1. 根据event中的 momentId 查找对应的朋友圈记录
         WechatPersonalMoment moment = momentRepository.findByMomentId(event.getMomentId()).orElse(null);
         if (moment == null) {
              log.warn("Received interaction for unknown moment: {}", event.getMomentId());
              // TODO: 返回错误响应给设备端或记录异常
              return;
         }
        
        // TODO: 2. 识别互动用户，查找或创建客户
         Customer interactor = customerService.findOrCreateCustomerByWechatId(event.getInteractorWechatId()); // 发起互动者

        // TODO: 3. 记录互动事件 (点赞或评论) 到 t_moment_interaction 表
        // MomentInteraction interaction = new MomentInteraction();
        // interaction.setMomentId(moment.getId());
        // interaction.setInteractorId(interactor.getId());
        // interaction.setInteractionType(event.getInteractionType());
        // if ("COMMENT".equals(event.getInteractionType())) {
        //     interaction.setCommentContent(event.getCommentContent());
        // }
        // interaction.setCreateTime(event.getCreateTime());
        // momentInteractionRepository.save(interaction);

        // TODO: 4. 更新朋友圈的评论数或点赞数 (t_wechat_personal_moment 表的 like_count, comment_count 字段)
         updateMomentStats(moment.getId(), event.getInteractionType());

        // TODO: 5. 如果是评论，可能需要触发自动回复或通知
         if ("COMMENT".equals(event.getInteractionType())) {
              // handleMomentComment(moment, interactor, event.getCommentContent()); // 例如：检查关键词回复规则
              // NotificationService.notifyUserAboutComment(...); // 通知朋友圈主人有新的评论
         }
         // TODO: 如果是点赞，可能需要通知或记录
          if ("LIKE".equals(event.getInteractionType())) {
               // NotificationService.notifyUserAboutLike(...);
          }
    }
    
    // TODO: 实现获取朋友圈列表、同步朋友圈等方法
    // getMomentList(MomentQuery query): 分页查询朋友圈列表
    // getMomentDetail(Long momentId): 获取朋友圈详情 (可能包含互动列表)
    // syncMoments(Long accountId): 同步朋友圈记录
}
```

### 4.5 BatchTaskService

负责批量任务的创建、执行和状态管理。

```java
@Service
@Slf4j
public class BatchTaskServiceImpl implements BatchTaskService {

    @Autowired
    private BatchTaskRepository batchTaskRepository;

    @Autowired
    private WechatPersonalAccountRepository accountRepository;

    @Autowired
    private DeviceControlService deviceControlService;

    @Autowired
    private WechatPersonalFriendRepository friendRepository;

    @Autowired
    private WechatPersonalMessageService messageService; // 用于批量发送消息

    @Autowired
    private WechatPersonalFriendRepository friendRequestService; // 用于批量通过好友请求


    @Override
    @Transactional
    public BatchTaskVO createBatchTask(BatchTaskDTO dto) {
        log.info("Creating batch task of type {} for account {}", dto.getTaskType(), dto.getAccountId());

        WechatPersonalAccount account = accountRepository.findById(dto.getAccountId())
                .orElseThrow(() -> new WechatAccountNotFoundException("Wechat personal account not found: " + dto.getAccountId()));

        // TODO: 1. 验证任务参数的合法性 (targetIds, taskConfig)
        validateBatchTask(dto);

        // 2. 保存批量任务记录
        BatchTask task = new BatchTask();
        task.setTaskType(dto.getTaskType());
        task.setAccountId(dto.getAccountId());
        task.setTotalCount(dto.getTargetIds().size());
        task.setCompletedCount(0);
        task.setFailedCount(0);
        task.setStatus(BatchTaskStatus.PENDING); // 初始状态为待处理
        task.setTaskConfig(serializeTaskConfig(dto.getTaskConfig())); // 序列化任务配置
        task.setCreateTime(new Date());
        // TODO: 如果有 scheduledTime，设置 scheduledTime 字段

        BatchTask savedTask = batchTaskRepository.save(task);

        // 3. 触发任务执行 (如果是立即执行)
        if (dto.getScheduledTime() == null || dto.getScheduledTime().before(new Date())) {
            triggerBatchTaskExecution(savedTask.getId());
        } else {
             // TODO: 使用任务调度服务安排定时执行
             // taskSchedulerService.schedule(Runnable taskExecutor, dto.getScheduledTime());
        }

        log.info("Batch task {} created with ID: {}", task.getTaskType(), savedTask.getId());
        return buildBatchTaskVO(savedTask);
    }

    // TODO: 实现 validateBatchTask(BatchTaskDTO dto) 方法
    // TODO: 实现 serializeTaskConfig(Object config) / deserializeTaskConfig(String configJson, TaskType type) 方法
    // TODO: 实现 buildBatchTaskVO(BatchTask task) 方法

    // 触发批量任务执行的内部方法
    @Transactional
    public void triggerBatchTaskExecution(Long taskId) {
        log.info("Triggering execution for batch task: {}", taskId);

        BatchTask task = batchTaskRepository.findById(taskId)
                .orElseThrow(() -> new BatchTaskNotFoundException("Batch task not found: " + taskId));

        if (task.getStatus() != BatchTaskStatus.PENDING) {
            log.warn("Batch task {} is not in PENDING status, skipping execution.", taskId);
            return;
        }

        task.setStatus(BatchTaskStatus.RUNNING); // 更新状态为运行中
        task.setStartTime(new Date());
        batchTaskRepository.save(task);

        // 根据任务类型执行具体逻辑
        switch (task.getTaskType()) {
            case BATCH_MESSAGE:
                executeBatchMessageTask(task);
                break;
            case BATCH_ADD_FRIEND:
                executeBatchAddFriendTask(task);
                break;
            // TODO: 其他任务类型
            default:
                log.error("Unknown batch task type: {}", task.getTaskType());
                task.setStatus(BatchTaskStatus.FAILED);
                task.setEndTime(new Date());
                // TODO: 记录失败原因
                batchTaskRepository.save(task);
                break;
        }

        // 任务执行完毕，更新最终状态
        // 对于异步任务，这里的状态更新可能只是表示任务已提交到处理队列。
    }

    // 执行批量发送消息任务
    private void executeBatchMessageTask(BatchTask task) {
        log.info("Executing batch message task: {}", task.getId());
        BatchMessageConfig config = deserializeTaskConfig(task.getTaskConfig(), BatchMessageConfig.class); // TODO: 定义 BatchMessageConfig DTO
        List<Long> targetFriendIds = config.getTargetFriendIds(); // TODO: targetIds 字段如何存储和获取？可能需要单独的关联表或存储在 task_config JSON中。

        for (Long friendId : targetFriendIds) {
            try {
                // 调用消息发送服务发送消息 (异步发送)
                messageService.sendMessage(task.getAccountId(), friendId, new MessageDTO(config.getMessageType(), config.getContent(), "FRIEND")); // TODO: Pass receiverType correctly
                // TODO: 更新任务的 completedCount
                task.setCompletedCount(task.getCompletedCount() + 1);
            } catch (Exception e) {
                log.error("Failed to send message to friend {} in task {}", friendId, task.getId(), e);
                // TODO: 记录失败原因，更新任务的 failedCount
                task.setFailedCount(task.getFailedCount() + 1);
            }
             // TODO: 批量保存任务状态，而不是每次循环都保存
        }

        // 任务执行完毕，更新最终状态
        task.setStatus(task.getFailedCount() > 0 ? BatchTaskStatus.COMPLETED_WITH_ERRORS : BatchTaskStatus.COMPLETED);
        task.setEndTime(new Date());
        batchTaskRepository.save(task);
        log.info("Batch message task {} execution completed.", task.getId());
    }

    // 执行批量通过好友请求任务
    private void executeBatchAddFriendTask(BatchTask task) {
        log.info("Executing batch add friend task: {}", task.getId());
        BatchAddFriendConfig config = deserializeTaskConfig(task.getTaskConfig(), BatchAddFriendConfig.class); // TODO: 定义 BatchAddFriendConfig DTO
        List<Long> targetRequestIds = config.getTargetRequestIds(); // 待通过的好友请求记录ID列表

        for (Long requestId : targetRequestIds) {
            try {
                 // TODO: 根据 requestId 查找 FriendRequestEvent 数据 (或直接存储在 task_config 中)
                 // FriendRequestEvent event = friendRequestService.getFriendRequestEvent(requestId);

                 // 调用好友请求服务自动通过方法
                 // friendRequestService.autoAcceptFriendRequest(event);
                 // TODO: 更新任务的 completedCount
                task.setCompletedCount(task.getCompletedCount() + 1);
            } catch (Exception e) {
                log.error("Failed to auto accept friend request {} in task {}", requestId, task.getId(), e);
                // TODO: 记录失败原因，更新任务的 failedCount
                task.setFailedCount(task.getFailedCount() + 1);
            }
             // TODO: 批量保存任务状态
        }

        // 任务执行完毕，更新最终状态
         task.setStatus(task.getFailedCount() > 0 ? BatchTaskStatus.COMPLETED_WITH_ERRORS : BatchTaskStatus.COMPLETED);
         task.setEndTime(new Date());
         batchTaskRepository.save(task);
         log.info("Batch add friend task {} execution completed.", task.getId());
    }

    // TODO: 实现查询批量任务列表、详情等方法
    // getBatchTaskList(BatchTaskQuery query): 分页查询批量任务列表
    // getBatchTaskDetail(Long taskId): 获取批量任务详情
}
```

## 5. 流程图

```mermaid
graph TD
    A[前端/其他服务触发]-->B[调用后端API创建个人微信任务]
    B-->C[后端验证参数/保存任务记录]
    C-->D{任务类型判断}
    D-->E[连接微信号任务]
    E-->F[调用设备控制服务/获取二维码]
    F-->G[后端返回二维码给前端]
    G-->H[用户扫码登录]
    H-->I[设备推送登录状态/事件Webhook]
    I-->J[后端接收Webhook/更新账号状态]

    D-->K[好友同步任务]
    K-->L[调用设备控制服务/获取好友列表]
    L-->M[后端解析好友数据/更新数据库]

    D-->N[发送消息任务]
    N-->O[查找接收者微信ID]
    O-->P[调用设备控制服务/发送消息]
    P-->Q[设备推送消息发送结果Webhook]
    Q-->R[后端接收Webhook/更新消息状态]

    D-->S[发布朋友圈任务]
    S-->T[调用设备控制服务/发布朋友圈]
    T-->U[设备推送发布结果Webhook]
    U-->V[后端接收Webhook/记录朋友圈]

    D-->W[批量任务]
    W-->X[保存批量任务记录/安排执行]
    X-->Y[任务执行器/根据任务类型]
    Y-->Z[调用其他服务/如消息发送/好友请求处理]
    Z-->AA[更新任务状态/记录结果]

    AB[设备推送新好友请求Webhook]-->AC[后端接收Webhook/验证/记录]
    AC-->AD{规则判断/是否自动通过}
    AD-->AE[自动通过]-->AF[调用设备控制服务/通过请求]
    AF-->AG[设备推送好友添加成功Webhook]
    AG-->AH[后端接收Webhook/更新好友关系/触发欢迎语]
    AD-->AI[手动处理/通知用户]

    AJ[设备推送个人消息Webhook]-->AK[后端接收Webhook/验证/记录]
    AK-->AL{触发自动化规则}
    AL-->AM[自动回复/关键词处理]
    AM-->AN[调用发送消息服务]

    AO[设备推送朋友圈互动Webhook]-->AP[后端接收Webhook/验证/记录互动]
    AP-->AQ[更新朋友圈统计/触发通知]
```

## 6. 异常处理

- `WechatPersonalAuthException`: 个人微信授权/连接相关异常
- `WechatAccountNotFoundException`: 个人微信号账号不存在
- `WechatFriendNotFoundException`: 好友不存在
- `MessageSendException`: 发送消息失败
- `MomentPublishException`: 发布朋友圈失败
- `BatchTaskException`: 批量任务执行异常
- `FriendRequestRuleException`: 好友请求规则相关异常
- `InvalidSignatureException`: Webhook签名验证失败
- `DeviceControlException`: 调用设备控制服务异常

## 7. 与前端的交互流程

1. **连接微信号:** 前端调用连接接口，后端返回二维码URL和任务ID。前端展示二维码并轮询任务状态接口，直到状态变为已登录或失败。
2. **管理账号/好友:** 前端调用获取账号/好友列表接口，后端查询并返回数据。前端展示列表并提供筛选、搜索功能。更新好友信息等操作调用相应的PUT/POST接口。
3. **处理新好友请求:** 设备端推送Webhook到后端。后端处理规则，如果自动通过，调用设备控制服务；否则记录并通知用户。前端定期或通过WebSocket接收通知，显示新好友请求列表。
4. **发送消息:** 前端调用发送消息接口，指定接收者和消息内容。后端触发异步发送任务。发送结果可能通过Webhook推送，后端更新消息状态。
5. **朋友圈:** 前端调用发布朋友圈接口，后端触发异步任务。前端调用获取朋友圈列表接口展示朋友圈。朋友圈互动（点赞评论）通过Webhook推送，后端记录并更新统计。
6. **批量任务:** 前端调用创建批量任务接口，后端保存任务并安排执行。前端调用查询任务列表/详情接口查看任务状态和结果。

---

#### 开发注意事项和实现要点

1.  **与设备控制服务的交互:**
    - 个人微信的实际操作（登录、获取好友、发送消息、朋友圈、批量任务等）都依赖于设备控制服务。
    - 后端与设备控制服务之间的通信需要设计稳定可靠的协议，处理指令下发和事件推送。
    - 指令执行通常是异步的，需要通过任务ID或事件关联来追踪状态。
    - Webhook是设备向上报事件（新消息、新好友、登录状态变化、任务结果等）的关键机制，必须确保Webhook接口的高可用性和安全性（验签）。
2.  **数据同步:**
    - 好友列表、群列表、朋友圈等数据需要定期或手动从设备端同步到后端数据库。
    - 同步过程需要考虑增量更新、数据去重、长时间同步的处理（可能需要分批或后台任务）。
3.  **消息处理:**
    - 接收到的个人聊天消息需要进行处理，包括保存消息记录、触发自动回复、关键词检测、会话管理等。
    - 消息处理流程可能较复杂，建议设计为异步处理，例如将接收到的消息放入消息队列。
    - 需要考虑消息去重，确保同一消息只处理一次（使用设备端提供的messageId）。
4.  **自动化任务:**
    - 自动通过好友请求、自动回复、批量发送消息、批量加好友等自动化任务需要在后端实现。这些任务通常依赖于配置的规则，并通过设备控制服务执行。
    - 批量任务可能耗时较长且容易失败，需要设计任务执行器、状态追踪、失败重试、日志记录和告警机制。
5.  **规则引擎:**
    - 自动通过好友请求规则、自动回复规则等需要灵活配置和管理。
    - 可以考虑使用简单的规则引擎或表达式解析器来实现规则判断逻辑。
6.  **数据模型:**
    - 设计合理的数据表结构来存储个人微信号账号、好友、消息、朋友圈、规则、批量任务等数据。
    - 需要考虑数据之间的关联关系（如账号与设备、好友与客户、消息与账号/好友）。
    - 对于好友、消息、朋友圈等数据量可能较大的表，需要考虑索引优化和归档策略。
7.  **用户识别与关联:**
    - 在处理新好友请求、接收消息、朋友圈互动时，需要根据微信ID等信息在存客宝现有用户/客户中进行识别或创建新的客户记录，并建立关联关系。
8.  **错误处理:**
    - 遵循 `./前后端接口约定.md` 中的错误处理规范。
    - 捕获并处理与设备控制服务交互、数据库操作、规则执行、批量任务执行等过程中可能发生的各种异常。
    - Webhook 接口的异常处理需要特殊考虑，通常返回 200 表示接收成功，实际业务处理失败通过日志和告警监控。
9.  **日志记录:**
    - 记录所有关键操作日志，包括：
        - 个人微信号的连接、登录状态变化、掉线、封号。
        - 好友的添加、删除、信息更新、同步结果。
        - 消息的发送、接收、处理状态、自动回复触发。
        - 朋友圈的发布、同步、互动。
        - 好友请求的接收、规则判断、自动通过尝试、处理结果。
        - 批量任务的创建、执行状态变化、成功/失败详情。
        - 与设备控制服务的交互日志、Webhook接收日志。
        - 所有异常日志。
    - 日志应包含时间、相关ID（账号ID、好友ID、消息ID、任务ID）、操作类型、操作人（如果适用）、操作结果、错误信息等信息。
10. **安全性:**
    - 所有面向前端的接口必须进行认证授权校验。
    - Webhook 接口需要进行签名验证等安全措施，确保消息来源可信。
    - 存储敏感信息（如微信ID、聊天记录、朋友圈内容等）需要进行脱敏或加密处理。
    - 对自动化任务的配置和执行进行权限控制，防止滥用。
    - 与设备控制服务之间的通信需要加密。
11. **性能与并发:**
    - Webhook 接口可能面临高并发的消息和事件推送，需要设计为快速响应并将实际处理逻辑放入消息队列异步执行。
    - 批量任务、数据同步等可能耗时较长的操作应设计为后台异步任务。
    - 优化数据库查询性能。
12. **幂等性:**
    - 接收到的消息、好友添加事件等可能存在重复推送，后端需要实现幂等性处理，确保同一事件只处理一次（例如基于messageId或事件唯一标识进行去重）。

--- 

---

## 文件 8: 后端-场景获客-公众号获客功能开发文档.md

*文件大小：13.91 KB*

---

# 存客宝场景获客-公众号获客功能开发文档

## 1. 模块概述

公众号获客功能通过集成微信公众号，实现自动回复、关键词回复、菜单管理、粉丝互动、模板消息等能力，帮助用户通过公众号 جذب and retain customers。后端模块负责微信公众号的对接配置、消息接收与处理、素材管理、用户管理以及通过公众号进行用户触达。

## 2. API接口设计

### 2.1 配置公众号信息

- **接口路径**：`/api/v1/lead-generation/wechat-mp/config`
- **请求方法**：`POST`
- **接口说明**：配置微信公众号的基本信息（AppID, AppSecret, Token, EncodingAESKey）。
- **请求参数**：

```json
{
  "appId": "YOUR_APPID",
  "appSecret": "YOUR_APPSECRET",
  "token": "YOUR_TOKEN",
  "encodingAesKey": "YOUR_ENCODING_AES_KEY"
}
```

- **响应结果**：

```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "configId": 401,
    "appId": "YOUR_APPID",
    "status": "CONFIGURED" // 表示配置成功
  },
  "timestamp": 1698290400000
}
```

### 2.2 获取公众号配置

- **接口路径**：`/api/v1/lead-generation/wechat-mp/config`
- **请求方法**：`GET`
- **接口说明**：获取已配置的微信公众号信息。

### 2.3 处理微信服务器验证与消息回调

- **接口路径**：`/api/v1/webhook/wechat-mp/{appId}`
- **请求方法**：`GET` (服务器验证) / `POST` (消息回调)
- **接口说明**：接收微信公众号服务器发送的验证请求和用户消息/事件推送。后端需要根据微信的协议进行验证和消息处理。
- **请求参数**：根据微信公众号回调协议而定（signature, timestamp, nonce, echostr for GET; encrypted message data for POST）。

### 2.4 管理自动回复规则

- **接口路径**：`/api/v1/lead-generation/wechat-mp/auto-replies`
- **请求方法**：`POST`/`GET`/`PUT`/`DELETE`
- **接口说明**：对关键词回复和关注后回复规则进行增删改查。

### 2.5 管理公众号菜单

- **接口路径**：`/api/v1/lead-generation/wechat-mp/menu`
- **请求方法**：`GET`/`POST`
- **接口说明**：获取或更新公众号菜单。

### 2.6 发送模板消息

- **接口路径**：`/api/v1/lead-generation/wechat-mp/template-messages`
- **请求方法**：`POST`
- **接口说明**：发送模板消息给指定用户。
- **请求参数**：

```json
{
  "openId": "USER_OPENID",
  "templateId": "TEMPLATE_ID",
  "url": "TARGET_URL",
  "data": { // 模板消息数据
    "first": {
      "value": "欢迎加入",
      "color": "#173177"
    },
    "keyword1": {
      "value": "新用户",
      "color": "#173177"
    },
    // ... 其他关键词
  }
}
```

## 3. 数据模型设计

### 3.1 主要数据表

| 表名                 | 说明            | 关键字段                                   |
|---------------------|----------------|-------------------------------------------|
| t_wechat_mp_config  | 公众号配置表    | id, app_id, app_secret, token, encoding_aes_key, status |
| t_wechat_mp_message | 公众号消息记录表| id, app_id, msg_id, msg_type, event, open_id, content, create_time |
| t_wechat_mp_reply_rule| 公众号回复规则表| id, app_id, rule_type, keyword, reply_content, status |
| t_wechat_mp_user    | 公众号粉丝信息表| id, app_id, open_id, union_id, nickname, subscribe_time, status |

## 4. 服务实现

### 4.1 WechatMpConfigService

负责微信公众号配置信息的管理。

```java
@Service
@Slf4j
public class WechatMpConfigServiceImpl implements WechatMpConfigService {

    @Autowired
    private WechatMpConfigRepository configRepository;

    @Override
    @Transactional
    public WechatMpConfigVO saveConfig(WechatMpConfigDTO dto) {
        log.info("Saving Wechat MP config for appId: {}", dto.getAppId());
        
        // 1. 保存或更新配置信息
        WechatMpConfig config = configRepository.findByAppId(dto.getAppId()).orElse(new WechatMpConfig());
        config.setAppId(dto.getAppId());
        config.setAppSecret(dto.getAppSecret());
        config.setToken(dto.getToken());
        config.setEncodingAesKey(dto.getEncodingAesKey());
        config.setStatus(ConfigStatus.CONFIGURED);
        
        WechatMpConfig savedConfig = configRepository.save(config);
        
        // TODO: 初始化或更新微信SDK配置
        initWechatMpSdk(savedConfig);
        
        return buildConfigVO(savedConfig);
    }
    
    // TODO: 实现获取配置、删除配置等方法
    
    private void initWechatMpSdk(WechatMpConfig config) {
        // 使用 savedConfig 的信息初始化或更新微信公众号SDK (如WxJava)
        // 例如: WxMpService wxMpService = new WxMpServiceImpl();
        // WxMpDefaultConfigImpl wxConfigProvider = new WxMpDefaultConfigImpl();
        // wxConfigProvider.setAppId(config.getAppId());
        // ... 设置其他信息
        // wxMpService.setWxMpConfigStorage(wxConfigProvider);
        // TODO: 将初始化的 service 存储起来，供后续使用 (可能需要考虑多公众号)
    }
}
```

### 4.2 WechatMpMessageService

负责处理微信公众号接收到的消息和事件。

```java
@Service
@Slf4j
public class WechatMpMessageServiceImpl implements WechatMpMessageService {

    @Autowired
    private WechatMpMessageRepository messageRepository;
    
    @Autowired
    private WechatMpReplyService replyService; // 自动回复服务
    
    @Autowired
    private CustomerService customerService; // 客户服务

    @Override
    @Transactional
    public String handleMessage(String appId, String requestBody, Map<String, String> headers) {
        log.info("Handling Wechat MP message for appId: {}", appId);
        
        // TODO: 根据appId获取对应的微信SDK实例
        WxMpService wxMpService = getWxMpService(appId);
        if (wxMpService == null) {
             log.error("Wechat MP config not found for appId: {}", appId);
             return ""; // 或返回错误响应
        }

        try {
            // 1. 解密和解析微信消息
            WxMpXmlMessage wxMessage = wxMpService.getMessageHandler().handle(requestBody);
            log.info("Received Wechat MP message: {}", wxMessage.toJson());
            
            // 2. 保存原始消息记录
            saveMessage(appId, wxMessage);
            
            // 3. 根据消息类型和内容进行处理
            WxMpXmlOutMessage responseMessage = null;
            
            switch (wxMessage.getMsgType()) {
                case WxConsts.XmlMsgType.EVENT:
                    responseMessage = handleEvent(wxMessage); // 处理事件，如关注、扫码等
                    break;
                case WxConsts.XmlMsgType.TEXT:
                    responseMessage = handleTextMsg(wxMessage); // 处理文本消息
                    break;
                // TODO: 处理其他消息类型，如IMAGE, VOICE, VIDEO, SHORTVIDEO, LOCATION, LINK
                default:
                    log.warn("Unknown Wechat MP message type: {}", wxMessage.getMsgType());
                    break;
            }
            
            // 4. 返回响应给微信服务器 (如果需要)
            if (responseMessage != null) {
                return responseMessage.toXml();
            } else {
                return "success"; // 告诉微信服务器已收到消息
            }
            
        } catch (Exception e) {
            log.error("Failed to handle Wechat MP message", e);
            return ""; // 返回空字符串或错误响应
        }
    }
    
    private void saveMessage(String appId, WxMpXmlMessage wxMessage) {
        // 将微信消息保存到 t_wechat_mp_message 表
    }
    
    private WxMpXmlOutMessage handleEvent(WxMpXmlMessage wxMessage) {
        // 处理微信事件，如用户关注(subscribe)、取消关注(unsubscribe)、扫码(SCAN)
        if (WxConsts.Event.SUBSCRIBE.equals(wxMessage.getEvent())) {
            // 用户关注事件
            log.info("User subscribed: {}", wxMessage.getFromUser());
            // TODO: 识别或创建存客宝客户，并标记为公众号粉丝
             customerService.processWechatMpSubscribe(wxMessage.getFromUser(), wxMessage.getAppId(), wxMessage.getEventKey());
             
            // 调用自动回复服务获取关注后回复内容
            return replyService.getSubscribeReply(wxMessage.getAppId(), wxMessage.getFromUser());
            
        } else if (WxConsts.Event.UNSUBSCRIBE.equals(wxMessage.getEvent())) {
            // 用户取消关注事件
             log.info("User unsubscribed: {}", wxMessage.getFromUser());
             // TODO: 更新存客宝客户的公众号粉丝状态
             customerService.processWechatMpUnsubscribe(wxMessage.getFromUser(), wxMessage.getAppId());
        }
        // TODO: 处理其他事件，如SCAN, CLICK, VIEW等
        return null;
    }
    
    private WxMpXmlOutMessage handleTextMsg(WxMpXmlMessage wxMessage) {
        log.info("Received text message from {}: {}", wxMessage.getFromUser(), wxMessage.getContent());
        // 调用自动回复服务，根据关键词获取回复内容
        return replyService.getKeywordReply(wxMessage.getAppId(), wxMessage.getContent(), wxMessage.getFromUser());
    }

    // TODO: 获取WxMpService实例的方法 (需要考虑多公众号的情况)
    private WxMpService getWxMpService(String appId) {
        return null; // 从缓存或注册中心获取
    }
}
```

### 4.3 WechatMpReplyService

负责管理和提供公众号的自动回复内容（关注后回复、关键词回复）。

```java
@Service
@Slf4j
public class WechatMpReplyServiceImpl implements WechatMpReplyService {

    @Autowired
    private WechatMpReplyRuleRepository replyRuleRepository;
    
    // TODO: 其他服务，如素材服务，用于构建图文消息回复

    @Override
    public WxMpXmlOutMessage getSubscribeReply(String appId, String openId) {
        log.info("Getting subscribe reply for appId: {}", appId);
        // TODO: 查询关注后回复规则，构建回复消息
        // 可能返回文本、图片、图文等类型的消息
        return null; 
    }
    
    @Override
    public WxMpXmlOutMessage getKeywordReply(String appId, String keyword, String openId) {
         log.info("Getting keyword reply for appId: {} and keyword: {}", appId, keyword);
        // TODO: 查询关键词回复规则，匹配关键词，构建回复消息
        return null; 
    }
    
    // TODO: 实现规则的增删改查方法
}
```

### 4.4 WechatMpUserService

负责同步和管理公众号粉丝信息。

```java
@Service
@Slf4j
public class WechatMpUserServiceImpl implements WechatMpUserService {

    @Autowired
    private WechatMpUserRepository userRepository;
    
    // TODO: 其他服务，如调用微信API获取粉丝列表等

    @Override
    @Transactional
    public void syncFansList(String appId) {
        log.info("Syncing fans list for appId: {}", appId);
        // TODO: 调用微信API获取粉丝列表，更新或保存到 t_wechat_mp_user 表
        // 需要处理分页获取、增量更新等逻辑
    }
    
     @Override
     @Transactional
     public void processWechatMpSubscribe(String openId, String appId, String eventKey) {
         log.info("Processing subscribe event for openId: {}", openId);
         // TODO: 查找或创建存客宝客户，并记录其公众号openId和关注状态
         // 如果 eventKey 包含场景值，也需要处理，用于追踪获客来源
     }
     
     @Override
     @Transactional
     public void processWechatMpUnsubscribe(String openId, String appId) {
         log.info("Processing unsubscribe event for openId: {}", openId);
          // TODO: 更新存客宝客户的公众号关注状态
     }

    // TODO: 实现获取粉丝信息等方法
}
```

## 5. 流程图

```mermaid
graph TD
    A[用户在前端配置公众号信息] --> B[调用后端配置接口]
    B --> C[后端保存配置]
    C --> D[后端初始化微信SDK]

    E[用户关注/发送消息到公众号] --> F[微信服务器推送消息/事件到存客宝后端Webhook]
    F --> G[后端Webhook接收]
    G --> H[根据AppID获取SDK实例]
    H --> I[验证签名/解密消息]
    I --> J[解析消息/事件]
    J --> K[保存消息记录]
    K --> L{消息类型/事件类型判断}
    L -- Event: subscribe --> M[处理关注事件/识别客户]
    M --> N[获取关注后回复内容]
    N --> O[返回回复消息给微信服务器]
    L -- Msg: text --> P[处理文本消息]
    P --> Q[根据关键词获取回复内容]
    Q --> O
    L -- Other --> R[处理其他类型/忽略]
    R --> O
    O --> S[微信服务器发送回复给用户]

    T[用户在前端管理回复规则/菜单] --> U[调用后端对应API]
    U --> V[后端更新数据库/调用微信API更新菜单]

    W[后端定时/手动] --> X[调用后端同步粉丝接口]
    X --> Y[后端调用微信API获取粉丝列表]
    Y --> Z[后端更新粉丝信息到数据库]
```

## 6. 异常处理

- `WechatMpConfigException`: 公众号配置异常
- `InvalidSignatureException`: 微信消息签名验证失败
- `MessageHandlingException`: 微信消息处理异常
- `WechatApiException`: 调用微信公众号API异常

## 7. 定时任务

- 定时同步公众号粉丝列表，确保粉丝数据的准确性。
- 定时检查Access Token是否过期，触发刷新逻辑。

## 8. 与前端的交互流程

1. 前端提供公众号配置入口，用户输入公众号信息后调用后端"配置公众号信息"接口。
2. 后端保存配置，并提供Webhook URL给用户在微信公众号后台配置。
3. 用户在微信公众号后台完成服务器配置。
4. 用户关注公众号或发送消息时，微信服务器将消息推送至存客宝后端Webhook接口。
5. 后端Webhook服务处理消息，根据规则自动回复，并更新客户信息（如关注状态）。
6. 前端调用API管理自动回复规则和公众号菜单。
7. 后端定时同步粉丝列表，前端可展示粉丝数据。
8. 后端提供发送模板消息接口，前端可触发向用户发送服务通知等。 

---

## 文件 9: 后端-场景获客-海报获客功能开发文档.md

*文件大小：35.00 KB*

---

# 存客宝场景获客-海报获客功能开发文档

## 1. 模块概述

海报获客功能通过生成带有用户专属二维码的个性化推广海报，鼓励用户分享，并追踪通过海报扫描带来的新用户，实现裂变获客。后端模块负责海报模板管理、用户专属二维码生成、海报合成、扫码事件追踪、新用户归因及数据统计。

## 2. API接口设计

### 2.1 创建海报模板

- **接口路径**：`/api/v1/lead-generation/posters/templates`
- **请求方法**：`POST`
- **接口说明**：上传或定义一个海报模板，包含背景图、文本区域、二维码占位符等。
- **权限:** `poster:template:create`
- **请求参数 (Request Body):**

| 参数名            | 类型             | 是否必需 | 说明                                  | 示例值 |
|-------------------|------------------|----------|---------------------------------------|--------|
| name              | string           | 是       | 海报模板名称                          | 裂变活动推广海报 |
| description       | string           | 否       | 海报模板描述                          | 用于分享推广新用户的海报 |
| backgroundImageUrl| string           | 是       | 海报背景图片URL (OSS地址)             | http://oss.example.com/bg.png |
| elements          | array<object>    | 是       | 海报元素列表 (文本、图片、二维码占位符) | `[...]` |

`elements` 数组中的对象结构示例：

**文本元素 (type="TEXT"):**
| 参数名   | 类型   | 是否必需 | 说明     | 示例值   |
|----------|--------|----------|----------|----------|
| type     | string | 是       | 元素类型 | TEXT     |
| content  | string | 是       | 文本内容 | 邀请你加入 |
| x        | integer| 是       | X坐标    | 100      |
| y        | integer| 是       | Y坐标    | 200      |
| fontSize | integer| 是       | 字体大小 | 24       |
| color    | string | 是       | 字体颜色 | #333     |
| font     | string | 否       | 字体名称 | SimHei   |

**二维码元素 (type="QR_CODE"):**
| 参数名      | 类型   | 是否必需 | 说明           | 示例值        |
|-------------|--------|----------|----------------|---------------|
| type        | string | 是       | 元素类型       | QR_CODE       |
| size        | integer| 是       | 二维码边长像素 | 150           |
| x           | integer| 是       | X坐标          | 300           |
| y           | integer| 是       | Y坐标          | 500           |
| placeholder | string | 是       | 占位符标记     | [[QR_CODE_URL]] |

**用户头像元素 (type="AVATAR"):**
| 参数名 | 类型   | 是否必需 | 说明     | 示例值 |
|--------|--------|----------|----------|--------|
| type   | string | 是       | 元素类型 | AVATAR |
| size   | integer| 是       | 边长像素 | 80     |
| x      | integer| 是       | X坐标    | 50     |
| y      | integer| 是       | Y坐标    | 50     |
| round  | boolean| 否       | 是否圆形 | true   |

**用户昵称元素 (type="NICKNAME"):**
| 参数名   | 类型   | 是否必需 | 说明     | 示例值   |
|----------|--------|----------|----------|----------|
| type     | string | 是       | 元素类型 | NICKNAME |
| x        | integer| 是       | X坐标    | 150      |
| y        | integer| 是       | Y坐标    | 70       |
| fontSize | integer| 是       | 字体大小 | 20       |
| color    | string | 是       | 字体颜色 | #000     |
| font     | string | 否       | 字体名称 | SimHei   |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "templateId": 501,
  "name": "裂变活动推广海报",
  "status": "ACTIVE", // 模板状态 (ACTIVE, INACTIVE)
  "createTime": "2023-10-26T10:00:00Z"
}
```
- **可能返回状态码:** 201 (创建成功), 400 (参数错误), 401, 403, 500

### 2.2 获取海报模板列表

- **接口路径**：`/api/v1/lead-generation/posters/templates`
- **请求方法**：`GET`
- **接口说明**：获取海报模板列表，支持分页和筛选。
- **权限:** `poster:template:view`
- **请求参数 (Query Parameters):**

| 参数名 | 类型    | 是否必需 | 描述         | 示例值 |
|--------|--------|----------|--------------|--------|
| name   | string | 否       | 模板名称关键字 | 活动   |
| status | string | 否       | 模板状态     | ACTIVE |
| page   | integer| 否       | 页码         | 1      |
| size   | integer| 否       | 每页条数     | 10     |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "templateId": 501,
      "name": "裂变活动推广海报",
      "description": "用于分享推广新用户的海报",
      "backgroundImageUrl": "http://oss.example.com/bg.png",
      "status": "ACTIVE",
      "createTime": "2023-10-26T10:00:00Z"
      // elements 列表通常在获取详情时返回
    }
    // ... 更多模板记录
  ],
  "total": 10,
  "size": 10,
  "current": 1,
  "pages": 1
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

### 2.3 获取海报模板详情

- **接口路径**：`/api/v1/lead-generation/posters/templates/{templateId}`
- **请求方法**：`GET`
- **接口说明**：获取指定海报模板的详细信息，包括所有元素配置。
- **权限:** `poster:template:view`
- **请求参数 (Path Parameters):**

| 参数名     | 类型    | 是否必需 | 说明         | 示例值 |
|------------|--------|----------|--------------|--------|
| templateId | integer | 是       | 海报模板ID   | 501    |

- **响应数据 (统一格式 `data` 字段):** 返回包含elements完整信息的模板详情。

```json
{
  "templateId": 501,
  "name": "裂变活动推广海报",
  "description": "用于分享推广新用户的海报",
  "backgroundImageUrl": "http://oss.example.com/bg.png",
  "elements": [ // 海报元素，如文本、图片、二维码
    { "type": "TEXT", "content": "邀请你加入", "x": 100, "y": 200, "fontSize": 24, "color": "#333", "font": "SimHei" },
    { "type": "QR_CODE", "size": 150, "x": 300, "y": 500, "placeholder": "[[QR_CODE_URL]]" },
    { "type": "AVATAR", "size": 80, "x": 50, "y": 50, "round": true },
    { "type": "NICKNAME", "x": 150, "y": 70, "fontSize": 20, "color": "#000" }
  ],
  "status": "ACTIVE",
  "createTime": "2023-10-26T10:00:00Z",
  "updateTime": "2023-10-26T10:30:00Z"
}
```
- **可能返回状态码:** 200, 401, 403, 404 (模板不存在), 500

### 2.4 更新海报模板

- **接口路径**：`/api/v1/lead-generation/posters/templates/{templateId}`
- **请求方法**：`PUT`
- **接口说明**：更新指定海报模板的信息。
- **权限:** `poster:template:update`
- **请求参数 (Path Parameters):**

| 参数名     | 类型    | 是否必需 | 说明         | 示例值 |
|------------|--------|----------|--------------|--------|
| templateId | integer | 是       | 海报模板ID   | 501    |

- **请求体 (Request Body):** 结构与创建模板类似，可以只包含需要更新的字段。

- **响应数据 (统一格式 `data` 字段):** 返回更新后的模板详情。

```json
{
  "templateId": 501,
  "name": "裂变活动推广海报 - V2",
  "status": "ACTIVE",
  "updateTime": "2023-10-26T11:00:00Z"
  // ... 其他更新后的字段
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 422 (数据校验失败), 500

### 2.5 删除海报模板

- **接口路径**：`/api/v1/lead-generation/posters/templates/{templateId}`
- **请求方法**：`DELETE`
- **接口说明**：删除指定的海报模板。
- **权限:** `poster:template:delete`
- **请求参数 (Path Parameters):**

| 参数名     | 类型    | 是否必需 | 说明         | 示例值 |
|------------|--------|----------|--------------|--------|
| templateId | integer | 是       | 海报模板ID   | 501    |

- **响应数据 (统一格式 `data` 字段):** 返回成功或失败信息。

```json
{
  "message": "海报模板删除成功"
}
```
- **可能返回状态码:** 200, 401, 403, 404, 409 (模板正在使用), 500

### 2.6 生成用户专属推广海报

- **接口路径**：`/api/v1/lead-generation/posters/generate`
- **请求方法**：`POST`
- **接口说明**：根据指定海报模板和用户ID，生成包含该用户专属推广二维码的海报图片。
- **权限:** `poster:generate`
- **请求参数 (Request Body):**

| 参数名     | 类型    | 是否必需 | 说明               | 示例值 |
|------------|--------|----------|--------------------|--------|
| templateId | integer | 是       | 使用的海报模板ID   | 501    |
| userId     | integer | 是       | 生成海报的用户ID   | 1001   |
| activityId | integer | 否       | 关联的活动ID (用于追踪) | 101    |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "userPosterId": 1,           // 生成的用户专属海报记录ID
  "posterUrl": "生成的专属海报图片URL (OSS)", // 前端展示用的海报图片URL
  "qrcodeUrl": "海报中的专属二维码URL", // 扫码事件会带上此URL或其中的参数
  "userId": 1001,
  "templateId": 501,
  "createTime": "2023-10-26T14:30:00Z"
}
```
- **可能返回状态码:** 200, 400 (参数错误/模板或用户不存在), 401, 403, 500

### 2.7 处理海报扫码事件推送 (Webhook)

- **接口路径**：`/api/v1/webhook/poster/scan`
- **请求方法**：`POST`
- **接口说明**：接收来自二维码服务或设备端的扫码事件推送。根据二维码携带的参数，识别推广用户（referrer）和扫码用户（scanner），记录扫码日志，并将新注册用户归因到推广用户，触发后续奖励流程。此接口通常无需认证，但需要验证签名。
- **权限:** 无需认证，需验签
- **请求参数 (Request Body):** 具体结构依赖于二维码服务或设备端推送的数据格式，通常包含：

| 参数名            | 类型    | 说明                                   | 示例值 |
|-------------------|---------|----------------------------------------|--------|
| qrcodeContent     | string  | 二维码中包含的原始内容 (如推广链接)    | https://your.domain.com/invite?userId=1001 |
| scannerIdentifier | string  | 扫码用户的唯一标识 (如微信OpenID, UnionID等) | oabc123... |
| scanTime          | string  | 扫码时间 (ISO 8601或其他约定格式)      | 2023-10-26T15:00:00Z |
| scanLocation      | string  | 扫码地点 (如果可获取)                  | 北京   |
| deviceId          | integer | 如果扫码事件来自设备端，设备ID         | 1      |
| ...               | ...     | 其他相关数据                           | ...    |

- **响应数据:** 接收成功通常返回简单的成功标识或符合推送方要求的特定响应。

```json
{
  "code": 200,
  "message": "received"
}
```
- **可能返回状态码:** 200, 400 (数据格式错误/验签失败), 500

### 2.8 获取海报推广效果统计

- **接口路径**：`/api/v1/lead-generation/posters/statistics`
- **请求方法**：`GET`
- **接口说明**：获取海报推广效果统计数据，包括总生成海报数、总扫码数、总新客户数、总归因客户数等。支持按海报模板、推广用户、时间范围进行筛选和分组统计。
- **权限:** `poster:stats:view`
- **请求参数 (Query Parameters):**

| 参数名         | 类型    | 是否必需 | 描述                 | 示例值       |
|----------------|--------|----------|----------------------|--------------|
| templateId     | integer| 否       | 按海报模板ID过滤     | 501          |
| userId         | integer| 否       | 按推广用户ID过滤     | 1001         |
| startTime      | string | 否       | 统计时间范围始 (ISO 8601) | 2023-10-01Z  |
| endTime        | string | 否       | 统计时间范围末 (ISO 8601) | 2023-10-31Z  |
| groupBy        | string | 否       | 分组方式 (TEMPLATE, USER, DAY) | TEMPLATE |
// 其他统计维度...

- **响应数据 (统一格式 `data` 字段):** 返回统计结果，具体结构取决于分组方式。

```json
// 按模板分组统计示例
[
  {
    "templateId": 501,
    "templateName": "裂变活动推广海报",
    "generatedCount": 1000, // 生成海报数
    "scanCount": 800,       // 总扫码数
    "newCustomerCount": 500, // 带来的新客户数
    "attributedCustomerCount": 450 // 成功归因的客户数
  }
  // ... 其他模板的统计数据
]
// 按用户分组或按天分组结构类似，包含相应分组字段和统计指标
```
- **可能返回状态码:** 200, 400, 401, 403, 500

## 3. 数据模型设计

### 3.1 主要数据表

| 表名                 | 说明            | 关键字段                                   | 与其他表关系 |
|---------------------|----------------|-------------------------------------------|------------|
| t_poster_template   | 海报模板表      | id (PK), name, description, background_image_url, elements_json (TEXT), status, create_time, update_time |            |
| t_user_poster       | 用户专属海报表  | id (PK), user_id (FK), template_id (FK), activity_id (FK, 否), poster_url, qrcode_url, create_time | user_id -> t_user/t_customer, template_id -> t_poster_template, activity_id -> t_activity (假设活动表) |
| t_poster_scan_log   | 海报扫码日志表  | id (PK), qrcode_content (TEXT), scanner_customer_id (FK), scan_time, scan_location (TEXT), referrer_user_id (FK, 否), new_customer_id (FK, 否), device_id (FK, 否), create_time | scanner_customer_id -> t_user/t_customer, referrer_user_id -> t_user/t_customer, new_customer_id -> t_user/t_customer, device_id -> t_device |

更新了字段名以更清晰表达（如 scanner_id 改为 scanner_customer_id），增加了与活动表、设备表的潜在关系。

## 4. 服务实现

### 4.1 PosterTemplateService

负责海报模板的增删改查。

```java
@Service
@Slf4j
public class PosterTemplateServiceImpl implements PosterTemplateService {

    @Autowired
    private PosterTemplateRepository templateRepository;

    @Override
    @Transactional
    public PosterTemplateVO createTemplate(PosterTemplateDTO dto) {
        log.info("Creating poster template: {}", dto.getName());

        // TODO: 1. 校验模板参数的合法性 (elements结构)
        validateTemplateElements(dto.getElements());

        // 2. 保存模板信息
        PosterTemplate template = new PosterTemplate();
        template.setName(dto.getName());
        template.setDescription(dto.getDescription());
        template.setBackgroundImageUrl(dto.backgroundImageUrl());
        // TODO: 将elements列表序列化为JSON存储
        template.setElementsJson(serializeElements(dto.getElements()));
        template.setStatus(TemplateStatus.ACTIVE);
        template.setCreateTime(new Date());

        PosterTemplate savedTemplate = templateRepository.save(template);

        return buildTemplateVO(savedTemplate);
    }

    private String serializeElements(List<PosterElementDTO> elements) {
         // 实现elements序列化，使用Jackson或其他库
         try {
             return new ObjectMapper().writeValueAsString(elements);
         } catch (JsonProcessingException e) {
             throw new RuntimeException("Failed to serialize poster elements", e);
         }
    }

    private void validateTemplateElements(List<PosterElementDTO> elements) {
         // 校验elements结构，确保必要字段存在，坐标、大小等合理
         if (elements == null || elements.isEmpty()) {
              throw new IllegalArgumentException("Poster elements cannot be empty");
         }
         boolean hasQrCode = false;
         for (PosterElementDTO element : elements) {
              // TODO: 更详细的校验逻辑，检查type, x, y, size/fontSize等
              if ("QR_CODE".equals(element.getType())) {
                   hasQrCode = true;
              }
         }
         if (!hasQrCode) {
              throw new IllegalArgumentException("Poster template must contain a QR_CODE element");
         }
    }

    // TODO: 实现获取模板列表、详情、更新、删除等方法
    // getTemplateList(TemplateQuery query): 分页查询模板列表
    // getTemplateDetail(Long templateId): 获取模板详情
    // updateTemplate(Long templateId, PosterTemplateDTO dto): 更新模板
    // deleteTemplate(Long templateId): 删除模板 (检查是否有用户海报关联)
}
```

### 4.2 UserPosterService

负责生成用户专属海报，包括生成专属二维码和海报图片合成。

```java
@Service
@Slf4j
public class UserPosterServiceImpl implements UserPosterService {

    @Autowired
    private PosterTemplateRepository templateRepository;

    @Autowired
    private UserPosterRepository userPosterRepository;

    @Autowired
    private QrCodeService qrCodeService; // 二维码生成服务

    @Autowired
    private ImageService imageService; // 图片处理服务，用于海报合成

    @Autowired
    private CustomerService customerService; // 获取用户信息

    @Override
    @Transactional
    public UserPosterVO generateUserPoster(Long templateId, Long userId) {
        log.info("Generating user poster for user {} with template {}", userId, templateId);

        PosterTemplate template = templateRepository.findById(templateId)
                .orElseThrow(() -> new PosterTemplateNotFoundException("Poster template not found: " + templateId));

        Customer user = customerService.getCustomerById(userId)
                 .orElseThrow(() -> new CustomerNotFoundException("User not found: " + userId));

        // 1. 生成用户专属推广二维码 (二维码中包含用户ID或其他标识，用于扫码后归因)
        // TODO: 二维码内容应包含足够信息，如活动ID、推广用户ID等，可以是推广链接带参数
        String qrcodeContent = "https://your.domain.com/invite?userId=" + userId + "&templateId=" + templateId; // + "&activityId=" + activityId
        String qrcodeUrl = qrCodeService.generateQrCode(qrcodeContent); // 调用二维码生成服务

        // 2. 合成海报图片
        // TODO: 将模板元素、背景图、用户头像昵称、生成的二维码等合成为一张图片
        // 需要传递完整的模板对象（包含elements），用户对象和二维码URL给图片处理服务
        String posterUrl = imageService.composePoster(template, user, qrcodeUrl); // 调用图片处理服务

        // 3. 保存用户专属海报记录
        UserPoster userPoster = new UserPoster();
        userPoster.setUserId(userId);
        userPoster.setTemplateId(templateId);
        // userPoster.setActivityId(activityId); // 如果有活动关联
        userPoster.setPosterUrl(posterUrl);
        userPoster.setQrcodeUrl(qrcodeUrl); // 保存二维码URL用于追踪
        userPoster.setCreateTime(new Date());

        UserPoster savedUserPoster = userPosterRepository.save(userPoster);

        log.info("User poster generated: {}", savedUserPoster.getPosterUrl());
        return buildUserPosterVO(savedUserPoster);
    }

    // TODO: 实现获取用户专属海报等方法 (支持按用户ID、模板ID查询)
    // getUserPosterList(UserPosterQuery query): 分页查询用户专属海报列表
    // getUserPosterDetail(Long userPosterId): 获取用户专属海报详情
}
```

### 4.3 PosterScanService

负责接收和处理海报扫码事件，记录扫码日志，并将新用户归因到推广者。

```java
@Service
@Slf4j
public class PosterScanServiceImpl implements PosterScanService {

    @Autowired
    private PosterScanLogRepository scanLogRepository;

    @Autowired
    private UserPosterRepository userPosterRepository;

    @Autowired
    private CustomerService customerService; // 客户服务，用于识别新老用户和归因

    @Override
    @Transactional
    public void handleScanEvent(PosterScanEvent event) {
        log.info("Handling poster scan event for qrcode: {}", event.getQrcodeUrl());

        // TODO: 1. 解析二维码内容，提取推广用户ID、模板ID、活动ID等信息
        // 二维码内容示例: https://your.domain.com/invite?userId=1001&templateId=501&activityId=101
        Map<String, String> qrcodeParams = parseQrCodeContent(event.getQrcodeContent()); // event现在应该包含qrcodeContent
        Long referrerUserId = Long.parseLong(qrcodeParams.get("userId")); // 推广用户ID
        Long templateId = Long.parseLong(qrcodeParams.get("templateId")); // 模板ID
        Long activityId = qrcodeParams.containsKey("activityId") ? Long.parseLong(qrcodeParams.get("activityId")) : null; // 活动ID

        // 校验 referrerUserId 是否存在
        Customer referrerUser = customerService.getCustomerById(referrerUserId).orElse(null);
        if (referrerUser == null) {
            log.warn("Referrer user not found for ID: {}", referrerUserId);
            // TODO: 记录无法归因的扫码事件
            referrerUserId = null; // 清空推广用户ID，表示无法归因
        }


        // 2. 识别扫码用户 (可能是新用户或已注册用户)
        // TODO: 根据event中的扫码用户标识（如微信OpenID, UnionID等）查找或创建客户
        // findOrCreateCustomerFromScan 方法应该处理新用户的创建和老用户的查找
        Customer scannerCustomer = customerService.findOrCreateCustomerFromScan(event.getScannerIdentifier(), event.getScanSource(), referrerUserId, activityId); // 传递来源、推广人和活动信息

        // 3. 记录扫码日志
        PosterScanLog scanLog = new PosterScanLog();
        scanLog.setQrcodeContent(event.getQrcodeContent()); // 记录原始二维码内容
        scanLog.setScannerCustomerId(scannerCustomer.getId());
        scanLog.setScanTime(new Date()); // event应包含扫码时间
        scanLog.setScanLocation(event.getScanLocation()); // 如果可获取
        scanLog.setReferrerUserId(referrerUserId);
        // 判断是否为新客户的标准可能需要调整，例如检查 createTime 是否接近 scanTime
        scanLog.setNewCustomerId(scannerCustomer.getCreateTime().getTime() >= (event.getScanTime().getTime() - 5000) ? scannerCustomer.getId() : null); // 假设5秒内创建算新客户
        scanLog.setTemplateId(templateId);
        scanLog.setActivityId(activityId);
        scanLog.setDeviceId(event.getDeviceId()); // 如果来自设备端

        scanLogRepository.save(scanLog);

        // 4. 如果是新用户且成功归因，触发新用户注册后的后续流程 (如给推广者发奖励)
        if (scanLog.getNewCustomerId() != null && scanLog.getReferrerUserId() != null) {
            log.info("New customer {} registered via poster scan, referred by {}", scanLog.getNewCustomerId(), scanLog.getReferrerUserId());
            // TODO: 触发奖励机制或其他裂变成功后的业务逻辑
            // rewardService.rewardReferrer(scanLog.getReferrerUserId(), scanLog.getNewCustomerId(), scanLog.getActivityId());
        }
    }

    private Map<String, String> parseQrCodeContent(String qrcodeContent) {
         // 解析二维码内容，提取参数 (例如解析URL的query string)
         return null; // TODO: 实现解析逻辑
    }

    // TODO: 实现获取统计数据的方法 (支持筛选、分组、分页)
    // getScanStatistics(ScanStatsQuery query): 获取扫码统计数据
    // getScanLogList(ScanLogQuery query): 获取扫码日志列表
}
```

### 4.4 QrCodeService

负责生成二维码图片并上传到文件存储。

```java
@Service
@Slf4j
public class QrCodeServiceImpl implements QrCodeService {

    @Autowired
    private FileStorageService fileStorageService; // 文件存储服务，如OSS

    @Override
    public String generateQrCode(String content) {
        log.info("Generating QR code for content: {}", content);
        // TODO: 使用二维码生成库生成二维码图片（字节数组或文件）
        byte[] qrCodeImageBytes = generateQrCodeImage(content);

        // TODO: 将图片上传到文件存储服务
        // 文件路径可以包含一些标识，如用户ID、模板ID等，方便管理和查找
        String fileKey = String.format("qrcodes/user_%d/template_%d/%s.png", userId, templateId, UUID.randomUUID().toString()); // TODO: 获取userId, templateId
        String imageUrl = fileStorageService.uploadFile(fileKey, qrCodeImageBytes);

        log.info("QR code generated and uploaded: {}", imageUrl);
        return imageUrl;
    }

    private byte[] generateQrCodeImage(String content) {
        // 使用zxing或其他库生成二维码图片字节数组
        // 需要考虑二维码容错率、编码格式等参数
        return null; // TODO: 实现生成逻辑
    }
}
```

### 4.5 ImageService

负责海报图片的合成。

```java
@Service
@Slf4j
public class ImageServiceImpl implements ImageService {

    @Autowired
    private FileStorageService fileStorageService; // 文件存储服务

    @Autowired
    private CustomerService customerService; // 获取用户头像等信息

    @Override
    public String composePoster(PosterTemplate template, Customer user, String qrcodeUrl) {
        log.info("Composing poster for user {} with template {}", user.getId(), template.getId());

        // TODO: 1. 下载背景图、用户头像（如果模板需要）、二维码图片
        // 从template和user对象获取URL，调用fileStorageService下载为本地文件或字节数组
        byte[] backgroundImageBytes = fileStorageService.downloadFile(template.backgroundImageUrl());
        byte[] avatarImageBytes = null;
        if (template.getElements().stream().anyMatch(e -> "AVATAR".equals(e.getType())) && user.getAvatarUrl() != null) {
             avatarImageBytes = fileStorageService.downloadFile(user.getAvatarUrl());
        }
        byte[] qrcodeImageBytes = fileStorageService.downloadFile(qrcodeUrl);

        // TODO: 2. 根据模板定义的元素位置和样式，将文本、图片、二维码绘制到背景图上
        // 使用Java Graphics2D 或其他图片处理库 (如 ImageIO, Graphics2D, TwelveMonkeys, imgscalr等)
        // 需要处理图片缩放、裁剪、文字绘制（颜色、字体、大小）、二维码叠加等
        byte[] composedImageBytes = composeImage(backgroundImageBytes, avatarImageBytes, qrcodeImageBytes, template.getElements(), user); // TODO: 实现合成逻辑，传递必要参数

        // TODO: 3. 将合成后的图片上传到文件存储服务
        // 文件路径可以包含用户ID、模板ID等信息
        String fileKey = String.format("posters/user_%d/template_%d/%s.png", user.getId(), template.getId(), UUID.randomUUID().toString());
        String posterUrl = fileStorageService.uploadFile(fileKey, composedImageBytes);

        log.info("Poster composed and uploaded: {}", posterUrl);
        return posterUrl;
    }

    private byte[] composeImage(byte[] backgroundImageBytes, byte[] avatarImageBytes, byte[] qrcodeImageBytes, List<PosterElementDTO> elements, Customer user) {
        // 实现图片合成逻辑，根据elements绘制内容
        // 例如：
        // 1. 读取背景图
        // 2. 创建Graphics2D对象
        // 3. 遍历elements:
        //    - 如果是TEXT，绘制文本，考虑换行、字体、颜色、大小、位置
        //    - 如果是IMAGE/AVATAR，绘制图片，考虑缩放、裁剪、圆角（头像）、位置
        //    - 如果是QR_CODE，绘制二维码，考虑缩放、位置
        // 4. 释放Graphics2D资源
        // 5. 将合成后的BufferedImage转为字节数组
        return null; // 返回合成后的图片字节数组
    }
}
```

## 5. 流程图

```mermaid
graph TD
    A[用户在前端创建海报模板] --> B[调用后端创建模板接口]
    B --> C[后端保存模板信息]

    D[用户在前端生成专属海报] --> E[调用后端生成海报接口]
    E --> F[后端查询海报模板和用户信息]
    F --> G[后端调用QrCodeService生成用户专属二维码]
    G --> H[后端调用ImageService合成海报图片]
    H --> I[后端保存用户专属海报记录]
    I --> J[后端返回海报图片URL给前端]

    K[用户分享专属海报]
    L[新用户扫码海报二维码] --> M[二维码服务/设备端发送扫码事件到存客宝后端Webhook]
    M --> N[后端Webhook接收/PosterScanService]
    N --> O[解析二维码内容/识别推广用户]
    O --> P[识别扫码用户/查找或创建客户]
    P --> Q[记录扫码日志]
    Q --> R{是否为新用户且成功归因}
    R -- Yes --> S[触发新客户注册后流程/奖励推广者]
```

## 6. 异常处理

- `PosterTemplateNotFoundException`: 海报模板不存在
- `UserNotFoundException`: 用户不存在 (应改为 CustomerNotFoundException)
- `QrCodeGenerationException`: 二维码生成失败
- `ImageCompositionException`: 海报图片合成失败
- `ScanEventHandlingException`: 扫码事件处理异常
- `InvalidQrCodeContentException`: 二维码内容格式无效
- `WebhookSignatureException`: Webhook签名验证失败

## 7. 定时任务

- 可能需要定时清理过期的二维码或用户专属海报（根据业务需求）。
- 定期统计和更新海报推广效果数据（如果统计接口是实时计算，则无需此定时任务）。

## 8. 与前端的交互流程

1. 前端提供海报模板创建和管理界面，用户通过API (`/api/v1/lead-generation/posters/templates`) 进行模板的增删改查。
2. 用户选择一个海报模板，点击生成专属海报，前端调用"生成用户专属推广海报"接口 (`/api/v1/lead-generation/posters/generate`)，传递模板ID和当前用户ID。
3. 后端生成海报图片并上传，返回图片URL给前端。
4. 前端展示专属海报图片，供用户下载或分享。
5. 新用户扫描海报上的二维码时，触发扫码事件，通过Webhook (`/api/v1/webhook/poster/scan`) 发送到后端。
6. 后端处理扫码事件，记录日志 (`t_poster_scan_log`)，识别新客户并归因到推广者，触发后续业务逻辑（如调用奖励服务）。
7. 前端调用"获取推广效果统计"接口 (`/api/v1/lead-generation/posters/statistics`)，展示海报的推广效果数据，支持按模板、用户、时间等维度查询。

---

#### 开发注意事项和实现要点

1.  **二维码内容设计:**
    - 二维码中应包含足够的信息用于扫码后的归因，例如推广用户的唯一标识 (userId)、海报模板ID、活动ID等。
    - 可以设计一个专门的短链服务或在二维码中直接编码包含这些参数的推广落地页URL。
    - 推广落地页（前端页面）在用户访问时，需要解析URL参数，将推广信息（如referrerUserId, activityId）记录下来，并在用户注册或成为客户时传递给后端。
2.  **扫码事件接收和处理:**
    - 扫码事件可能来自不同的渠道（例如：直接扫描公众号/小程序码、或者设备控制服务捕获的扫码事件）。后端Webhook接口需要能够处理不同来源和格式的扫码数据。
    - Webhook接口必须保证高可用性和快速响应，实际的扫码处理逻辑（解析二维码、识别用户、记录日志、触发归因）应设计为异步处理（例如放入消息队列）。
    - 扫码事件可能重复推送，需要实现幂等性处理，防止重复记录日志或重复触发奖励。
    - Webhook接口需要进行严格的签名验证，确保请求的合法性。
3.  **用户识别与归因:**
    - 在处理扫码事件时，根据扫码用户的标识（如微信OpenID, UnionID）在现有客户库中查找。如果是新标识，则创建新的客户记录。
    - 归因逻辑需要准确：将新创建的客户关联到扫描海报的推广用户 (`referrer_user_id`)。
    - 需要考虑边缘情况：例如已注册用户扫描海报是否记录日志？是否更新最后互动时间？
    - `customerService.findOrCreateCustomerFromScan` 方法需要能够根据扫码事件提供的标识和推广信息来查找或创建客户。
4.  **图片合成服务 (ImageService):**
    - 图片合成是核心且可能耗时的操作。
    - 需要选择合适的图片处理库，并考虑性能优化。
    - 需要处理各种海报元素类型的绘制（文本、图片、二维码），包括位置、大小、颜色、字体、图层顺序等。
    - 处理用户头像时，可能需要进行裁剪和圆角处理。
    - 合成后的图片需要上传到文件存储服务（如OSS）。
5.  **二维码生成服务 (QrCodeService):**
    - 需要选择可靠的二维码生成库。
    - 生成的二维码图片需要上传到文件存储服务。
    - 考虑生成的二维码图片的存储路径命名规则，方便查找和管理。
6.  **文件存储服务 (FileStorageService):**
    - 海报背景图、用户头像、生成的二维码图片和合成后的海报图片都需要存储在文件服务中（如阿里云OSS、腾讯云COS等）。
    - 后端需要封装文件上传、下载、删除等操作。
7.  **数据模型:**
    - `t_poster_template` 表用于存储海报模板定义，elements字段使用JSON存储复杂结构。
    - `t_user_poster` 表关联用户和模板，存储生成的专属海报URL和二维码URL，用于追踪和后续查找。
    - `t_poster_scan_log` 表记录每一次扫码事件，是统计和归因的基础。需要记录扫码用户、推广用户、时间、二维码内容等关键信息。
    - 考虑增加活动表 (`t_activity`) 来关联海报和活动，便于按活动进行统计和管理。
8.  **统计接口:**
    - 统计接口 (`/api/v1/lead-generation/posters/statistics`) 需要能够根据 `t_poster_scan_log` 表的数据进行各种维度的统计和分组。
    - 可以考虑使用数据库的聚合函数进行实时统计，或者通过定时任务预计算统计结果存储到专门的统计表中，以提高查询性能。
9.  **错误处理:**
    - 遵循 `./前后端接口约定.md` 中的错误处理规范。
    - 捕获并处理模板查找失败、用户查找失败、二维码生成失败、图片合成失败、文件上传下载失败、扫码事件处理失败等各种异常。
    - Webhook 接口的错误处理需要特殊考虑，通常返回 200 表示接收成功，实际业务处理失败通过日志和告警监控。
10. **日志记录:**
    - 记录所有关键操作日志，包括：
        - 海报模板的创建、更新、删除。
        - 用户专属海报的生成请求和结果。
        - 二维码生成请求和结果、文件上传结果。
        - 图片合成请求和结果、文件上传结果。
        - 扫码事件的接收、处理过程、识别出的推广用户和扫码用户、归因结果、触发的后续业务（如奖励）。
        - 统计查询日志。
        - 所有异常日志。
    - 日志应包含时间、相关ID（模板ID、用户ID、海报记录ID、扫码日志ID）、操作类型、操作人（如果适用）、操作结果、错误信息等信息。
11. **安全性:**
    - 所有面向前端的接口必须进行认证授权校验。
    - Webhook 接口需要进行签名验证等安全措施。
    - 文件存储服务的访问控制需要严格限制。
    - 敏感信息存储需要脱敏或加密。
12. **性能与并发:**
    - 图片合成和二维码生成可能耗时，应设计为异步任务，避免阻塞主线程。
    - Webhook 接口可能面临高并发的扫码事件，需要设计为快速响应并将处理逻辑异步化（消息队列）。
    - 优化数据库查询性能，特别是统计相关的查询。

--- 

---

## 文件 10: 后端-场景获客-接口开发文档.md

*文件大小：20.45 KB*

---

# 场景化获客模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
场景化获客模块是企业私域流量运营和客户关系管理 (CRM) 的前端入口，旨在通过多样化的内外部渠道和互动场景，高效捕获潜在客户线索，并将其转化为可跟进、可培育的客户资产。本模块是连接公域流量与私域运营的关键桥梁。

### 1.2 核心价值
- **拓宽获客渠道**: 支持线上线下多种获客方式，最大化线索来源。
- **提升线索质量**: 通过场景化互动和初步筛选，提高线索的有效性和意向度。
- **自动化处理**: 实现线索的自动记录、分类、打标和分配，提升运营效率。
- **数据驱动决策**: 统一收集和分析各渠道获客数据，为优化获客策略提供依据。
- **无缝客户旅程**: 将新获取的线索顺畅导入CRM或销售流程，开始客户培育和转化。

### 1.3 设计目标
- **多场景适配**: 灵活支持并可快速扩展新的获客场景（如电话、订单、社交平台、内容互动、线下活动、API对接等）。
- **配置驱动**: 核心业务逻辑（如线索处理规则、标签规则、分配规则）应高度可配置。
- **智能化**: 具备一定的智能处理能力，如自动客户识别、智能打标、智能分配。
- **高可用与可伸缩**: 保证在高并发线索涌入时系统的稳定性和处理能力。
- **数据准确与一致**: 确保线索数据和客户信息的准确性，以及在各系统间的一致性。
- **安全性**: 保护用户数据和接入凭证的安全，防止数据泄露和未授权访问。
- **易集成性**: 提供标准化的接口，方便与内部其他系统（CRM、营销自动化、数据分析平台）和外部第三方应用集成。

## 二、模块概述

本模块负责统一管理和处理来自各种内外部渠道的潜在客户线索。它包括：获客场景的定义与配置，线索数据的接收与标准化，潜在客户与已有客户的识别与关联，基于规则的自动标签，以及将线索智能分配给相应的销售团队或处理流程。此外，模块还需提供各场景和渠道获客效果的统计分析能力。

## 三、核心概念

- **线索 (Lead)**: 代表一个潜在的销售机会或一个对产品/服务表现出兴趣的个体/组织信息。通常包含联系方式和初步需求信息。
- **客户 (Customer/Contact/Account)**: 已建立联系或已成交的个体/组织。新线索可能转化为新客户，或关联到已有客户。
- **获客场景 (Acquisition Scene)**: 线索产生的具体业务情境或互动方式。例如：客服电话呼入、在线表单提交、电商平台订单同步、社交媒体广告互动、内容下载、扫码关注、会议注册、API导入等。
- **渠道 (Channel)**: 线索的来源媒介或平台。例如：官方网站、搜索引擎、微信公众号、抖音、小红书、合作伙伴、线下门店等。
- **场景配置 (Scene Configuration)**: 针对特定获客场景的参数设置，包括数据解析规则、处理流程、自动标签规则、分配规则等。
- **标签 (Tag)**: 用于描述线索或客户特征的关键词或分类。可以是手动添加或自动生成。
- **分配规则 (Assignment Rule)**: 将线索分配给特定用户、团队或处理队列的逻辑。可以是轮询、随机、基于权重、基于地理区域、基于线索属性等。
- **自动化处理 (Automation)**: 在线索进入系统后，根据预设规则自动执行的一系列操作，如数据清洗、信息丰富、打标签、分配、发送初步响应等。
- **Webhook/回调**: 外部系统在产生符合条件的线索时，主动向本模块推送数据的机制。

## 四、核心数据实体/模型

1.  **线索 (Lead)**
    *   `lead_id` (主键): 线索唯一标识符。
    *   `source_channel_id` (外键, 可选): 来源渠道ID。
    *   `acquisition_scene_id` (外键, 可选): 关联的获客场景配置ID。
    *   `external_lead_id` (字符串, 可选): 外部系统中的线索ID。
    *   `status` (枚举: NEW, QUALIFIED, DISQUALIFIED, ASSIGNED, PROCESSING, CONVERTED, CLOSED): 线索状态。
    *   `lead_data` (JSON/结构化数据, 必填): 线索的核心信息，通常包含联系方式（电话、邮箱、社交账号）、姓名、公司、需求描述、来源URL等。具体字段可能因场景而异。
    *   `raw_data` (文本/JSON, 可选): 接收到的原始线索数据，用于追溯和调试。
    *   `assigned_to_user_id` (外键, 可选): 被分配处理的用户ID。
    *   `assigned_to_team_id` (外键, 可选): 被分配处理的团队ID。
    *   `assignment_time` (时间戳, 可选): 分配时间。
    *   `tags` (数组/关联表, 可选): 线索关联的标签列表。
    *   `notes` (文本, 可选): 跟进备注。
    *   `created_at` (时间戳): 线索创建时间。
    *   `updated_at` (时间戳): 线索最后更新时间。
    *   `related_customer_id` (外键, 可选): 关联到的客户ID（如果已识别或转化）。

2.  **客户 (Customer)** (通常由CRM模块核心管理，此处为简化关联模型)
    *   `customer_id` (主键): 客户唯一标识符。
    *   `name` (字符串, 可选): 客户名称。
    *   `contact_info` (JSON): 主要联系方式（电话、邮箱等）。
    *   `tags` (数组/关联表, 可选): 客户标签。
    *   `created_at`, `updated_at` (时间戳)。

3.  **获客场景配置 (AcquisitionSceneConfiguration)**
    *   `scene_config_id` (主键): 场景配置唯一标识符。
    *   `scene_name` (字符串, 必填): 场景名称 (如 "官网产品咨询表单", "抖音广告线索")。
    *   `scene_type` (枚举, 必填): 场景类型 (e.g., PHONE_CALL, WEB_FORM, ORDER_SYNC, SOCIAL_MEDIA_LEAD, API_IMPORT, QR_CODE_SCAN)。
    *   `is_enabled` (布尔, 默认: true): 此场景是否启用。
    *   `source_channel_default_id` (外键, 可选): 此场景默认关联的渠道ID。
    *   `scene_specific_params` (JSON, 可选): 特定场景所需的配置参数（如表单ID、API端点密钥、Webhook验证Token、监控的电话号码、订单平台标识等）。
    *   `data_mapping_rules` (JSON, 可选): 定义如何从原始输入数据映射到标准线索字段的规则。
    *   `auto_tagging_rules` (JSON, 可选): 自动为通过此场景进入的线索打标签的规则列表。每个规则包含条件和要应用的标签。
    *   `assignment_rules` (JSON, 可选): 线索分配规则配置（如轮询用户列表、按区域分配等）。
    *   `auto_response_config` (JSON, 可选): 自动回复配置（如邮件/短信模板ID）。
    *   `deduplication_strategy` (枚举, 可选): 线索去重策略 (e.g., NO_CHECK, BY_PHONE, BY_EMAIL, BY_PHONE_OR_EMAIL)。
    *   `created_at`, `updated_at` (时间戳)。

4.  **渠道定义 (ChannelDefinition)**
    *   `channel_id` (主键): 渠道唯一标识符。
    *   `name` (字符串, 必填): 渠道名称 (如 "百度推广", "微信自然流量", "销售自开拓")。
    *   `channel_type` (枚举, 可选): 渠道类型 (如 PAID_SEARCH, ORGANIC_SOCIAL, REFERRAL, OFFLINE_EVENT)。
    *   `is_active` (布尔, 默认: true): 渠道是否启用。

5.  **标签定义 (TagDefinition)** (可复用通用标签模块的实体)
    *   `tag_id` (主键): 标签唯一标识符。
    *   `name` (字符串, 必填, 唯一): 标签名称。
    *   `tag_group` (字符串, 可选): 标签分组。

6.  **线索处理/分配日志 (LeadProcessingLog / LeadAssignmentLog)**
    *   记录线索被处理（如打标、分配）的详细历史。

## 五、功能模块划分

1.  **多渠道线索接入模块**
    *   **API接入**: 提供标准化的RESTful API接口，供外部系统（如网站表单后端、第三方工具）主动推送线索数据。
    *   **Webhook处理器**: 接收并验证来自各类平台（如社交媒体广告、在线表单工具、支付网关订单通知）的Webhook/回调请求。
    *   **特定场景适配器**: (概念上) 为不同的获客场景（如电话系统集成、邮件抓取、订单数据同步任务）提供数据接入和初步解析逻辑。
    *   **文件导入**: 支持通过CSV/Excel等格式批量导入线索。
2.  **线索标准化与丰富化模块**
    *   根据场景配置中的`data_mapping_rules`，将不同来源和格式的原始数据转换为统一的内部线索数据结构。
    *   (可选) 数据清洗：格式化电话号码、邮箱，修正常见错误。
    *   (可选) 信息丰富：通过IP地址查询地理位置，通过公司名称查询企业信息等（可能需要集成第三方数据服务）。
3.  **客户识别与关联模块**
    *   根据线索中的关键信息（如手机号、邮箱、公司名、社交账号等）和预设的`deduplication_strategy`，在现有客户库中查找是否已存在该潜在客户。
    *   如果匹配到已有客户，则将新线索与该客户关联，并可能触发更新客户信息或通知客户负责人。
    *   如果未匹配到，则可选择创建新的潜在客户记录。
4.  **自动化标签模块**
    *   根据场景配置中的`auto_tagging_rules`以及线索内容，自动为线索打上相应的标签（如意向度、产品偏好、来源场景等）。
    *   规则可以基于关键词、数值范围、来源等条件。
5.  **线索智能分配模块**
    *   根据场景配置中的`assignment_rules`，将符合条件的线索自动分配给合适的销售人员、销售团队或处理队列。
    *   支持多种分配策略：轮询、随机、按负载、按区域、按技能标签、按线索价值等。
    *   记录分配历史。
6.  **场景与规则配置管理模块**
    *   提供UI界面或API，供管理员创建和管理获客场景、数据映射规则、标签规则、分配规则等。
    *   配置版本控制与审批流程 (可选)。
7.  **线索处理与跟进支持模块**
    *   提供API供CRM或销售工具查询、更新线索状态和跟进记录。
    *   (可选) 触发自动化的初步响应（如发送欢迎邮件/短信，创建任务提醒）。
8.  **数据统计与分析模块**
    *   统计各获客场景、渠道的线索数量、转化率、成本等关键指标。
    *   分析线索质量和分配效率。
    *   提供报表和API接口供数据分析使用。

## 六、API接口设计指导原则

### 6.1 通用原则
- **RESTful设计**: 使用标准的HTTP方法 (POST, GET, PUT, DELETE)。
- **统一数据格式**: 请求和响应主体主要使用JSON。
- **版本控制**: API应进行版本化 (如 `/api/v1/...`)。
- **认证与授权**: 所有接口（特别是写操作和配置接口）都必须经过严格的认证和授权。
- **幂等性**: 对于创建或可能重复调用的接口（如Webhook接收），需考虑幂等性设计。
- **标准化响应**: 包括HTTP状态码、统一的成功/错误响应结构（包含错误码、消息）。
- **分页与筛选**: 对于列表查询接口，必须支持分页、排序和多条件筛选。
- **异步处理提示**: 对于耗时较长的操作（如批量导入），应采用异步处理，并立即返回受理状态，后续通过回调或查询接口获取结果。

### 6.2 核心API示例 (概念性)

1.  **接收线索 (通用入口)**
    *   **路径**: `POST /leads/ingestions`
    *   **说明**: 接收来自各种渠道的线索，通过参数或请求头指定场景类型或场景配置ID。
    *   **请求体**: 包含原始线索数据，结构可能因场景而异，但应有可识别场景的字段。
        ```json
        {
          "scene_type": "WEB_FORM", // 或 scene_config_id: "config_xyz"
          "form_id": "contact_us_form_v1",
          "submission_data": {
            "name": "张三",
            "email": "zhangsan@example.com",
            "phone": "13800138000",
            "company": "某某公司",
            "message": "对产品A感兴趣，希望了解详情。"
          },
          "meta": {
            "ip_address": "192.168.1.100",
            "user_agent": "Mozilla/5.0...",
            "submission_url": "https://example.com/contact"
    }
}
```
    *   **响应**: 受理成功 (HTTP 202 Accepted) 或校验失败 (HTTP 400 Bad Request)。

2.  **特定场景Webhook接收** (为每个需要Webhook的场景类型定义独立端点)
    *   **路径**: `POST /webhooks/{scene_type}` (e.g., `/webhooks/douyin_leads`, `/webhooks/order_notifications`)
    *   **说明**: 接收特定第三方平台推送的数据。需实现签名验证和数据解析适配。
    *   **请求体**: 由第三方平台定义。
    *   **响应**: 遵循第三方平台要求的响应格式。

3.  **查询线索列表**
    *   **路径**: `GET /leads`
    *   **参数**: `status`, `channel_id`, `scene_config_id`, `assigned_to_user_id`, `start_date`, `end_date`, `tags_contain_any`, `page`, `size`, `sort_by`, `sort_order`等。
    *   **响应**: 分页的线索列表。

4.  **获取线索详情**
    *   **路径**: `GET /leads/{lead_id}`

5.  **更新线索信息/状态**
    *   **路径**: `PUT /leads/{lead_id}`
    *   **请求体**: 包含要更新的字段 (如状态、备注、关联客户ID)。

6.  **手动分配/重新分配线索**
    *   **路径**: `POST /leads/{lead_id}/assign`
    *   **请求体**: `{"user_id": "user_abc"}` 或 `{"team_id": "team_xyz"}`。

7.  **场景配置管理API**
    *   `POST /scenes/configurations`: 创建新的场景配置。
    *   `GET /scenes/configurations`: 获取场景配置列表。
    *   `GET /scenes/configurations/{scene_config_id}`: 获取特定场景配置。
    *   `PUT /scenes/configurations/{scene_config_id}`: 更新场景配置。
    *   `DELETE /scenes/configurations/{scene_config_id}`: 删除场景配置。

## 七、关键业务流程示例

### 1. 处理网站表单提交的线索
    1.  用户在网站填写并提交咨询表单。
    2.  网站后端服务收集表单数据，并调用场景获客模块的 `POST /leads/ingestions` 接口，指定 `scene_type="WEB_FORM"` 和表单相关信息。
    3.  **线索接入与标准化**: 模块接收数据，根据预设的"官网表单"场景配置，将表单字段映射到标准线索字段。
    4.  **客户识别**: 使用线索中的邮箱和手机号，在客户库中查找是否已存在该客户。
        *   若存在，则将此线索与老客户关联。
        *   若不存在，标记为新潜客。
    5.  **自动打标**: 根据表单内容（如咨询的产品类别、问题关键词），应用标签规则，为线索打上"产品A意向"、"价格咨询"等标签。
    6.  **智能分配**: 根据标签（如产品线）和预设的分配规则（如按产品线分配给不同销售组），将线索分配给相应销售人员。
    7.  **通知与后续**: (可选) 向被分配的销售发送新线索提醒；(可选) 向提交表单的用户发送自动感谢邮件。
    8.  记录所有处理步骤到日志。

### 2. 通过订单同步获客
    1.  配置一个"电商平台订单同步"场景 (`scene_type="ORDER_SYNC"`)。
        *   `scene_specific_params`包含电商平台API的凭证、查询订单的端点等。
        *   `data_mapping_rules`定义如何从订单数据提取客户信息（姓名、电话、地址）和购买信息。
        *   `auto_tagging_rules`可基于购买商品、金额等打标（如"已购用户"、"高价值订单"）。
        *   `assignment_rules`可将新客户分配给客服或特定销售跟进。
    2.  定时任务或消息触发，调用电商平台API拉取新订单数据。
    3.  对于每条新订单：
        a.  适配器解析订单数据。
        b.  调用 `POST /leads/ingestions` 接口，传入解析后的订单数据和场景信息。
        c.  后续流程同表单提交线索，进行客户识别、打标、分配。

### 3. 电话呼入线索处理
    1.  集成电话系统 (CTI)。当有电话呼入分配给销售座席的号码时，电话系统将来电信息（主叫号码、被叫号码、呼叫时间等）通过API实时推送给场景获客模块（或本模块主动轮询CTI接口）。
    2.  配置一个"销售电话呼入"场景 (`scene_type="PHONE_CALL"`)。
    3.  模块接收到来电信息，立即创建一条线索，状态为"通话中"或"待处理"，并尝试根据主叫号码关联已有客户或销售人员（如果可以识别）。
    4.  通话结束后，销售人员在CRM或对接的工具中补充通话摘要、意向度等信息，这些信息可同步更新到线索记录中。
    5.  根据通话结果和补充信息，触发后续的打标和分配（如果初次分配不明确或需调整）。

## 八、技术考量与开发注意事项

1.  **场景适配器设计**: 针对不同获客场景（特别是需要主动拉取数据或有复杂交互的场景，如社交媒体、电话系统），设计可插拔的适配器/插件机制，方便扩展。
2.  **线索去重与合并逻辑**: 设计灵活的去重规则（可按场景配置），并考虑在发现重复线索时的数据合并策略。
3.  **规则引擎**: 对于复杂的自动打标和分配规则，可以考虑引入轻量级规则引擎，或设计易于扩展的规则判断逻辑。
4.  **与核心系统的集成**: 
    *   **CRM集成**: 与CRM系统紧密双向同步线索和客户数据、跟进状态。
    *   **用户中心集成**: 识别和关联平台已有注册用户。
    *   **营销自动化集成**: 将符合条件的线索推送到营销自动化流程进行培育。
5.  **高并发线索处理**: 对于可能产生大量并发线索的场景（如大型营销活动、API批量导入），需确保接入层、处理层的高性能和可伸缩性。可采用消息队列进行削峰填谷和异步处理。
6.  **数据一致性**: 保证线索在创建、分配、转化各阶段状态的一致性。若涉及分布式事务，需谨慎处理。
7.  **配置灵活性与热加载**: 场景配置（特别是规则类配置）应尽可能支持动态修改并实时生效，避免重启服务。
8.  **监控与告警**: 监控各场景线索接入量、处理成功率、队列积压情况、规则执行异常等，并设置告警。
9.  **可测试性**: 模块各部分（特别是规则逻辑、场景适配器）应易于单元测试和集成测试。

## 九、数据校验与错误处理

1.  **输入数据校验**: 对所有外部传入的线索数据进行基础格式校验（如手机号、邮箱格式）。对特定场景的必填字段进行校验。
2.  **Webhook/回调验签**: 接收第三方平台推送数据时，必须严格校验签名或Token，确保数据来源可靠。
3.  **配置数据校验**: 管理员在配置场景规则时，进行逻辑校验（如分配用户是否存在、标签是否有效）。
4.  **依赖服务异常处理**: 调用外部服务（如CRM、电话系统API）失败时，有重试和降级机制。
5.  **规则执行异常**: 规则引擎或自定义规则执行出错时，记录详细错误信息，并有通知机制，避免影响主流程。
6.  **死信队列**: 对于无法处理的线索消息或Webhook通知，应转入死信队列，供人工排查和处理。

## 十、安全性考量

1.  **API认证与授权**: 所有API接口（特别是配置类接口和接收线索的写接口）必须有严格的认证机制（如API Key/Secret, OAuth2）。细化权限控制，不同调用方只能访问其授权的资源和操作。
2.  **Webhook安全**: 
    *   使用HTTPS确保传输安全。
    *   对回调请求进行签名验证 (如使用HMAC-SHA256) 防止伪造和篡改。
    *   (可选) 限制回调来源IP地址。
3.  **敏感数据处理**: 
    *   线索中可能包含用户个人敏感信息，存储和传输时需符合数据保护法规（如加密存储电话、邮箱等）。
    *   在日志和监控中避免直接暴露原始敏感数据，进行脱敏处理。
4.  **防数据泄露**: 控制对线索数据库的直接访问权限。数据导出功能需有审批和审计。
5.  **防范恶意提交与攻击**: 
    *   对公开的线索提交通道（如网站表单对应的接收API）进行速率限制、防机器人提交（如验证码）。
    *   输入清理，防止XSS、SQL注入等攻击（虽然现代框架有防护，但仍需注意自定义解析逻辑）。
6.  **凭证管理**: 安全存储和使用访问第三方平台（如社交媒体API、订单平台API）所需的凭证，遵循最小权限原则。

---
> 本文档为场景化获客模块提供后端设计指导，旨在构建一个灵活、高效、可扩展的线索捕获与处理中心。具体实现细节需根据业务需求和技术选型进行调整。 

---

## 文件 11: 后端-场景获客-微信群获客功能开发文档.md

*文件大小：22.20 KB*

---

# 存客宝场景获客-微信群获客功能开发文档

## 1. 模块概述

微信群获客功能通过管理和运营微信群，实现群成员管理、群消息监控、入群欢迎语、自动踢人、数据统计等功能，帮助用户通过微信群 جذب and maintain customers。后端模块负责微信群的同步与管理、群成员管理、群消息处理、自动化规则执行以及数据统计。本模块与设备控制服务（用于实际微信操作）和客户服务进行交互。

## 2. API接口设计 (`/api/v1/lead-generation/wechat-groups`)

所有接口遵循 **`../前后端接口约定.md`** 定义的 RESTful 规范、请求响应格式、错误处理和认证授权机制。所有接口需要相应的权限控制，具体权限标识符根据权限设计定义（如 `group:sync`, `group:view`, `group:message:send`, `group:rule:manage`）。

##### 2.1 同步微信群列表

- **接口路径**：`/api/v1/lead-generation/wechat-groups/sync`
- **请求方法**：`POST`
- **接口说明**：触发同步当前登录设备上的微信群列表及基础信息。这是一个异步任务。
- **权限:** `group:sync`
- **请求参数 (Request Body):**

| 参数名   | 类型    | 是否必需 | 说明             | 示例值 |
|----------|---------|----------|------------------|--------|
| deviceId | integer | 是       | 指定要同步的设备ID | 1      |

- **响应数据 (统一格式 `data` 字段):** 返回触发同步任务的结果或任务ID。

```json
{
  "syncTaskId": 501,         // 同步任务ID
  "status": "ACCEPTED",      // 任务状态：ACCEPTED, REJECTED
  "message": "微信群同步任务已触发"
}
```
- **可能返回状态码:** 200, 400 (设备ID无效), 401, 403, 409 (设备正在同步), 500

##### 2.2 获取微信群列表

- **接口路径**：`/api/v1/lead-generation/wechat-groups`
- **请求方法**：`GET`
- **接口说明**：获取已同步的微信群列表，支持按名称、设备、成员数等筛选和分页。
- **权限:** `group:view`
- **请求参数 (Query Parameters):**

| 参数名       | 类型    | 是否必需 | 描述                     | 示例值         |
|-------------|--------|----------|--------------------------|----------------|
| deviceId    | integer| 否       | 按设备ID过滤             | 1              |
| name        | string | 否       | 群名称关键字 (模糊匹配)  | 存客宝         |
| minMembers  | integer| 否       | 最小成员数               | 10             |
| maxMembers  | integer| 否       | 最大成员数               | 100            |
| status      | string | 否       | 群状态过滤 (ACTIVE, ARCHIVED) | ACTIVE         |
| page        | integer| 否       | 页码                     | 1              |
| size        | integer| 否       | 每页条数                 | 10             |
| sort        | string | 否       | 排序字段                 | syncTime, memberCount |
| order       | string | 否       | 排序方向                 | desc           |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "groupId": 1,          // 后端系统内的群ID
      "deviceId": 1,         // 关联设备ID
      "wechatGroupId": "wxid_xxxxxxxxxxxx", // 设备端的微信群唯一标识
      "name": "存客宝核心用户群",
      "ownerId": 101,        // 群主在存客宝的用户ID
      "memberCount": 50,
      "syncTime": "2023-10-26T10:30:00Z",
      "status": "ACTIVE"
    }
    // ... 更多群记录
  ],
  "total": 100,
  "size": 10,
  "current": 1,
  "pages": 10
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

##### 2.3 获取微信群详情

- **接口路径**：`/api/v1/lead-generation/wechat-groups/{groupId}`
- **请求方法**：`GET`
- **接口说明**：获取指定微信群的详细信息，包括基础信息、关联规则等（不包含成员和消息列表）。
- **权限:** `group:view`
- **请求参数 (Path Parameters):**

| 参数名  | 类型    | 是否必需 | 描述       | 示例值 |
|---------|---------|----------|------------|--------|
| groupId | integer | 是       | 后端系统内的群ID | 1      |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "groupId": 1,
  "deviceId": 1,
  "wechatGroupId": "wxid_xxxxxxxxxxxx",
  "name": "存客宝核心用户群",
  "ownerId": 101,
  "memberCount": 50,
  "syncTime": "2023-10-26T10:30:00Z",
  "status": "ACTIVE",
  "welcomeRule": { // 关联的欢迎语规则简要信息
      "ruleId": 10,
      "status": "ACTIVE",
      "messageTemplate": "欢迎 @{nickname} 加入本群！..."
  },
  "autoKickRule": { // 关联的踢人规则简要信息
      "ruleId": 20,
      "status": "ACTIVE",
      "ruleType": "INACTIVE",
      "threshold": 30
  }
  // ... 其他群设置
}
```
- **可能返回状态码:** 200, 401, 403, 404, 500

##### 2.4 获取微信群成员列表

- **接口路径**：`/api/v1/lead-generation/wechat-groups/{groupId}/members`
- **请求方法**：`GET`
- **接口说明**：获取指定微信群的成员列表，支持分页和筛选。
- **权限:** `group:view`
- **请求参数 (Path Parameters):**

| 参数名  | 类型    | 是否必需 | 描述       | 示例值 |
|---------|---------|----------|------------|--------|
| groupId | integer | 是       | 后端系统内的群ID | 1      |

- **请求参数 (Query Parameters):**

| 参数名        | 类型    | 是否必需 | 描述           | 示例值        |
|---------------|--------|----------|----------------|---------------|
| nickname      | string | 否       | 成员昵称关键字 | 张三          |
| isOwner       | boolean| 否       | 是否群主       | true          |
| joinTimeStart | string | 否       | 入群时间范围始 | 2023-10-01Z   |
| joinTimeEnd   | string | 否       | 入群时间范围末 | 2023-10-31Z   |
| page          | integer| 否       | 页码           | 1             |
| size          | integer| 否       | 每页条数       | 10            |
| sort          | string | 否       | 排序字段       | joinTime, lastActiveTime |
| order         | string | 否       | 排序方向       | desc          |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "memberId": 101,       // 成员在存客宝的用户ID
      "wechatMemberId": "wxid_zzzzzzzzzzz", // 设备端的成员唯一标识
      "groupId": 1,
      "nickname": "张三",      // 群内昵称
      "joinTime": "2023-10-26T11:00:00Z",
      "lastActiveTime": "2023-10-26T14:00:00Z",
      "isOwner": false
      // ... 其他成员信息
    }
    // ... 更多群成员记录
  ],
  "total": 50,
  "size": 10,
  "current": 1,
  "pages": 5
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 500

##### 2.5 设置入群欢迎语规则

- **接口路径**：`/api/v1/lead-generation/wechat-groups/{groupId}/rules/welcome`
- **请求方法**：`PUT`
- **接口说明**：设置指定微信群的入群欢迎语规则。
- **权限:** `group:rule:manage`
- **请求参数 (Path Parameters):**

| 参数名  | 类型    | 是否必需 | 描述       | 示例值 |
|---------|---------|----------|------------|--------|
| groupId | integer | 是       | 后端系统内的群ID | 1      |

- **请求体 (Request Body):**

```json
{
  "messageTemplate": "欢迎 @{nickname} 加入本群！请仔细阅读群规：{link}", // 欢迎语模板，支持占位符
  "status": "ACTIVE" // 规则状态：ACTIVE, INACTIVE
  // 可选：其他配置，如延迟发送时间等
}
```
- **响应数据 (统一格式 `data` 字段):** 返回更新后的规则信息或成功状态。

```json
{
  "ruleId": 10,
  "groupId": 1,
  "status": "ACTIVE",
  "messageTemplate": "欢迎 @{nickname} 加入本群！请仔细阅读群规：{link}"
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 500

##### 2.6 设置自动踢人规则

- **接口路径**：`/api/v1/lead-generation/wechat-groups/{groupId}/rules/auto-kick`
- **请求方法**：`PUT`
- **接口说明**：设置指定微信群的自动踢人规则（如长时间不活跃、发送违禁词等）。
- **权限:** `group:rule:manage`
- **请求参数 (Path Parameters):**

| 参数名  | 类型    | 是否必需 | 描述       | 示例值 |
|---------|---------|----------|------------|--------|
| groupId | integer | 是       | 后端系统内的群ID | 1      |

- **请求体 (Request Body):**

```json
{
  "ruleType": "INACTIVE", // 规则类型：INACTIVE (不活跃), FORBIDDEN_WORDS (违禁词)
  "threshold": 30, // 阈值 (如30天不活跃)
  "forbiddenWords": ["广告", "兼职", "代购"], // 违禁词列表
  "status": "ACTIVE"
  // 可选：其他配置，如白名单成员列表等
}
```
- **响应数据 (统一格式 `data` 字段):** 返回更新后的规则信息或成功状态。

```json
{
  "ruleId": 20,
  "groupId": 1,
  "status": "ACTIVE",
  "ruleType": "INACTIVE",
  "threshold": 30
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 500

##### 2.7 发送群消息

- **接口路径**：`/api/v1/lead-generation/wechat-groups/{groupId}/messages`
- **请求方法**：`POST`
- **接口说明**：向指定微信群发送消息（文本、图片、文件、链接等）。这是一个异步任务。
- **权限:** `group:message:send`
- **请求参数 (Path Parameters):**

| 参数名  | 类型    | 是否必需 | 描述       | 示例值 |
|---------|---------|----------|------------|--------|
| groupId | integer | 是       | 后端系统内的群ID | 1      |

- **请求体 (Request Body):**

```json
{
  "messageType": "TEXT", // 消息类型：TEXT, IMAGE, FILE, LINK etc.
  "content": "本周活动开始了，点击链接参与：...", // 文本内容
  "materialId": null, // 如果是素材库中的图片/文件等，提供素材ID
  "fileUrl": "http://example.com/image.jpg" // 如果直接提供文件URL (考虑安全性，优先使用materialId)
  // 更多消息类型和对应字段...
}
```
- **响应数据 (统一格式 `data` 字段):** 返回发送任务的结果或任务ID。

```json
{
  "sendTaskId": 601,         // 发送任务ID
  "status": "ACCEPTED",      // 任务状态：ACCEPTED, REJECTED
  "message": "群消息发送任务已触发"
}
```
- **可能返回状态码:** 200, 400 (参数错误/群状态异常), 401, 403, 404, 500

##### 2.8 获取群消息记录

- **接口路径**：`/api/v1/lead-generation/wechat-groups/{groupId}/messages`
- **请求方法**：`GET`
- **接口说明**：获取指定微信群的消息记录，支持分页和筛选。
- **权限:** `group:view`
- **请求参数 (Path Parameters):**

| 参数名  | 类型    | 是否必需 | 描述       | 示例值 |
|---------|---------|----------|------------|--------|
| groupId | integer | 是       | 后端系统内的群ID | 1      |

- **请求参数 (Query Parameters):**

| 参数名       | 类型    | 是否必需 | 描述           | 示例值         |
|-------------|--------|----------|----------------|---------------|
| senderId    | integer| 否       | 按发送者用户ID过滤 | 101           |
| messageType | string | 否       | 按消息类型过滤 | TEXT          |
| content     | string | 否       | 消息内容关键字 | 活动           |
| startTime   | string | 否       | 发送时间范围始 | 2023-10-01Z   |
| endTime     | string | 否       | 发送时间范围末 | 2023-10-31Z   |
| page        | integer| 否       | 页码           | 1             |
| size        | integer| 否       | 每页条数       | 10            |
| sort        | string | 否       | 排序字段       | sendTime      |
| order       | string | 否       | 排序方向       | desc          |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "messageId": 701,      // 后端系统内的消息ID
      "groupId": 1,
      "senderId": 101,       // 发送者在存客宝的用户ID
      "messageType": "TEXT",
      "content": "大家好！",
      "sendTime": "2023-10-26T14:05:00Z",
      "materialUrl": null    // 如果是图片/文件等，这里提供URL (可能需要权限访问)
      // ... 其他消息信息
    }
    // ... 更多消息记录
  ],
  "total": 200,
  "size": 10,
  "current": 1,
  "pages": 20
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 500

##### 2.9 处理微信群消息推送 (Webhook)

- **接口路径**：`/api/v1/webhook/wechat-group/message`
- **请求方法**：`POST`
- **接口说明**：接收来自设备端的微信群消息推送。后端根据消息内容触发自动回复或关键词处理等逻辑。此接口通常无需认证。
- **请求参数 (Request Body):** 具体结构依赖于设备端推送的数据格式，通常包含：

| 参数名         | 类型    | 说明                               | 示例值 |
|----------------|---------|------------------------------------|--------|
| deviceId       | integer | 推送消息的设备ID                     | 1      |
| wechatGroupId  | string  | 设备端的微信群唯一标识               | wxid_xxxxxxxxxxxx |
| senderWechatId | string  | 设备端的发送者微信唯一标识           | wxid_yyyyyyyyyyyy |
| messageType    | string  | 消息类型 (TEXT, IMAGE, MEMBER_JOIN etc.) | TEXT   |
| content        | string  | 消息内容                             | 你好   |
| sendTime       | string  | 消息发送时间 (ISO 8601或其他约定格式) | 2023-10-26T14:06:00Z |
| ...            | ...     | 其他消息相关数据 (图片URL, 文件URL等) | ...    |

- **响应数据:** 接收成功通常返回简单的成功标识。

```json
{
  "code": 200,
  "message": "received"
}
```
- **可能返回状态码:** 200, 400 (数据格式错误), 500

---

## 3. 数据模型设计

##### 3.1 主要数据表

| 表名                    | 说明              | 关键字段                                           | 与其他表关系 |
|------------------------|------------------|---------------------------------------------------|------------|
| t_wechat_group         | 微信群表          | id (PK), device_id, wechat_group_id (设备端ID), name, owner_id, member_count, sync_time, status, create_time, update_time | device_id -> t_device (假设设备表), owner_id -> t_user (用户表) |
| t_wechat_group_member  | 微信群成员表      | id (PK), group_id (FK), member_user_id (FK), nickname, join_time, last_active_time, create_time, update_time | group_id -> t_wechat_group, member_user_id -> t_user |
| t_wechat_group_message | 微信群消息记录表  | id (PK), group_id (FK), sender_user_id (FK), message_type, content, material_id (FK), send_time, create_time | group_id -> t_wechat_group, sender_user_id -> t_user, material_id -> t_material (素材库表) |
| t_group_welcome_rule   | 群欢迎语规则表    | id (PK), group_id (FK), message_template, status, create_time, update_time | group_id -> t_wechat_group |
| t_group_kick_rule      | 群踢人规则表      | id (PK), group_id (FK), rule_type, threshold, forbidden_words_json, status, create_time, update_time | group_id -> t_wechat_group |

补充了数据表之间的关系、主键(PK)和外键(FK)标识，以及时间戳字段。

#### 4. 服务实现 (Service Implementation)

简要说明核心服务的职责和关键方法，并补充关键逻辑的实现思路。

##### 4.1 `WechatGroupService`

负责微信群的同步、管理和查询。通过调用 `DeviceControlService` 获取设备上的群信息，并更新到数据库。管理群和成员的状态。

- **关键方法:**
    - `syncGroups(Long deviceId)`: 触发异步群同步任务。调用 `DeviceControlService` 的 `GET_GROUPS` 命令。接收设备端返回的群和成员数据，进行解析和批量更新/插入到 `t_wechat_group` 和 `t_wechat_group_member` 表。需要考虑数据去重和更新逻辑。
    - `getGroupList(GroupQuery query)`: 分页查询微信群列表，支持按设备、名称、成员数等条件过滤和排序。
    - `getGroupDetail(Long groupId)`: 获取指定微信群详情，包含关联规则简要信息。
    - `getGroupMembers(Long groupId, MemberQuery query)`: 分页查询指定群的成员列表，支持按昵称、入群时间等过滤和排序。需要关联 `t_wechat_group_member` 和 `t_user` 表。
    - `updateGroupInfo(Long groupId, GroupUpdateDTO dto)`: 更新群基础信息（如名称、状态等）。
    - `updateGroupMember(Long groupId, Long userId, MemberUpdateDTO dto)`: 更新群成员信息（如昵称、活跃时间等），主要通过 Webhook 接收设备端事件更新。需要确保 `t_user` 表中有对应的用户记录（通过微信ID查找或创建）。

##### 4.2 `WechatGroupMessageService`

负责处理微信群消息的接收、保存和自动化响应。接收来自设备端的 Webhook 推送，保存消息记录，并触发规则检查（欢迎语、关键词回复、踢人）。通过调用 `DeviceControlService` 发送群消息。

- **关键方法:**
    - `handleGroupMessageWebhook(WechatGroupMessageEvent event)`: Webhook 接口接收消息事件。根据 `wechatGroupId` 和 `senderWechatId` 查找对应的微信群和发送者用户（如果不存在则创建用户）。保存消息到 `t_wechat_group_message` 表。根据消息类型和内容，调用 `WechatGroupRuleService` 检查并执行规则（欢迎语、关键词回复、踢人）。
    - `sendGroupMessage(Long groupId, MessageSendDTO dto)`: 触发异步发送群消息任务。根据 `groupId` 查找对应的 `deviceId` 和 `wechatGroupId`。调用 `DeviceControlService` 的 `SEND_GROUP_MESSAGE` 命令。需要支持不同消息类型（文本、图片、文件等）的处理。
    - `getGroupMessages(Long groupId, MessageQuery query)`: 分页查询指定群的消息记录，支持按发送者、消息类型、内容、时间范围过滤和排序。

##### 4.3 `WechatGroupRuleService`

负责管理和提供微信群的自动化规则（欢迎语、踢人规则等）。提供规则查询和检查方法。

- **关键方法:**
    - `getWelcomeMessage(Long groupId, String nickname)`: 根据群ID查询有效的入群欢迎语规则，将模板中的占位符（如 `{nickname}`, `{link}` 等）替换为实际值，返回欢迎语内容。需要支持不同的占位符。
    - `getKeywordReply(Long groupId, String messageContent)`: 根据群ID和消息内容查询有效的关键词回复规则。实现关键词匹配逻辑（精确匹配、模糊匹配、正则匹配）。如果匹配到规则，返回对应的回复内容。
    - `checkAutoKickRules(Long groupId, Long userId, String messageContent, Date lastActiveTime)`: 根据群ID和成员用户ID查询有效的踢人规则。判断是否满足踢人条件，例如：检查 `lastActiveTime` 是否超过不活跃阈值；检查 `messageContent` 是否包含违禁词。返回是否需要踢人以及原因。
    - `saveWelcomeRule(Long groupId, WelcomeRuleDTO dto)`: 保存或更新入群欢迎语规则。
    - `saveAutoKickRule(Long groupId, AutoKickRuleDTO dto)`: 保存或更新自动踢人规则。

##### 4.4 `DeviceControlService` (依赖模块)

负责与实际的微信操作设备进行通信，执行指令（如获取群列表、发送群消息、踢人），并上报事件（如收到新消息、新成员加入）。

- **关键方法:**
    - `executeCommand(Long deviceId, DeviceCommand command)`: 向指定设备发送控制指令。

##### 4.5 `CustomerService` (依赖模块)

负责存客宝平台的用户/客户管理。提供根据微信ID查找或创建客户的功能。

- **关键方法:**
    - `findOrCreateCustomerByWechatId(String wechatId)`: 根据微信ID查找客户，如果不存在则创建新客户并返回。
    - `findCustomerById(Long userId)`: 根据用户ID查找客户。

#### 5. 数据验证

对所有接收到的请求参数和请求体进行严格验证，例如：

- 同步群列表时，校验 `deviceId` 是否有效。
- 设置规则时，校验规则内容的合法性（如阈值范围、违禁词格式）。
- 发送群消息时，校验 `groupId` 和消息内容的合法性。
- Webhook 接收消息时，可能需要验证签名以确保消息来源可信。

使用 Spring Validation 框架结合注解实现。验证失败时，按照 `../前后端接口约定.md` 中的约定返回 422 状态码和详细的错误信息列表。

#### 6. 错误处理

遵循 `./前后端接口约定.md` 中的错误处理规范。捕获并处理常见的异常，例如：

- 参数校验失败 (`MethodArgumentNotValidException`) 返回 422。
- 资源未找到 (`GroupNotFoundException`, `MemberNotFoundException`, `RuleNotFoundException`) 返回 404。
- 权限不足 (`AccessDeniedException`) 返回 403。
- 业务逻辑错误（如设备离线、群状态异常、规则冲突、踢人失败）返回 400 或特定业务错误码。
- 调用设备控制服务失败、调用客户服务失败、数据库异常等系统内部错误返回 500。

Webhook 接口的异常处理需要特殊考虑，通常返回 200 表示接收成功，具体业务处理失败通过日志和告警监控。

#### 7. 日志记录

记录关键操作日志，包括：

- 群同步任务的触发、状态和结果。
- 群和成员的创建、更新。
- 群消息的发送和接收（Webhook）。
- 自动化规则的设置和触发（入群欢迎语发送、踢人尝试）。
- 与设备控制服务和客户服务的交互日志。
- 所有异常日志。

日志应包含操作人（如果适用）、操作时间、群/成员/消息ID、操作类型、操作结果、错误信息等信息。

#### 8. 性能与并发

- Webhook 接口可能面临高并发的消息推送，需要设计为快速响应，并将实际消息处理放入消息队列进行异步处理。
- 群消息发送和自动化规则执行（如批量检查不活跃成员）也应设计为异步任务。
- 优化数据库查询（如获取群列表、成员列表、消息记录）以提高性能。
- 考虑设备端的连接稳定性和消息丢失问题，可能需要引入消息确认和重传机制。

#### 9. 安全性

- 所有面向前端的接口必须进行认证授权校验。
- Webhook 接口需要进行签名验证等安全措施，确保消息来源可信。
- 存储敏感信息（如原始消息内容、成员微信ID等）需要进行脱敏或加密处理。
- 对可执行的规则内容（如欢迎语模板）进行安全校验，防止注入攻击。

---

> 本文档详细说明了存客宝后端场景获客-微信群获客功能的设计与实现要点，开发时请严格遵循上述规范，确保系统功能完善和安全稳定。 

---

## 文件 12: 后端-场景获客-小红书获客功能开发文档.md

*文件大小：9.85 KB*

---

# 社交内容平台获客模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块旨在通过接入外部社交内容平台（如小红书、抖音、视频平台、博客平台等），获取内容互动产生的潜在客户信息，实现内容营销向客户转化的闭环。这类获客渠道通常拥有大量高质量UGC内容和活跃用户，用户在评论、私信等互动中表现出的购买意向是重要的线索来源。

### 1.2. 设计目标
- **多平台支持**: 采用可扩展的设计，支持接入多种社交内容平台。
- **授权便捷**: 提供简单易用的账号授权流程，便于运营人员绑定其社交平台账号。
- **自动同步**: 自动或定期同步社交平台的互动数据（评论、私信等）。
- **线索分类**: 根据互动内容、模式等对获取的线索进行智能分类和价值评估。
- **闭环管理**: 将获取的线索纳入统一的客户管理体系，支持后续跟进和转化。

## 2. 核心概念

- **平台账号 (Platform Account)**: 用户在社交内容平台的账号，需要授权给系统才能获取互动数据。
- **授权凭证 (Authorization Credential)**: 用于访问社交平台API的凭证，通常包括访问令牌、刷新令牌等。
- **内容资源 (Content Resource)**: 平台账号发布的内容，如文章、视频、笔记等，是用户互动的载体。
- **互动数据 (Interaction Data)**: 用户与内容的互动，如评论、点赞、收藏、私信等。
- **线索 (Lead)**: 从互动数据中提取的潜在客户信息，包括用户信息、互动内容、互动时间等。
- **同步任务 (Sync Task)**: 从社交平台同步互动数据的任务，可能是定时执行或手动触发。

## 3. 核心数据实体/模型 (Conceptual)

- **`PlatformAuthorization` (平台授权)**
    - `authorizationId` (授权ID)
    - `userId` (系统用户ID)
    - `platformType` (平台类型：XIAOHONGSHU, DOUYIN, BILIBILI, 等)
    - `platformUserId` (平台用户ID)
    - `accessToken` (访问令牌)
    - `refreshToken` (刷新令牌)
    - `tokenExpireTime` (令牌过期时间)
    - `scope` (授权范围)
    - `status` (授权状态：ACTIVE, EXPIRED, REVOKED)

- **`ContentResource` (内容资源)**
    - `resourceId` (资源ID)
    - `authorizationId` (关联的授权ID)
    - `platformType` (平台类型)
    - `originalId` (平台原始内容ID)
    - `title` (内容标题)
    - `url` (内容URL)
    - `type` (内容类型：POST, VIDEO, ARTICLE, 等)
    - `publishTime` (发布时间)
    - `lastSyncTime` (最后同步时间)

- **`SocialInteractionLead` (社交互动线索)**
    - `leadId` (线索ID)
    - `authorizationId` (授权ID)
    - `resourceId` (内容资源ID)
    - `platformType` (平台类型)
    - `interactionType` (互动类型：COMMENT, PRIVATE_MESSAGE, LIKE, 等)
    - `interactionId` (平台互动记录ID)
    - `platformUserId` (互动用户的平台ID)
    - `nickname` (用户昵称)
    - `avatarUrl` (用户头像)
    - `content` (互动内容/评论文本)
    - `interactionTime` (互动时间)
    - `leadScore` (线索评分，可选)
    - `tags` (标签，可选)
    - `status` (线索状态：NEW, PROCESSING, CONTACTED, CONVERTED, INVALID)
    - `notes` (备注)

## 4. 功能模块划分

### 4.1. 平台授权管理模块
- **功能**：
    - 提供各社交平台的授权入口和回调处理。
    - 管理和刷新授权令牌。
    - 查看、管理已授权的平台账号。
- **主要接口 (Conceptual)**:
    - 获取授权URL: `/api/v1/social/auth/{platformType}/url`
    - 授权回调处理: `/api/v1/social/auth/{platformType}/callback`
    - 查询已授权账号: `/api/v1/social/auth/accounts`
    - 解除平台授权: `/api/v1/social/auth/{authorizationId}`

### 4.2. 内容资源管理模块
- **功能**：
    - 同步/查询已授权账号发布的内容列表。
    - 选择要监控互动的特定内容资源。
    - 查看内容资源的数据概览（如互动数量、线索数等）。
- **主要接口 (Conceptual)**:
    - 同步内容资源: `/api/v1/social/contents/sync`
    - 查询内容资源: `/api/v1/social/contents`
    - 内容资源详情: `/api/v1/social/contents/{resourceId}`

### 4.3. 互动数据同步模块
- **功能**：
    - 根据设置自动或手动同步内容资源的互动数据。
    - 处理和转换互动数据，提取线索信息。
    - 管理同步任务的执行和状态。
- **主要接口 (Conceptual)**:
    - 触发互动同步: `/api/v1/social/interactions/sync`
    - 查询同步任务: `/api/v1/social/interactions/tasks`
    - 同步任务详情: `/api/v1/social/interactions/tasks/{taskId}`

### 4.4. 线索管理模块
- **功能**：
    - 查询和过滤从社交平台获取的线索。
    - 对线索进行标记、分类、评分。
    - 将线索转化为正式客户或推送到其他客户管理模块。
- **主要接口 (Conceptual)**:
    - 查询线索列表: `/api/v1/social/leads`
    - 线索详情: `/api/v1/social/leads/{leadId}`
    - 更新线索状态: `/api/v1/social/leads/{leadId}/status`
    - 添加线索备注: `/api/v1/social/leads/{leadId}/notes`

## 5. 业务流程示例

### 5.1 平台账号授权流程
1. 系统生成平台特定的授权URL。
2. 用户访问授权URL，在平台页面上完成授权。
3. 平台重定向回系统的回调接口，带上授权码。
4. 系统使用授权码从平台获取访问令牌和刷新令牌。
5. 系统存储授权信息，建立用户与平台账号的关联。

### 5.2 内容互动同步流程
1. 用户选择已授权的平台账号和需要监控的内容资源。
2. 系统创建同步任务，可立即执行或按计划执行。
3. 同步任务调用平台API，获取内容的互动数据（如评论列表）。
4. 系统处理互动数据，提取用户信息和互动内容。
5. 系统根据预设规则评估互动价值，生成线索记录。
6. 线索数据写入数据库，并可选择性推送到其他系统。

### 5.3 线索处理流程
1. 用户查询和筛选线索列表，可按平台、内容、时间、关键词等过滤。
2. 用户查看线索详情，包括互动用户信息、互动内容、来源内容等。
3. 用户对线索进行初步评估，更新状态、添加标签或备注。
4. 对有价值的线索，用户可通过系统提供的方式联系该用户（如平台私信）。
5. 成功建立联系后，可将线索转化为客户，进入后续的客户管理流程。

## 6. 技术考量与开发注意事项

### 6.1 平台对接策略
- **开放平台API**: 优先使用各平台官方提供的开放API，遵循平台的接入规范和限制。
- **API限流处理**: 社交平台通常对API调用有频率限制，需要设计合理的请求策略，避免触发限流。
- **多平台抽象**: 设计统一的接口抽象层，使系统能够以相似的方式处理不同平台的数据，便于扩展新平台。

### 6.2 数据同步策略
- **增量同步**: 优先实现增量同步机制，只获取上次同步后的新数据，减少资源消耗。
- **重试机制**: 针对同步失败的情况，设计适当的重试策略。
- **任务调度**: 合理规划同步任务的执行时间和频率，避免集中请求造成系统负载过高。

### 6.3 授权安全
- **令牌安全存储**: 平台的访问令牌和刷新令牌是敏感信息，应加密存储并严格控制访问权限。
- **令牌刷新**: 实现令牌刷新机制，确保长期有效的平台访问能力。
- **授权状态监控**: 定期检查授权状态，及时处理过期或失效的授权。

### 6.4 数据处理
- **数据清洗**: 对同步的互动数据进行清洗，去除无效或垃圾内容。
- **敏感信息处理**: 关注用户隐私保护，对敏感信息进行适当处理（如脱敏、加密）。
- **内容分析**: 可考虑使用NLP技术对互动内容进行分析，提取关键信息，评估线索价值。

## 7. 数据校验与错误处理

### 7.1 常见异常类型
- **平台API异常**: 调用社交平台API可能出现的各类异常，如网络错误、权限不足、参数错误等。
- **授权异常**: 授权过程中可能出现的异常，如用户拒绝授权、授权码无效、令牌过期等。
- **数据同步异常**: 同步过程中可能出现的异常，如API限流、数据格式变更、平台服务不可用等。
- **数据处理异常**: 处理互动数据时可能出现的异常，如数据格式错误、字段缺失等。

### 7.2 异常处理策略
- 设计清晰的异常层次结构，方便定位和处理特定类型的异常。
- 记录详细的错误日志，包括异常类型、时间、上下文信息等。
- 实现适当的异常恢复机制，如自动重试、降级服务等。
- 对用户友好的错误提示，避免暴露系统内部细节。

## 8. 安全性考量

- **数据保护**: 严格控制从社交平台获取的用户数据的访问权限，防止数据泄露。
- **合规性**: 确保系统的设计和实现符合相关的数据保护法规和平台使用条款。
- **用户同意**: 在获取和使用用户数据前，确保获得用户的明确同意。
- **安全通信**: 使用HTTPS等安全协议进行与社交平台的通信，保护数据传输安全。

## 9. 可扩展性设计

- **新平台集成**: 设计模块化的平台适配器，使系统能够方便地集成新的社交内容平台。
- **功能扩展**: 预留功能扩展点，如线索评分算法、自动回复策略等。
- **与其他系统集成**: 提供标准的数据接口，便于与CRM、客户服务等系统集成。

## 10. 监控与运维

- **同步任务监控**: 监控同步任务的执行状态、成功率、耗时等指标。
- **授权状态监控**: 监控平台授权的有效性，及时发现并处理失效的授权。
- **系统资源监控**: 监控系统资源使用情况，如数据库负载、API调用频率等。
- **告警机制**: 设置合理的告警阈值和通知机制，确保问题能够及时被发现和处理。

---

## 文件 13: 后端-场景获客-API获客功能开发文档.md

*文件大小：10.74 KB*

---

# 外部系统API对接获客模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块旨在为外部系统（如合作伙伴、第三方平台、营销自动化工具等）提供一套标准、安全、高效的API接口，用于将潜在客户数据（线索）推送到存客宝系统中。通过此模块，可以实现自动化、程序化的外部数据源接入，丰富和扩展获客渠道。

### 1.2. 设计目标
- **标准化**：提供定义清晰、一致的API接口规范，降低对接难度。
- **安全性**：确保数据传输和接口访问的安全性，防止未授权访问和数据泄露。
- **可靠性**：保证数据接收的稳定性和准确性，具备一定的容错和重试机制。
- **可扩展性**：设计上应考虑未来可能的字段增加、数据格式调整等需求。
- **可监控性**：能够对API调用情况、数据接收情况进行记录和监控。

## 2. 核心概念

- **API密钥 (API Key)**: 用于认证外部系统身份的凭证，通常包含一个`Access Key ID`和`Secret Key`。
- **数据接入点 (Data Ingestion Endpoint)**: 外部系统推送数据的目标API接口。
- **原始数据日志 (Raw Data Log)**: 记录接收到的原始外部数据的日志，用于追溯和问题排查。
- **数据校验 (Data Validation)**: 对接收到的数据进行格式、类型、完整性等方面的校验。
- **数据转换/映射 (Data Transformation/Mapping)**: 将外部系统的数据结构转换为内部系统可识别的客户或线索模型。
- **异步处理 (Asynchronous Processing)**: 对于数据量较大或处理耗时较长的场景，采用异步方式处理，例如通过消息队列。
- **请求签名 (Request Signing)**: 为防止数据篡改和重放攻击，外部系统在调用API时需对请求进行签名。

## 3. 核心数据实体/模型 (Conceptual)

- **`ApiAccessConfiguration` (API访问配置)**
    - `partnerId` (合作伙伴/系统ID)
    - `accessKeyId` (访问密钥ID)
    - `secretKeyHash` (加密存储的密钥)
    - `allowedIpAddresses` (允许的IP白名单，可选)
    - `status` (启用/禁用)
    - `description` (描述)
    - `rateLimit` (频率限制配置，可选)

- **`ExternalRawDataLog` (外部原始数据日志)**
    - `logId` (日志ID)
    - `partnerId` (合作伙伴/系统ID)
    - `receivedTimestamp` (接收时间戳)
    - `requestHeaders` (请求头信息)
    - `requestBody` (原始请求体)
    - `validationStatus` (校验状态：成功/失败)
    - `processingStatus` (处理状态：待处理/处理中/成功/失败)
    - `errorMessage` (错误信息，如果处理失败)

- **（内部）`Lead` / `CustomerProspect` (线索/潜在客户)**
    - (根据实际业务定义的线索字段，如姓名、电话、邮箱、来源、意向产品等)

## 4. 功能模块划分

### 4.1. API密钥管理模块
- **功能**：
    - 创建、查看、更新、禁用API密钥。
    - 安全存储密钥信息。
    - 管理密钥的权限和范围（如果需要）。
- **主要接口 (Conceptual Admin API)**:
    - `POST /admin/api-keys` (创建密钥)
    - `GET /admin/api-keys/{keyId}` (查询密钥详情)
    - `PUT /admin/api-keys/{keyId}` (更新密钥状态或描述)

### 4.2. 数据接收与预处理模块
- **功能**：
    - 提供数据接收的API端点。
    - 验证请求签名和API密钥的有效性。
    - 记录原始请求数据。
    - 对接收的数据进行初步校验（如格式、必填项）。
- **主要接口 (Conceptual Public API)**:
    - `POST /public/v1/leads/ingest` (外部系统推送线索数据接口)

### 4.3. 数据处理与转换模块
- **功能**：
    - 对通过初步校验的数据进行详细业务校验。
    - 将外部数据模型映射到内部线索/客户模型。
    - 执行数据清洗、去重等操作。
    - 将处理后的数据存入业务数据库。
- **内部机制**：
    - 可通过消息队列与数据接收模块解耦，实现异步处理。

### 4.4. 日志与监控模块
- **功能**：
    - 记录API调用日志、数据处理日志、错误日志。
    - 提供监控指标，如API调用频率、成功率、失败率、数据处理延迟等。

## 5. API接口设计指导原则 (Conceptual)

### 5.1. 认证与授权
- **认证方式**：推荐使用基于HMAC（Hash-based Message Authentication Code）的请求签名机制。外部系统使用分配的`Secret Key`对请求的关键部分（如HTTP方法、URI、时间戳、请求体）进行签名，并将签名结果通过请求头传递。
    - 例如，自定义请求头 `X-Signature`。
    - 服务端用同样的`Secret Key`重新计算签名并比对。
- **API Key传递**：`Access Key ID`可通过请求头（如 `X-Access-Key-Id`）或请求参数传递。

### 5.2. 请求与响应
- **数据格式**：推荐使用JSON作为数据交换格式。
- **HTTP方法**：遵循RESTful原则，使用合适的HTTP动词（如`POST`用于创建资源）。
- **版本控制**：在API路径中包含版本号（如 `/v1/`）。
- **响应状态码**：
    - `200 OK` 或 `202 Accepted` (对于异步处理): 请求成功。
    - `400 Bad Request`: 请求参数错误、格式错误、校验失败。
    - `401 Unauthorized`: 认证失败（签名无效、API Key无效）。
    - `403 Forbidden`: 授权失败（API Key无权限）。
    - `429 Too Many Requests`: 超出频率限制。
    - `500 Internal Server Error`: 服务器内部错误。
- **响应体**：
    - 成功时，可返回处理结果或任务ID（对于异步处理）。
    - 失败时，应返回结构化的错误信息，包含错误码、错误描述。
      ```json
      {
        "errorCode": "INVALID_PARAMETER",
        "message": "Field \'email\' is not a valid email address."
      }
      ```

### 5.3. 数据模型 (线索数据示例)
```json
// POST /public/v1/leads/ingest 请求体示例
{
  "externalLeadId": "XYZ-12345", // 外部系统线索ID，用于幂等性或追踪
  "sourceSystem": "PartnerPlatformA",
  "timestamp": "2023-10-27T10:30:00Z",
  "leadData": {
    "name": "张三",
    "phone": "13800138000",
    "email": "zhangsan@example.com",
    "company": "某某公司",
    "city": "厦门",
    "productInterest": ["ProductA", "ServiceB"],
    "notes": "通过市场活动A获取的线索",
    "customFields": {
      "utm_source": "campaign_xyz"
    }
  }
}
```

## 6. 主要业务流程示例

### 6.1. 外部系统推送线索
1. **外部系统**：准备待推送的线索数据。
2. **外部系统**：根据约定的签名算法，使用`Secret Key`对请求内容（或其摘要）进行签名。
3. **外部系统**：构造HTTP POST请求，目标为数据接入点 (e.g., `/public/v1/leads/ingest`)。
    - 请求头中包含 `Access Key ID` 和计算出的签名。
    - 请求体为JSON格式的线索数据。
4. **本模块 (API网关/接入层)**：接收请求。
5. **本模块**：
    - 提取 `Access Key ID`。
    - 根据 `Access Key ID` 查询对应的 `Secret Key`。
    - 验证请求时间戳的有效性（防止重放攻击）。
    - 使用同样的算法重新计算签名，与请求中的签名进行比对。
    - **若签名无效或API Key无效**：返回 `401 Unauthorized`。
6. **本模块 (数据接收与预处理)**：
    - 记录原始请求到 `ExternalRawDataLog`。
    - 对请求体JSON进行基本格式校验和必填项校验。
    - **若校验失败**：更新日志状态，返回 `400 Bad Request` 及错误详情。
7. **本模块**：
    - **同步处理方式**：直接调用数据处理与转换模块。
    - **异步处理方式**：将原始数据（或其引用）发送到消息队列，返回 `202 Accepted` 给外部系统。
8. **本模块 (数据处理与转换，可能异步)**：
    - 从消息队列消费数据（异步时）。
    - 进行详细业务校验、数据清洗、去重、转换。
    - 将数据保存到核心业务系统的线索库。
    - 更新 `ExternalRawDataLog` 中的处理状态和结果。

## 7. 技术考量与开发注意事项

- **幂等性设计**：对于数据创建类接口，需要考虑幂等性。外部系统可能会因为网络问题重试请求。可以通过要求外部系统传递唯一的请求ID或业务ID (`externalLeadId`) 来实现。
- **安全性**：
    - `Secret Key`绝不能在客户端或不安全信道中暴露。
    - 定期审计和更换API密钥。
    - 对输入数据进行严格的清理和验证，防止注入攻击（如SQL注入、XSS）。
    - 考虑对敏感数据在传输和存储时进行加密。
- **日志与监控**：完善的日志记录对于问题排查和审计至关重要。监控API的性能指标和错误率，以便及时发现和处理问题。
- **错误处理**：提供清晰、具体的错误信息给API调用方。
- **文档**：提供详细、准确的API文档给外部开发者，包括认证方式、请求/响应格式、数据模型、错误码等。
- **可测试性**：模块应易于测试，包括单元测试、集成测试和端到端测试。可以提供一个沙箱环境供外部系统测试对接。

## 8. 数据校验与错误处理

### 8.1. 数据校验层级
- **网关/接入层校验**：认证信息校验、签名校验、请求频率限制。
- **基础格式校验**：JSON格式、必填字段、数据类型、长度限制。
- **业务逻辑校验**：枚举值有效性、关联数据存在性、业务规则符合性。

### 8.2. 错误响应规范
- 使用标准的HTTP状态码。
- 响应体中包含 `errorCode` (内部定义的错误码) 和 `message` (可读的错误描述)。
- 可选地包含 `details` 字段，提供更详细的错误信息（例如，哪个字段校验失败及其原因）。

## 9. 安全性考量

- **传输安全**：所有API接口必须使用HTTPS。
- **认证安全**：
    - 签名机制防止请求被篡改。
    - API Key不应硬编码在客户端代码中，应由后端安全管理。
- **访问控制**：
    - IP白名单机制增强安全性。
    - 考虑API Key的权限范围，遵循最小权限原则。
- **数据安全**：
    - 对用户敏感数据（如手机号、邮箱）进行脱敏处理（如果需要在日志或非核心系统中展示）。
    - 防止数据泄露。
- **防攻击**：
    - 输入验证，防止SQL注入、XSS等。
    - 请求频率限制，防止DoS/DDoS攻击。
    - 时间戳校验，防止重放攻击。
- **审计**：记录所有API调用和关键操作，便于安全审计。

## 10. 演进与扩展

- **版本迭代**：通过API版本号管理接口的演进，确保向后兼容性。
- **数据格式扩展**：设计时考虑未来可能增加的字段，例如使用 `customFields` 结构允许外部系统传递自定义数据。
- **回调机制/Webhook**：对于长时间处理的异步任务，可以考虑引入Webhook机制，当数据处理完成后主动通知外部系统。 

---

## 文件 14: 后端-订单管理-后端开发文档.md

*文件大小：915 B*

---

### 订单管理模块后端开发文档

#### 模块概述

负责处理用户订单相关的流程，包括订单创建、支付、状态更新、查询、退款等。

#### 后端技术栈

- 主要技术：Spring Boot, MyBatis-Plus
- 数据库：MySQL
- 缓存：Redis

#### 核心实体与数据表

- 订单主表 (order)
- 订单项表 (order_item)
- 支付记录表 (payment_record)
- 退款记录表 (refund_record)
- 订单日志表 (order_log)

#### 主要API接口

- GET /api/orders: 获取订单列表
- GET /api/orders/{id}: 获取订单详情
- POST /api/orders: 创建新订单
- POST /api/orders/{id}/pay: 订单支付接口
- POST /api/orders/{id}/cancel: 取消订单
- POST /api/orders/{id}/refund: 申请退款

#### 开发注意事项

- 事务管理，确保订单、支付、库存等操作的原子性。
- 订单状态机的设计与实现。
- 支付回调处理。
- 幂等性考虑。 

---

## 文件 15: 后端-多租户管理-后端开发文档.md

*文件大小：1.64 KB*

---

### 多租户管理模块后端开发文档

#### 模块概述

负责支持平台的多租户架构，管理租户信息，确保租户之间的数据隔离和资源分配。

#### 后端技术栈

- 主要技术：Spring Boot, MyBatis-Plus (或ORM框架)
- 数据库：MySQL (支持多租户模式)

#### 核心实体与数据表

- 租户表 (tenant)
- 可能需要在其他业务表中增加租户ID字段 (tenant_id)

#### 主要API接口

*(注：多租户管理相关的核心API通常由平台管理员使用，对普通租户用户不可见)*

- GET /api/tenants: 获取租户列表
- POST /api/tenants: 创建新租户
- PUT /api/tenants/{id}: 更新租户信息
- DELETE /api/tenants/{id}: 删除租户

#### 开发注意事项

- **租户识别：** 如何在每个请求中识别当前操作属于哪个租户 (例如通过请求头、JWT Claim)。
- **数据隔离：** 实现租户数据的严格隔离。常见模式有：
    - Schema-per-tenant (每个租户一个数据库Schema)
    - Database-per-tenant (每个租户一个数据库)
    - Shared-schema, isolated-table (共享Schema，业务表含tenant_id字段，通过WHERE子句过滤)
    - *根据项目实际情况，当前采用共享Schema，业务表含tenant_id字段模式。*
- **ORM框架集成：** 配置MyBatis-Plus或其他ORM框架支持多租户字段的自动填充或过滤。
- **SQL注入风险：** 确保所有数据库操作都正确地包含了租户ID过滤条件，防止跨租户数据访问。
- **资源分配：** 管理不同租户的资源限制（如存储空间、请求频率等）。
- **租户生命周期：** 租户的创建、激活、暂停、删除流程。 

---

## 文件 16: 后端-工作台-内容多平台分发功能开发文档.md

*文件大小：14.44 KB*

---

# 存客宝工作台 - 内容多平台分发功能后端开发文档\n\n## 1. 模块概述\n\n内容多平台分发功能允许用户在存客宝工作台创建或编辑内容（如文章、图片、短视频等），并通过系统集成将内容一键分发到多个外部社交媒体或内容平台（如微信公众号、微博、抖音、小红书等）。后端模块负责内容管理、平台对接、分发任务调度、状态跟踪及回传。\n\n## 2. API接口设计\n\n### 2.1 创建待分发内容\n\n- **接口路径**：`/api/v1/workbench/content`\n- **请求方法**：`POST`\n- **接口说明**：创建一篇待分发的内容草稿。内容可以包含标题、正文、图片、视频等多种形式。\n- **权限:** `workbench:content:create`\n- **请求参数 (Request Body):**\n\n| 参数名   | 类型    | 是否必需 | 描述           | 示例值 |
|----------|--------|----------|----------------|--------|\
| title    | string | 是       | 内容标题       | \"我的营销干货分享\" |\
| contentType| string | 是       | 内容类型 (ARTICLE, IMAGE, VIDEO) | \"ARTICLE\" |\
| content  | object | 是       | 内容详情，具体结构根据contentType不同 | `{ \"body\": \"文章正文...\", \"images\": [\"url1\", \"url2\"] }` |\
| tags     | array<string> | 否 | 内容标签       | `[\"营销\", \"私域\"]` |\
| category | string | 否       | 内容分类       | \"行业分析\" |\
\n- **响应数据 (统一格式 `data` 字段):** 返回新创建的内容草稿信息。\n\n```json\n{\n  \"contentId\": 4001,\n  \"title\": \"我的营销干货分享\",\n  \"status\": \"DRAFT\", // DRAFT, READY, DISTRIBUTING, DISTRIBUTED, FAILED\n  \"createTime\": \"2023-10-26T15:00:00Z\"\n}\n```\n- **可能返回状态码:** 201 (创建成功), 400 (参数错误), 401, 403, 422, 500\n\n### 2.2 获取内容列表\n\n- **接口路径**：`/api/v1/workbench/content`\n- **请求方法**：`GET`\n- **接口说明**：获取用户创建的内容列表。支持分页、筛选和排序。\n- **权限:** `workbench:content:view`\n- **请求参数 (Query Parameters):**\n\n| 参数名   | 类型    | 是否必需 | 描述           | 示例值 |
|----------|--------|----------|----------------|--------|\
| status   | string | 否       | 按状态过滤     | \"DRAFT\" |\
| keyword  | string | 否       | 按标题或标签关键字搜索 | \"干货\" |\
| startTime| string | 否       | 创建时间开始 (ISO 8601) |        |\
| endTime  | string | 否       | 创建时间结束 (ISO 8601) |        |\
| page     | integer| 否       | 页码           | 1      |\
| size     | integer| 否       | 每页条数       | 10     |\n\n- **响应数据 (统一格式 `data` 字段):** 返回内容列表（支持分页）。\n\n```json\n{\n  \"records\": [\n    {\n      \"contentId\": 4001,\n      \"title\": \"我的营销干货分享\",\n      \"contentType\": \"ARTICLE\",\n      \"status\": \"DRAFT\",\n      \"createTime\": \"2023-10-26T15:00:00Z\",\n      \"updateTime\": \"2023-10-26T15:05:00Z\"\n    }\n    // ... 更多内容\n  ],\n  \"total\": 20,\n  \"size\": 10,\n  \"current\": 1,\n  \"pages\": 2\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n### 2.3 获取内容详情\n\n- **接口路径**：`/api/v1/workbench/content/{contentId}`\n- **请求方法**：`GET`\n- **接口说明**：获取指定内容草稿的详细信息。\n- **权限:** `workbench:content:view`\n- **请求参数 (Path Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 说明       | 示例值 |
|-----------|--------|----------|------------|--------|\
| contentId | integer | 是       | 内容ID     | 4001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回内容详情。\n\n```json\n{\n  \"contentId\": 4001,\n  \"title\": \"我的营销干货分享\",\n  \"contentType\": \"ARTICLE\",\n  \"content\": { \"body\": \"文章正文...\", \"images\": [\"url1\", \"url2\"] },\n  \"tags\": [\"营销\", \"私域\"],\n  \"category\": \"行业分析\",\n  \"status\": \"DRAFT\",\n  \"createTime\": \"2023-10-26T15:00:00Z\",\n  \"updateTime\": \"2023-10-26T15:05:00Z\"\n}\n```\n- **可能返回状态码:** 200, 401, 403, 404 (内容不存在), 500\n\n### 2.4 更新内容\n\n- **接口路径**：`/api/v1/workbench/content/{contentId}`\n- **请求方法**：`PUT`\n- **接口说明**：更新指定内容草稿的信息。\n- **权限:** `workbench:content:update`\n- **请求参数 (Path Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 说明       | 示例值 |
|-----------|--------|----------|------------|--------|\
| contentId | integer | 是       | 内容ID     | 4001   |\n\n- **请求体 (Request Body):** 结构与创建内容类似，可以只包含需要更新的字段。\n\n- **响应数据 (统一格式 `data` 字段):** 返回更新后的内容信息。\n\n```json\n{\n  \"contentId\": 4001,\n  \"title\": \"更新后的标题\",\n  \"updateTime\": \"2023-10-26T15:10:00Z\"\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 500\n\n### 2.5 删除内容\n\n- **接口路径**：`/api/v1/workbench/content/{contentId}`\n- **请求方法**：`DELETE`\n- **接口说明**：删除指定内容草稿。\n- **权限:** `workbench:content:delete`\n- **请求参数 (Path Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 说明       | 示例值 |
|-----------|--------|----------|------------|--------|\
| contentId | integer | 是       | 内容ID     | 4001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回成功信息。\n\n```json\n{\n  \"message\": \"内容删除成功\"\n}\n```\n- **可能返回状态码:** 200, 401, 403, 404, 500\n\n### 2.6 获取可分发平台列表\n\n- **接口路径**：`/api/v1/workbench/distribute/platforms`\n- **请求方法**：`GET`\n- **接口说明**：获取当前用户已授权并可用于内容分发的平台列表（如已绑定的微信公众号、抖音号等）。\n- **权限:** `workbench:distribute:platforms:view`\n- **请求参数 (Query Parameters):** 无\n\n- **响应数据 (统一格式 `data` 字段):** 返回可分发平台列表。\n\n```json\n[\n  {\n    \"platformId\": \"WECHAT_MP_1\",\n    \"platformName\": \"微信公众号 - 存客宝服务号\",\n    \"platformType\": \"WECHAT_MP\",\n    \"accountId\": \"mp_account_id_1\" // 关联的平台账号ID\n  },\n   {\n    \"platformId\": \"DOUYIN_USER_A\",\n    \"platformName\": \"抖音账号 - 卡若说\",\n    \"platformType\": \"DOUYIN\",\n    \"accountId\": \"douyin_user_id_A\"\n  }\n  // ... 更多平台\n]\n```\n- **可能返回状态码:** 200, 401, 403, 500\n\n### 2.7 发起内容分发任务\n\n- **接口路径**：`/api/v1/workbench/distribute`\n- **请求方法**：`POST`\n- **接口说明**：将指定内容分发到选定的多个平台。此接口通常只负责创建分发任务并返回任务ID，实际分发是异步进行的。\n- **权限:** `workbench:distribute:create`\n- **请求参数 (Request Body):**\n\n| 参数名      | 类型           | 是否必需 | 描述         | 示例值 |
|-------------|----------------|----------|--------------|--------|\
| contentId   | integer        | 是       | 待分发内容ID | 4001   |\
| platformIds | array<string>  | 是       | 目标平台ID列表 | `[\"WECHAT_MP_1\", \"DOUYIN_USER_A\"]` |\
| scheduledTime| string       | 否       | 定时发布时间 (ISO 8601)，立即发布则不传 | \"2023-10-26T16:00:00Z\" |\
\n- **响应数据 (统一格式 `data` 字段):** 返回分发任务信息。\n\n```json\n{\n  \"distributeTaskId\": 5001,\n  \"contentId\": 4001,\n  \"status\": \"PENDING\", // PENDING, PROCESSING, COMPLETED, PARTIAL_SUCCESS, FAILED\n  \"createTime\": \"2023-10-26T15:30:00Z\"\n}\n```\n- **可能返回状态码:** 202 (已接受处理), 400, 401, 403, 404 (内容或平台不存在), 422, 500\n\n### 2.8 查询分发任务状态及结果\n\n- **接口路径**：`/api/v1/workbench/distribute/tasks/{taskId}`\n- **请求方法**：`GET`\n- **接口说明**：查询指定分发任务的详细状态和每个平台的具体分发结果。\n- **权限:** `workbench:distribute:task:view`\n- **请求参数 (Path Parameters):**\n\n| 参数名   | 类型    | 是否必需 | 说明         | 示例值 |
|----------|--------|----------|--------------|--------|\
| taskId   | integer | 是       | 分发任务ID   | 5001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回分发任务详情。\n\n```json
{
  \"distributeTaskId\": 5001,\n  \"contentId\": 4001,\n  \"status\": \"PARTIAL_SUCCESS\",\n  \"createTime\": \"2023-10-26T15:30:00Z\",\n  \"updateTime\": \"2023-10-26T15:35:00Z\",\n  \"results\": [\n    {\n      \"platformId\": \"WECHAT_MP_1\",\n      \"status\": \"SUCCESS\", // SUCCESS, FAILED, PENDING, PROCESSING\n      \"platformContentId\": \"wx_article_id_abc\", // 平台返回的内容ID\n      \"platformContentUrl\": \"https://mp.weixin.qq.com/s/xxx\", // 平台内容链接\n      \"errorMessage\": null\n    },\n    {\n      \"platformId\": \"DOUYIN_USER_A\",\n      \"status\": \"FAILED\",\n      \"platformContentId\": null,\n      \"platformContentUrl\": null,\n      \"errorMessage\": \"抖音接口调用失败：敏感词过滤未通过\"\n    }\n  ]\n}\n```
- **可能返回状态码:** 200, 401, 403, 404, 500

## 3. 数据模型设计\n\n### 3.1 内容草稿表 `t_workbench_content`\n\n存储用户在工作台创建和编辑的内容草稿。\n\n| 字段名        | 类型         | 是否必需 | 说明             | 索引        |\n|--------------|--------------|----------|------------------|------------|\
| id           | BIGINT (PK)  | 是       | 主键             |            |\
| user_id      | BIGINT (FK)  | 是       | 创建用户ID       | Index      |\
| title        | VARCHAR(255) | 是       | 内容标题         | Index      |\
| content_type | VARCHAR(20)  | 是       | 内容类型 (ARTICLE, IMAGE, VIDEO) | Index |\
| content_data | JSON / TEXT  | 是       | 内容详情数据，根据类型不同 |            |\
| tags         | JSON / TEXT  | 否       | 内容标签列表 (JSON 数组) |            |\
| category     | VARCHAR(50)  | 否       | 内容分类         | Index      |\
| status       | VARCHAR(20)  | 是       | 状态 (DRAFT, READY, DISTRIBUTING, DISTRIBUTED, FAILED) | Index |\
| create_time  | DATETIME     | 是       | 创建时间         |            |\
| update_time  | DATETIME     | 是       | 更新时间         |            |\
\n### 3.2 内容分发任务表 `t_distribute_task`\n\n记录内容分发任务的基本信息。\n\n| 字段名        | 类型         | 是否必需 | 说明             | 索引        |\n|--------------|--------------|----------|------------------|------------|\
| id           | BIGINT (PK)  | 是       | 主键             |            |\
| user_id      | BIGINT (FK)  | 是       | 发起任务用户ID   | Index      |\
| content_id   | BIGINT (FK)  | 是       | 关联的内容草稿ID | Index      |\
| status       | VARCHAR(20)  | 是       | 任务状态 (PENDING, PROCESSING, COMPLETED, PARTIAL_SUCCESS, FAILED) | Index |\
| scheduled_time| DATETIME     | 否       | 定时发布时间     | Index      |\
| create_time  | DATETIME     | 是       | 创建时间         |            |\
| update_time  | DATETIME     | 是       | 更新时间         |            |\
\n### 3.3 分发结果详情表 `t_distribute_result`\n\n记录每个分发任务在每个平台的具体分发结果。\n\n| 字段名        | 类型         | 是否必需 | 说明               | 索引        |\n|--------------|--------------|----------|--------------------|------------|\
| id           | BIGINT (PK)  | 是       | 主键               |            |\
| task_id      | BIGINT (FK)  | 是       | 关联的分发任务ID   | Index      |\
| platform_id  | VARCHAR(50)  | 是       | 目标平台唯一标识   | Index      |\
| platform_name| VARCHAR(100) | 否       | 平台名称           |            |\
| platform_type| VARCHAR(50)  | 是       | 平台类型         | Index      |\
| account_id   | VARCHAR(100) | 是       | 关联的平台账号ID   | Index      |\
| status       | VARCHAR(20)  | 是       | 平台分发状态 (PENDING, PROCESSING, SUCCESS, FAILED) | Index |\
| platform_content_id| VARCHAR(255) | 否 | 平台返回的内容ID   |            |\
| platform_content_url| VARCHAR(500)| 否 | 平台内容链接       |            |\
| error_message| TEXT         | 否       | 分发失败错误信息   |            |\
| create_time  | DATETIME     | 是       | 创建时间           |            |\
| update_time  | DATETIME     | 是       | 更新时间           |            |\
\n## 4. 异常处理\n\n- `ContentNotFoundException`: 内容草稿不存在异常\n- `PlatformNotAuthorizedException`: 平台未授权或配置错误异常\n- `DistributeTaskCreationException`: 分发任务创建失败异常\n- `PlatformApiException`: 调用外部平台 API 异常\n- `DistributeFailedException`: 内容分发失败异常\n\n## 5. 开发注意事项和实现要点\n\n1.  **平台对接:**\n    - 需要针对每个目标平台（微信公众号、微博、抖音、小红书等）实现独立的适配器或服务，封装各自的 API 调用逻辑。\n    - 处理不同平台的内容格式要求、API 调用频率限制、内容审核规则等差异。\n    - 统一管理各个平台的授权信息（access_token, refresh_token等）。\n2.  **内容格式转换:**\n    - 设计灵活的内容格式转换机制，将存客宝内部的内容格式转换为各平台所需的格式。\n3.  **异步处理和任务调度:**\n    - 内容分发是异步过程。接收到分发请求后，将任务放入消息队列，由消费者异步执行实际的分发逻辑。\n    - 使用任务调度框架 (如 Quartz, XXL-Job) 处理定时分发任务。\n    - 跟踪每个分发任务在各平台的状态，并及时更新分发结果。\n4.  **统一内容管理:**\n    - `t_workbench_content` 表用于管理所有待分发的内容草稿。支持多种内容类型。\n5.  **错误处理和回传:**\n    - 捕获分发过程中可能出现的各种错误（如平台 API 调用失败、内容审核不通过），并记录到 `t_distribute_result` 表中。\n    - 将错误信息回传给前端，便于用户查看分发失败原因并进行处理。\n6.  **权限控制:**\n    - 对内容创建、查看、更新、删除、平台列表查询、发起分发任务、查询任务状态等接口进行权限控制。\n7.  **定时发布:**\n    - 支持设置定时发布时间。调度器负责在指定时间触发分发任务。\n8.  **可扩展性:**\n    - 设计易于扩展的架构，方便后续集成新的分发平台。\n\n--- 

---

## 文件 17: 后端-工作台-朋友圈同步功能开发文档.md

*文件大小：9.61 KB*

---

# 存客宝工作台 - 朋友圈同步功能后端开发文档\n\n## 1. 模块概述\n\n朋友圈同步功能旨在帮助用户将内容一键同步或定时发布到指定微信账号的朋友圈。后端模块负责微信账号授权管理、内容处理（如文本、图片、视频）、调用微信相关接口（如企业微信或第三方SDK提供的发布朋友圈能力）、发布任务调度及状态回传。\n\n## 2. API接口设计\n\n### 2.1 获取可同步朋友圈的微信账号列表\n\n- **接口路径**：`/api/v1/workbench/wechat/moments/accounts`\n- **请求方法**：`GET`\n- **接口说明**：获取当前用户已授权并可用于发布朋友圈的微信账号列表。这些账号可能是通过企业微信或第三方SDK集成的个人微信。\n- **权限:** `workbench:wechat:moments:accounts:view`\n- **请求参数 (Query Parameters):** 无\n\n- **响应数据 (统一格式 `data` 字段):** 返回微信账号列表。\n\n```json\n[\n  {\n    \"accountId\": \"wx_account_id_1\",\n    \"accountName\": \"微信账号 - 张三\",\n    \"accountType\": \"PERSONAL\", // PERSONAL, WEWORK\n    \"status\": \"ACTIVE\" // ACTIVE, OFFLINE, EXPIRED\n  },\n   {\n    \"accountId\": \"wework_user_id_A\",\n    \"accountName\": \"企业微信成员 - 李四\",\n    \"accountType\": \"WEWORK\",\n     \"status\": \"ACTIVE\"\n  }\n  // ... 更多账号\n]\n```\n- **可能返回状态码:** 200, 401, 403, 500\n\n### 2.2 发起朋友圈同步任务\n\n- **接口路径**：`/api/v1/workbench/wechat/moments/sync`\n- **请求方法**：`POST`\n- **接口说明**：将指定内容（可与内容多平台分发模块联动，或单独上传）同步到选定的微信账号朋友圈。此接口通常只负责创建同步任务，实际发布是异步进行的。\n- **权限:** `workbench:wechat:moments:sync:create`\n- **请求参数 (Request Body):**\n\n| 参数名        | 类型           | 是否必需 | 描述         | 示例值 |
|---------------|----------------|----------|--------------|--------|\
| contentId     | integer        | 否       | 关联的内容草稿ID (如果从内容库选择) | 4001 |\
| text          | string         | 否       | 朋友圈文本内容 (如果非内容库选择) | \"今天分享...\" |\
| mediaUrls     | array<string>  | 否       | 朋友圈媒体URL列表 (图片或短视频) | `[\"url1\", \"url2\"]` |\
| accountIds    | array<string>  | 是       | 目标微信账号ID列表 | `[\"wx_account_id_1\", \"wework_user_id_A\"]` |\
| scheduledTime | string       | 否       | 定时发布时间 (ISO 8601)，立即发布则不传 | \"2023-10-26T16:30:00Z\" |\
\n- **响应数据 (统一格式 `data` 字段):** 返回同步任务信息。\n\n```json\n{\n  \"syncTaskId\": 6001,\n  \"contentId\": 4001, // 或 null\n  \"status\": \"PENDING\", // PENDING, PROCESSING, COMPLETED, PARTIAL_SUCCESS, FAILED\n  \"createTime\": \"2023-10-26T16:00:00Z\"\n}\n```\n- **可能返回状态码:** 202 (已接受处理), 400, 401, 403, 404 (账号不存在), 422, 500\n\n### 2.3 查询朋友圈同步任务状态及结果\n\n- **接口路径**：`/api/v1/workbench/wechat/moments/tasks/{taskId}`\n- **请求方法**：`GET`\n- **接口说明**：查询指定朋友圈同步任务的详细状态和每个账号的发布结果。\n- **权限:** `workbench:wechat:moments:task:view`\n- **请求参数 (Path Parameters):**\n\n| 参数名   | 类型    | 是否必需 | 说明         | 示例值 |
|----------|--------|----------|--------------|--------|\
| taskId   | integer | 是       | 同步任务ID   | 6001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回同步任务详情。\n\n```json
{
  \"syncTaskId\": 6001,\n  \"contentId\": 4001,\n  \"status\": \"COMPLETED\",\n  \"createTime\": \"2023-10-26T16:00:00Z\",\n  \"updateTime\": \"2023-10-26T16:05:00Z\",\n  \"results\": [\n    {\n      \"accountId\": \"wx_account_id_1\",\n      \"status\": \"SUCCESS\", // SUCCESS, FAILED, PENDING, PROCESSING\n      \"momentId\": \"wx_moment_id_xyz\", // 平台返回的朋友圈ID\n      \"errorMessage\": null\n    },\n    {\n      \"accountId\": \"wework_user_id_A\",\n      \"status\": \"FAILED\",\n      \"errorMessage\": \"企业微信接口调用失败：内容包含敏感词\"\n    }\n  ]\n}\n```
- **可能返回状态码:** 200, 401, 403, 404, 500\n\n## 3. 数据模型设计\n\n### 3.1 微信账号关联表 `t_wechat_account`\n\n存储用户关联的微信账号信息，包括授权状态等。此表可能与其他模块（如微信号管理）共用或关联。\n\n| 字段名      | 类型         | 是否必需 | 说明             | 索引        |\n|------------|--------------|----------|------------------|------------|\
| id         | BIGINT (PK)  | 是       | 主键             |            |\
| user_id    | BIGINT (FK)  | 是       | 存客宝用户ID     | Index      |\
| account_id | VARCHAR(100) | 是       | 微信账号唯一标识 (如wxid, 企业微信成员id) | UNIQUE Index |\
| account_type| VARCHAR(20)  | 是       | 账号类型 (PERSONAL, WEWORK) | Index |\
| account_name| VARCHAR(100) | 否       | 账号昵称/名称    |            |\
| status     | VARCHAR(20)  | 是       | 状态 (ACTIVE, OFFLINE, EXPIRED) | Index |\
| auth_data  | JSON / TEXT  | 否       | 授权相关数据 (access_token, refresh_token等)，加密存储 |            |\
| create_time| DATETIME     | 是       | 创建时间         |            |\
| update_time| DATETIME     | 是       | 更新时间         |            |\
\n### 3.2 朋友圈同步任务表 `t_moment_sync_task`\n\n记录朋友圈同步任务的基本信息。\n\n| 字段名        | 类型         | 是否必需 | 说明             | 索引        |\n|--------------|--------------|----------|------------------|------------|\
| id           | BIGINT (PK)  | 是       | 主键             |            |\
| user_id      | BIGINT (FK)  | 是       | 发起任务用户ID   | Index      |\
| content_id   | BIGINT (FK)  | 否       | 关联的内容草稿ID | Index      |\
| text_content | TEXT         | 否       | 朋友圈文本内容   |            |\
| media_urls   | JSON / TEXT  | 否       | 媒体URL列表 (JSON 数组) |            |\
| status       | VARCHAR(20)  | 是       | 任务状态 (PENDING, PROCESSING, COMPLETED, PARTIAL_SUCCESS, FAILED) | Index |\
| scheduled_time| DATETIME     | 否       | 定时发布时间     | Index      |\
| create_time  | DATETIME     | 是       | 创建时间         |            |\
| update_time  | DATETIME     | 是       | 更新时间         |            |\
\n### 3.3 朋友圈同步结果详情表 `t_moment_sync_result`\n\n记录每个同步任务在每个微信账号上的具体发布结果。\n\n| 字段名      | 类型         | 是否必需 | 说明           | 索引        |\n|------------|--------------|----------|----------------|------------|\
| id         | BIGINT (PK)  | 是       | 主键           |            |\
| task_id    | BIGINT (FK)  | 是       | 关联的同步任务ID | Index      |\
| account_id | VARCHAR(100) | 是       | 目标微信账号ID | Index      |\
| status     | VARCHAR(20)  | 是       | 发布状态 (PENDING, PROCESSING, SUCCESS, FAILED) | Index |\
| moment_id  | VARCHAR(255) | 否       | 平台返回的朋友圈ID |            |\
| error_message| TEXT         | 否       | 发布失败错误信息 |            |\
| create_time| DATETIME     | 是       | 创建时间       |            |\
| update_time| DATETIME     | 是       | 更新时间       |            |\
\n## 4. 异常处理\n\n- `WechatAccountNotFoundException`: 微信账号不存在或未授权异常\n- `MomentSyncCreationException`: 朋友圈同步任务创建失败异常\n- `WechatApiException`: 调用微信接口异常\n- `MomentPublishFailedException`: 朋友圈发布失败异常\n\n## 5. 开发注意事项和实现要点\n\n1.  **微信接口集成:**\n    - 朋友圈同步依赖于微信提供的接口能力。对于个人微信，可能需要集成第三方SDK或使用企业微信的外部联系人朋友圈功能。对于企业微信，直接使用企业微信开放平台提供的接口。\n    - 熟悉相关接口的调用方式、参数要求和限制。\n2.  **账号授权管理:**\n    - 需要妥善管理用户授权的微信账号信息和授权凭证（access_token等），确保凭证的有效性，并处理过期和刷新逻辑。授权信息必须加密存储。\n3.  **内容处理:**\n    - 处理不同类型的内容（文本、图片、视频）在朋友圈的发布格式。\n    - 如果与内容多平台分发模块联动，需要能获取并解析内容库中的内容数据。\n4.  **异步处理和任务调度:**\n    - 朋友圈发布是异步过程。接收到同步请求后，将任务放入消息队列，由消费者异步执行实际的发布逻辑。\n    - 使用任务调度框架处理定时发布任务。\n    - 跟踪每个任务在各账号的发布状态，并及时更新结果。\n5.  **错误处理和回传:**\n    - 捕获发布过程中可能出现的各种错误（如微信接口调用失败、内容审核不通过），并记录到 `t_moment_sync_result` 表中。\n    - 将错误信息回传给前端，便于用户查看发布失败原因。\n6.  **权限控制:**\n    - 对账号列表查询、发起同步任务、查询任务状态等接口进行权限控制。\n7.  **定时发布:**\n    - 支持设置定时发布时间。调度器负责在指定时间触发发布任务。\n8.  **限制与风险:**\n    - 个人微信朋友圈发布通常有限制（如频率、内容），使用第三方SDK需了解其稳定性和合规性风险。\n    - 企业微信外部联系人朋友圈有企业微信的限制。\n    - 需要注意内容合规性，避免发布违规内容导致账号被封。\n\n--- 

---

## 文件 18: 后端-工作台-群发助手功能开发文档.md

*文件大小：13.69 KB*

---

# 存客宝工作台 - 群发助手功能后端开发文档\n\n## 1. 模块概述\n\n群发助手功能允许用户选择特定的客户群体（如标签、分组、个人），编辑消息内容（文本、图片、链接等），并通过指定的微信账号（如企业微信成员）进行批量发送。后端模块负责客户选择、消息内容管理、群发任务创建与调度、调用微信/第三方SDK接口进行发送、以及发送状态和结果的回传。\n\n## 2. API接口设计\n\n### 2.1 获取可用于群发的微信账号列表\n\n- **接口路径**：`/api/v1/workbench/wechat/group-send/accounts`\n- **请求方法**：`GET`\n- **接口说明**：获取当前用户已授权并可用于发起群发任务的微信账号列表。这些账号通常是企业微信成员账号。\n- **权限:** `workbench:wechat:group-send:accounts:view`\n- **请求参数 (Query Parameters):** 无\n\n- **响应数据 (统一格式 `data` 字段):** 返回微信账号列表。\n\n```json\n[\n  {\n    \"accountId\": \"wework_user_id_A\",\n    \"accountName\": \"企业微信成员 - 李四\",\n    \"accountType\": \"WEWORK\", // 目前主要支持 WEWORK\n    \"status\": \"ACTIVE\" // ACTIVE, OFFLINE, EXPIRED\n  },\n   {\n    \"accountId\": \"wework_user_id_B\",\n    \"accountName\": \"企业微信成员 - 王五\",\n    \"accountType\": \"WEWORK\",\n     \"status\": \"ACTIVE\"\n  }\n  // ... 更多账号\n]\n```\n- **可能返回状态码:** 200, 401, 403, 500\n\n### 2.2 获取客户标签/分组列表\n\n- **接口路径**：`/api/v1/workbench/customer/tags`\n- **请求方法**：`GET`\n- **接口说明**：获取用于筛选群发客户的标签列表。\n- **权限:** `workbench:customer:tags:view`\n- **请求参数 (Query Parameters):** 无\n\n- **响应数据 (统一格式 `data` 字段):** 返回客户标签列表。\n\n```json\n[\n  {\n    \"tagId\": 101,\n    \"tagName\": \"意向客户\",\n    \"customerCount\": 500 // 关联客户数\n  },\n   {\n    \"tagId\": 102,\n    \"tagName\": \"会员用户\",\n    \"customerCount\": 800\n  }\n  // ... 更多标签\n]\n```\n- **可能返回状态码:** 200, 401, 403, 500\n\n### 2.3 根据筛选条件获取客户列表（用于预览或二次确认）\n\n- **接口路径**：`/api/v1/workbench/customer/search`\n- **请求方法**：`POST` 或 `GET`\n- **接口说明**：根据标签、分组等条件筛选出目标客户列表。\n- **权限:** `workbench:customer:view`\n- **请求参数 (Request Body or Query Parameters):**\n\n| 参数名    | 类型           | 是否必需 | 描述           | 示例值 |
|-----------|----------------|----------|----------------|--------|\
| tagIds    | array<integer> | 否       | 按标签ID筛选   | `[101, 102]` |\
| groupIds  | array<integer> | 否       | 按分组ID筛选   | `[201]` |\
| keyword   | string         | 否       | 按客户名称/手机号/微信号关键字搜索 | \"张三\" |\
| page      | integer        | 否       | 页码           | 1      |\
| size      | integer        | 否       | 每页条数       | 10     |\n\n- **响应数据 (统一格式 `data` 字段):** 返回客户列表（支持分页）。\n\n```json\n{\n  \"records\": [\n    {\n      \"customerId\": 10001,\n      \"name\": \"张三\",\n      \"wechatId\": \"zhangsan_wx\",\n      \"phone\": \"138...\"\n    }\n    // ... 更多客户\n  ],\n  \"total\": 100,\n  \"size\": 10,\n  \"current\": 1,\n  \"pages\": 10\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n### 2.4 创建群发任务\n\n- **接口路径**：`/api/v1/workbench/group-send/tasks`\n- **请求方法**：`POST`\n- **接口说明**：创建一个群发任务。指定发送账号、目标客户（按标签/分组/客户ID列表）、消息内容及定时发送时间。\n- **权限:** `workbench:group-send:create`\n- **请求参数 (Request Body):**\n\n| 参数名        | 类型           | 是否必需 | 描述           | 示例值 |
|---------------|----------------|----------|----------------|--------|\
| senderAccountId| string         | 是       | 发起群发的微信账号ID | \"wework_user_id_A\" |\
| target        | object         | 是       | 目标客户选择条件 | `{ \"tagIds\": [101], \"customerIds\": [] }` |\
| messageContent| object         | 是       | 消息内容，支持多种类型 | `{ \"type\": \"TEXT\", \"data\": { \"text\": \"您好！\" } }` |\
| scheduledTime | string       | 否       | 定时发送时间 (ISO 8601)，立即发送则不传 | \"2023-10-26T17:00:00Z\" |\
| taskName      | string         | 否       | 任务名称（方便管理） | \"会员用户问候\" |\
\n- **响应数据 (统一格式 `data` 字段):** 返回新创建的群发任务信息。\n\n```json\n{\n  \"groupSendTaskId\": 7001,\n  \"taskName\": \"会员用户问候\",\n  \"status\": \"PENDING\", // PENDING, PROCESSING, COMPLETED, PARTIAL_SUCCESS, FAILED\n  \"createTime\": \"2023-10-26T16:40:00Z\"\n}\n```\n- **可能返回状态码:** 201 (创建成功), 400, 401, 403, 404 (账号或客户不存在), 422, 500\n\n### 2.5 查询群发任务列表\n\n- **接口路径**：`/api/v1/workbench/group-send/tasks`\n- **请求方法**：`GET`\n- **接口说明**：查询群发任务列表。支持分页、筛选和排序。\n- **权限:** `workbench:group-send:tasks:view`\n- **请求参数 (Query Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 描述           | 示例值 |
|-----------|--------|----------|----------------|--------|\
| status    | string | 否       | 按状态过滤     | \"PENDING\" |\
| taskName  | string | 否       | 按任务名称关键字搜索 | \"问候\" |\
| startTime | string | 否       | 创建时间开始 (ISO 8601) |        |\
| endTime   | string | 否       | 创建时间结束 (ISO 8601) |        |\
| page      | integer| 否       | 页码           | 1      |\
| size      | integer| 否       | 每页条数       | 10     |\n\n- **响应数据 (统一格式 `data` 字段):** 返回群发任务列表（支持分页）。\n\n```json\n{\n  \"records\": [\n    {\n      \"groupSendTaskId\": 7001,\n      \"taskName\": \"会员用户问候\",\n      \"senderAccountName\": \"企业微信成员 - 李四\",\n      \"targetCount\": 100, // 目标客户数\n      \"successCount\": 80, // 成功发送数\n      \"status\": \"PARTIAL_SUCCESS\",\n      \"scheduledTime\": \"2023-10-26T17:00:00Z\",\n      \"createTime\": \"2023-10-26T16:40:00Z\"\n    }\n    // ... 更多任务\n  ],\n  \"total\": 5,\n  \"size\": 10,\n  \"current\": 1,\n  \"pages\": 1\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n### 2.6 查询群发任务详情及发送结果\n\n- **接口路径**：`/api/v1/workbench/group-send/tasks/{taskId}`\n- **请求方法**：`GET`\n- **接口说明**：查询指定群发任务的详细信息及每个目标客户的发送结果。\n- **权限:** `workbench:group-send:task:view`\n- **请求参数 (Path Parameters):**\n\n| 参数名 | 类型    | 是否必需 | 说明         | 示例值 |
|--------|--------|----------|--------------|--------|\
| taskId | integer | 是       | 群发任务ID   | 7001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回群发任务详情。\n\n```json
{
  \"groupSendTaskId\": 7001,\n  \"taskName\": \"会员用户问候\",\n  \"senderAccount\": {\"accountId\": \"wework_user_id_A\", \"accountName\": \"企业微信成员 - 李四\"},\n  \"messageContent\": { \"type\": \"TEXT\", \"data\": { \"text\": \"您好！\" } },\n  \"target\": { \"tagIds\": [101], \"customerIds\": [] },\n  \"targetCount\": 100,\n  \"successCount\": 80,\n  \"failedCount\": 20,\n  \"status\": \"PARTIAL_SUCCESS\",\n  \"scheduledTime\": \"2023-10-26T17:00:00Z\",\n  \"createTime\": \"2023-10-26T16:40:00Z\",\n  \"updateTime\": \"2023-10-26T17:05:00Z\",\n  \"results\": [\n    {\n      \"customerId\": 10001,\n      \"customerName\": \"张三\",\n      \"status\": \"SUCCESS\", // SUCCESS, FAILED, PENDING\n      \"errorMessage\": null\n    },\n    {\n      \"customerId\": 10005,\n      \"customerName\": \"王二\",\n      \"status\": \"FAILED\",\n      \"errorMessage\": \"对方拒收或已删除\"\n    }\n    // ... 更多结果\n  ]\n}\n```
- **可能返回状态码:** 200, 401, 403, 404, 500\n\n## 3. 数据模型设计\n\n### 3.1 群发任务表 `t_group_send_task`\n\n记录群发任务的基本信息。\n\n| 字段名        | 类型         | 是否必需 | 说明             | 索引        |\n|--------------|--------------|----------|------------------|------------|\
| id           | BIGINT (PK)  | 是       | 主键             |            |\
| user_id      | BIGINT (FK)  | 是       | 发起任务用户ID   | Index      |\
| sender_account_id| VARCHAR(100) | 是       | 发送微信账号ID   | Index      |\
| task_name    | VARCHAR(100) | 否       | 任务名称         |            |\
| target_type  | VARCHAR(20)  | 是       | 目标类型 (TAG, GROUP, CUSTOMER_IDS) | Index |\
| target_ids   | JSON / TEXT  | 是       | 目标ID列表 (标签ID、分组ID或客户ID列表) |            |\
| message_content| JSON / TEXT  | 是       | 消息内容数据 (JSON) |            |\
| target_count | INTEGER      | 否       | 目标客户总数     |            |\
| success_count| INTEGER      | 否       | 成功发送客户数   |            |\
| failed_count | INTEGER      | 否       | 失败发送客户数   |            |\
| status       | VARCHAR(20)  | 是       | 任务状态 (PENDING, PROCESSING, COMPLETED, PARTIAL_SUCCESS, FAILED) | Index |\
| scheduled_time| DATETIME     | 否       | 定时发送时间     | Index      |\
| create_time  | DATETIME     | 是       | 创建时间         |            |\
| update_time  | DATETIME     | 是       | 更新时间         |            |\
\n### 3.2 群发结果详情表 `t_group_send_result`\n\n记录每个群发任务中每个目标客户的发送结果。\n\n| 字段名        | 类型         | 是否必需 | 说明           | 索引        |\n|--------------|--------------|----------|----------------|------------|\
| id           | BIGINT (PK)  | 是       | 主键           |            |\
| task_id      | BIGINT (FK)  | 是       | 关联的群发任务ID | Index      |\
| customer_id  | BIGINT (FK)  | 是       | 目标客户ID     | Index      |\
| status       | VARCHAR(20)  | 是       | 发送状态 (PENDING, PROCESSING, SUCCESS, FAILED) | Index |\
| error_message| TEXT         | 否       | 发送失败错误信息 |            |\
| create_time  | DATETIME     | 是       | 创建时间       |            |\
| update_time  | DATETIME     | 是       | 更新时间       |            |\
\n### 3.3 消息内容结构 (示例)\n\n消息内容可以使用 JSON 结构存储，支持多种类型：\n\n*   文本消息:\n    ```json\n    { \"type\": \"TEXT\", \"data\": { \"text\": \"您好！\" } }\n    ```\n*   图片消息:\n    ```json\n    { \"type\": \"IMAGE\", \"data\": { \"media_id\": \"uploaded_media_id\" } } // media_id 是调用微信接口上传图片后返回的ID\n    ```\n*   图文链接消息:\n    ```json\n    { \"type\": \"LINK\", \"data\": { \"title\": \"链接标题\", \"pic_url\": \"图片URL\", \"desc\": \"描述\", \"url\": \"链接URL\" } }\n    ```\n\n## 4. 异常处理\n\n- `SenderAccountNotFoundException`: 发起群发的微信账号不存在或未授权异常\n- `TargetCustomersEmptyException`: 目标客户列表为空异常\n- `MessageContentInvalidException`: 消息内容格式或类型无效异常\n- `GroupSendTaskCreationException`: 群发任务创建失败异常\n- `WechatApiException`: 调用微信/第三方接口异常\n- `CustomerSendFailedException`: 针对某个客户发送失败异常\n\n## 5. 开发注意事项和实现要点\n\n1.  **微信接口集成:**\n    - 群发功能通常依赖于企业微信客户联系功能中的群发接口。对于个人微信，可能需要集成第三方SDK来实现。\n    - 熟悉相关接口的调用方式、参数要求和限制（如发送频率、目标客户数限制、内容限制等）。\n2.  **客户筛选:**\n    - 需要与客户管理模块集成，能够根据标签、分组等条件准确筛选出目标客户。\n3.  **消息内容处理:**\n    - 支持多种消息类型（文本、图片、链接、小程序等），根据前端提交的结构进行校验和转换。\n    - 图片、文件等媒体需要提前上传到微信/第三方平台获取媒体ID。\n4.  **异步处理和任务调度:**\n    - 群发任务是批量操作，应采用异步处理，避免阻塞接口响应。接收到请求后，快速创建任务并放入消息队列。\n    - 使用任务调度框架处理定时群发任务。\n    - 消费者从队列获取任务，遍历目标客户，调用微信/第三方接口逐个或批量发送。\n5.  **发送状态跟踪与回传:**\n    - 及时获取每个客户的发送结果（成功、失败、原因），并更新到 `t_group_send_result` 表中。\n    - 统计任务的成功/失败客户数，更新 `t_group_send_task` 表的状态和计数。\n6.  **错误处理:**\n    - 捕获并处理发送过程中可能出现的各种错误（如接口调用失败、客户关系异常、内容违规等），记录错误信息，并更新任务和结果状态。\n7.  **权限控制:**\n    - 对账号列表查询、标签/分组列表查询、客户搜索、创建群发任务、查询任务列表及详情等接口进行权限控制。\n8.  **限制与合规:**\n    - 严格遵守微信平台的群发规则和限制，避免频繁发送或发送违规内容，导致账号被封或功能受限。\n    - 需要考虑不同类型账号（企业微信、个人微信SDK）的群发能力差异和限制。\n    - 尊重用户隐私，仅向获得授权的客户发送消息。\n9.  **任务管理界面:**\n    - 后端需要提供接口支持前端展示群发任务列表、任务详情（包括每个客户的发送结果和原因），便于用户查看和管理。\n\n--- 

---

## 文件 19: 后端-工作台-AI助手功能开发文档.md

*文件大小：8.75 KB*

---

# 存客宝工作台 - AI助手功能后端开发文档\n\n## 1. 模块概述\n\nAI助手功能为用户提供智能辅助，可能包括但不限于：内容创作建议、智能回复推荐、数据分析摘要、常见问题解答等。后端模块负责集成不同的AI模型和能力，接收用户请求，调用相应的AI服务进行处理，并返回结果。此模块将依赖于其他模块（如知识库、数据统计、客户管理）提供的数据。\n\n## 2. API接口设计\n\n### 2.1 获取AI助手能力列表\n\n- **接口路径**：`/api/v1/workbench/ai-assistant/capabilities`\n- **请求方法**：`GET`\n- **接口说明**：获取AI助手当前支持的能力列表，供前端展示和引导用户使用。\n- **权限:** `workbench:ai-assistant:capabilities:view`\n- **请求参数 (Query Parameters):** 无\n\n- **响应数据 (统一格式 `data` 字段):** 返回能力列表。\n\n```json\n[\n  {\n    \"capabilityId\": \"CONTENT_SUGGESTION\",\n    \"capabilityName\": \"内容创作建议\",\n    \"description\": \"根据您的输入和热点提供内容创意和大纲\",\n    \"icon\": \"icon_url\",\n    \"parameters\": [ // 需要用户输入或选择的参数\n      {\n        \"paramName\": \"topic\",\n        \"paramType\": \"string\",\n        \"required\": true,\n        \"description\": \"请提供内容主题\"\n      },\n       {\n        \"paramName\": \"platform\",\n        \"paramType\": \"enum\",\n        \"options\": [\"抖音\", \"小红书\", \"微信公众号\"],\n        \"required\": false,\n        \"description\": \"目标发布平台\"\n      }\n    ]\n  },\n   {\n    \"capabilityId\": \"SMART_REPLY\",\n    \"capabilityName\": \"智能回复推荐\",\n    \"description\": \"根据对话上下文生成回复建议\",\n    \"icon\": \"icon_url\",\n    \"parameters\": [\n       {\n        \"paramName\": \"context\",\n        \"paramType\": \"string\",\n        \"required\": true,\n        \"description\": \"请输入对话上下文\"\n      }\n    ]\n  }\n  // ... 更多能力\n]\n```\n- **可能返回状态码:** 200, 401, 403, 500\n\n### 2.2 调用AI助手能力\n\n- **接口路径**：`/api/v1/workbench/ai-assistant/invoke/{capabilityId}`\n- **请求方法**：`POST`\n- **接口说明**：根据用户选择的能力ID和提供的参数，调用后端AI服务进行处理。\n- **权限:** `workbench:ai-assistant:invoke:{capabilityId}` (细粒度权限) 或 `workbench:ai-assistant:invoke`\n- **请求参数 (Path Parameters):**\n\n| 参数名       | 类型   | 是否必需 | 说明           | 示例值 |
|--------------|--------|----------|----------------|--------|\
| capabilityId | string | 是       | AI助手能力ID   | \"CONTENT_SUGGESTION\" |\n\n- **请求体 (Request Body):** 包含调用该能力所需的参数，结构与 `capabilities` 接口返回的 `parameters` 定义对应。\n\n```json\n{\n  \"parameters\": {\n    \"topic\": \"私域流量运营\",\n    \"platform\": \"抖音\"\n  }\n}\n```\n- **响应数据 (统一格式 `data` 字段):** 返回AI处理结果。结果结构根据 `capabilityId` 不同而异。\n\n```json\n{\n  \"resultType\": \"text\", // text, json, html, image_url, etc.\n  \"data\": \"这是一篇关于私域流量运营的抖音内容大纲：...\" // 具体的AI生成内容\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 404 (能力不存在), 422 (参数错误), 500 (AI服务调用失败)\n\n### 2.3 获取AI助手对话历史（可选）\n\n- **接口路径**：`/api/v1/workbench/ai-assistant/history`\n- **请求方法**：`GET`\n- **接口说明**：获取用户与AI助手的交互历史记录。\n- **权限:** `workbench:ai-assistant:history:view`\n- **请求参数 (Query Parameters):**\n\n| 参数名   | 类型    | 是否必需 | 描述       | 示例值 |
|----------|--------|----------|------------|--------|\
| capabilityId| string| 否       | 按能力过滤 | \"SMART_REPLY\" |\
| startTime| string | 否       | 时间开始   |        |\
| endTime  | string | 否       | 时间结束   |        |\
| page     | integer| 否       | 页码       | 1      |\
| size     | integer| 否       | 每页条数   | 10     |\n\n- **响应数据 (统一格式 `data` 字段):** 返回历史记录列表。\n\n```json\n{\n  \"records\": [\n    {\n      \"historyId\": 9001,\n      \"capabilityId\": \"CONTENT_SUGGESTION\",\n      \"request\": {\"topic\": \"私域流量运营\"},\n      \"response\": {\"resultType\": \"text\", \"data\": \"...\"},\n      \"requestTime\": \"2023-10-26T18:30:00Z\"\n    }\n    // ... 更多记录\n  ],\n  \"total\": 100,\n  \"size\": 10,\n  \"current\": 1,\n  \"pages\": 10\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n## 3. 数据模型设计\n\n### 3.1 AI助手能力配置表 `t_ai_capability_config`\n\n存储AI助手的各种能力配置信息。\n\n| 字段名         | 类型         | 是否必需 | 说明             | 索引        |\n|---------------|--------------|----------|------------------|------------|\
| id            | BIGINT (PK)  | 是       | 主键             |            |\
| capability_id | VARCHAR(50)  | 是       | 能力唯一标识ID   | UNIQUE Index |\
| capability_name| VARCHAR(100) | 是       | 能力名称         |            |\
| description   | VARCHAR(500) | 否       | 能力描述         |            |\
| icon_url      | VARCHAR(255) | 否       | 能力图标URL      |            |\
| parameters    | JSON / TEXT  | 否       | 参数定义 (JSON 数组) |            |\
| backend_service| VARCHAR(100) | 是       | 关联的后端服务标识 | Index      |\
| status        | VARCHAR(20)  | 是       | 状态 (ACTIVE, INACTIVE) | Index |\
| create_time   | DATETIME     | 是       | 创建时间         |            |\
| update_time   | DATETIME     | 是       | 更新时间         |            |\
\n### 3.2 AI助手交互历史表 `t_ai_assistant_history`\n\n存储用户与AI助手的每次交互记录（请求和响应）。\n\n| 字段名         | 类型         | 是否必需 | 说明             | 索引        |\n|---------------|--------------|----------|------------------|------------|\
| id            | BIGINT (PK)  | 是       | 主键             |            |\
| user_id       | BIGINT (FK)  | 是       | 用户ID           | Index      |\
| capability_id | VARCHAR(50)  | 是       | 关联的能力ID     | Index      |\
| request_data  | JSON / TEXT  | 是       | 用户请求数据 (JSON)|            |\
| response_data | JSON / TEXT  | 否       | AI响应数据 (JSON)  |            |\
| status        | VARCHAR(20)  | 是       | 处理状态 (SUCCESS, FAILED) | Index |\
| error_message | TEXT         | 否       | 失败原因         |            |\
| request_time  | DATETIME     | 是       | 请求时间         | Index      |\
| response_time | DATETIME     | 否       | 响应时间         |            |\
\n## 4. 异常处理\n\n- `CapabilityNotFoundException`: 指定的AI助手能力不存在异常\n- `InvalidCapabilityParametersException`: 调用能力时提供的参数无效异常\n- `AiServiceInvocationException`: 调用后端AI服务失败异常\n- `AiAssistantHistoryQueryException`: 查询历史记录异常\n- `InsufficientPermissionsException`: 权限不足异常\n\n## 5. 开发注意事项和实现要点\n\n1.  **AI服务集成层:**\n    - 需要建立一个AI服务集成层，负责对接不同的AI模型或第三方AI服务提供商（如OpenAI, 腾讯云、阿里云的LLM/NLP/CV服务）。\n    - 封装底层AI服务的调用细节，向上层提供统一的调用接口。\n2.  **能力路由和分发:**\n    - 根据 `capabilityId` 将用户请求路由到对应的后端AI服务或处理逻辑。\n3.  **数据传递和格式:**\n    - 确保用户输入的参数能正确传递给后端AI服务。\n    - 处理不同AI服务返回结果的格式差异，转换为统一的响应结构。\n4.  **异步处理:**\n    - 某些AI能力（如复杂内容生成）可能耗时较长，可以考虑异步处理，提供任务ID，前端通过轮询获取结果。\n5.  **错误处理和回传:**\n    - 捕获调用AI服务过程中的各种错误（连接超时、服务内部错误、内容违规等），并返回清晰的错误信息给前端。\n6.  **权限控制:**\n    - 对获取能力列表和调用具体能力进行权限控制。某些高级能力可能需要特定用户权限。\n7.  **成本控制:**\n    - 调用外部AI服务会产生费用，需要监控调用量，并考虑成本优化策略（如使用更经济的模型、缓存常见结果）。\n8.  **日志记录:**\n    - 记录AI助手的使用日志，包括用户、调用的能力、参数、结果（摘要）和耗时，用于监控和分析。\n9.  **与中台知识库集成:**\n    - 如果AI助手需要基于企业知识库回答问题或生成内容，需要调用知识库模块提供的搜索和问答接口。\n\n--- 

---

## 文件 20: 后端-工作台功能实现文档.md

*文件大小：24.90 KB*

---

# 存客宝工作台功能实现文档

## 1. 模块概述

工作台模块是存客宝私域流量运营平台的核心操作中心，提供内容管理、社交媒体互动、自动化任务等功能，帮助运营人员高效管理私域客户资产。本模块基于Spring Boot实现，采用微服务架构设计，支持内容多平台分发、朋友圈同步、群发助手、群同步、自动点赞、自动建群、AI助手等多种功能。

### 1.1 核心功能

- 内容多平台分发管理
- 朋友圈自动同步与互动
- 群发助手与消息模板管理
- 微信群同步与管理
- 自动点赞与互动增强
- 自动建群与群管理
- AI助手内容生成与优化

## 2. 技术架构

- **核心框架**：Spring Boot 2.7.5 + Spring Cloud
- **数据访问**：MyBatis-Plus 3.5.2
- **数据库**：MySQL 8.0
- **缓存**：Redis
- **消息队列**：RocketMQ（用于异步任务处理）
- **定时任务**：Spring Task + XXL-Job
- **AI集成**：FastAPI（Python服务集成）
- **设备控制**：自研WebSocket协议

## 3. 数据模型设计

### 3.1 核心实体关系

```
内容(Content) --> 内容分发(ContentDistribution) --> 渠道(Channel)
          |
          v
素材(Material) --> 素材分类(MaterialCategory)
          |
          v
消息模板(MessageTemplate) --> 消息任务(MessageTask)
          |
          v
设备(Device) --> 设备状态(DeviceStatus)
          |
          v
群组(Group) --> 群成员(GroupMember)
```

### 3.2 主要数据表

| 表名                       | 说明                      | 关键字段                    |
|---------------------------|--------------------------|----------------------------|
| t_content                 | 内容表                    | id, title, body, type, status |
| t_content_distribution    | 内容分发表                | id, content_id, channel_id, status |
| t_material                | 素材表                    | id, name, type, url, category_id |
| t_material_category       | 素材分类表                | id, name, parent_id        |
| t_message_template        | 消息模板表                | id, name, content, variables |
| t_message_task            | 消息任务表                | id, template_id, status, scheduled_time |
| t_device                  | 设备表                    | id, name, type, status, wechat_id |
| t_group                   | 群组表                    | id, name, owner_id, member_count |
| t_group_member            | 群成员表                  | id, group_id, member_id, join_time |

## 4. API接口设计

### 4.1 内容多平台分发接口

#### 4.1.1 创建内容

- **接口路径**：`/api/v1/contents`
- **请求方法**：`POST`
- **接口说明**：创建内容，可同时设置分发渠道
- **请求参数**：

```json
{
  "title": "七夕营销活动攻略",
  "body": "## 七夕活动方案\n1. 优惠券发放\n2. 产品套装促销\n3. 社交媒体互动话题",
  "type": "ARTICLE",
  "materials": [
    {
      "id": 1001,
      "type": "IMAGE"
    }
  ],
  "tags": ["营销", "节日", "七夕"],
  "distribution": {
    "channels": ["WECHAT_MOMENTS", "WECHAT_OFFICIAL", "DOUYIN"],
    "scheduledTime": "2023-08-15T10:00:00",
    "status": "DRAFT"
  }
}
```

- **响应结果**：

```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "id": 5001,
    "title": "七夕营销活动攻略",
    "status": "DRAFT",
    "createTime": "2023-08-01T14:30:00",
    "distribution": {
      "channels": [
        {
          "id": 1,
          "name": "微信朋友圈",
          "status": "PENDING"
        },
        {
          "id": 2,
          "name": "微信公众号",
          "status": "PENDING"
        },
        {
          "id": 3,
          "name": "抖音",
          "status": "PENDING"
        }
      ],
      "scheduledTime": "2023-08-15T10:00:00"
    }
  },
  "timestamp": 1628247972123
}
```

#### 4.1.2 获取内容列表

- **接口路径**：`/api/v1/contents`
- **请求方法**：`GET`
- **接口说明**：获取内容列表，支持多条件查询和分页
- **请求参数**：

| 参数名      | 类型    | 必填 | 描述                  | 示例值           |
|------------|--------|-----|----------------------|-----------------|
| title      | string | 否  | 标题关键字            | 七夕             |
| type       | string | 否  | 内容类型              | ARTICLE         |
| status     | string | 否  | 状态                  | DRAFT/PUBLISHED |
| tag        | string | 否  | 标签                  | 营销             |
| startTime  | string | 否  | 创建开始时间          | 2023-08-01      |
| endTime    | string | 否  | 创建结束时间          | 2023-08-30      |
| page       | int    | 否  | 页码                  | 1               |
| size       | int    | 否  | 每页条数              | 10              |

#### 4.1.3 发布内容

- **接口路径**：`/api/v1/contents/{id}/publish`
- **请求方法**：`POST`
- **接口说明**：发布内容到指定渠道
- **请求参数**：

```json
{
  "channels": ["WECHAT_MOMENTS", "WECHAT_OFFICIAL"],
  "now": true
}
```

### 4.2 朋友圈同步接口

#### 4.2.1 创建朋友圈同步任务

- **接口路径**：`/api/v1/wechat/moments/tasks`
- **请求方法**：`POST`
- **接口说明**：创建朋友圈同步任务，支持定时发布
- **请求参数**：

```json
{
  "content": "七夕将至，我们推出了限时优惠活动，戳链接了解详情 👉 https://example.com/promo",
  "images": [
    {
      "materialId": 1001,
      "url": "https://example.com/images/promo1.jpg"
    },
    {
      "materialId": 1002,
      "url": "https://example.com/images/promo2.jpg"
    }
  ],
  "devices": [1, 2, 3],
  "scheduledTime": "2023-08-15T10:00:00",
  "visibleTo": "ALL",
  "autoLike": true,
  "autoComment": true,
  "commentTexts": ["太赞了！", "好漂亮！", "喜欢这个！"]
}
```

- **响应结果**：

```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "taskId": 10001,
    "status": "SCHEDULED",
    "scheduledTime": "2023-08-15T10:00:00",
    "devices": [
      {
        "id": 1,
        "name": "iPhone 13",
        "status": "ONLINE"
      },
      {
        "id": 2,
        "name": "OPPO Find X5",
        "status": "ONLINE"
      },
      {
        "id": 3,
        "name": "Redmi Note 11",
        "status": "OFFLINE"
      }
    ]
  },
  "timestamp": 1628247972123
}
```

#### 4.2.2 获取朋友圈同步任务列表

- **接口路径**：`/api/v1/wechat/moments/tasks`
- **请求方法**：`GET`
- **接口说明**：获取朋友圈同步任务列表，支持多条件查询和分页
- **请求参数**：

| 参数名      | 类型    | 必填 | 描述                  | 示例值           |
|------------|--------|-----|----------------------|-----------------|
| status     | string | 否  | 任务状态              | SCHEDULED/PROCESSING/COMPLETED/FAILED |
| deviceId   | int    | 否  | 设备ID                | 1               |
| startTime  | string | 否  | 开始时间              | 2023-08-01      |
| endTime    | string | 否  | 结束时间              | 2023-08-30      |
| page       | int    | 否  | 页码                  | 1               |
| size       | int    | 否  | 每页条数              | 10              |

### 4.3 群发助手接口

#### 4.3.1 创建消息模板

- **接口路径**：`/api/v1/message/templates`
- **请求方法**：`POST`
- **接口说明**：创建消息模板，用于群发消息
- **请求参数**：

```json
{
  "name": "七夕促销通知",
  "type": "TEXT_WITH_IMAGE",
  "content": "亲爱的{nickname}，七夕将至，我们特别推出了{product}限时7折优惠，仅限3天，先到先得！详情请看图片👇",
  "variables": ["nickname", "product"],
  "materialIds": [1001, 1002]
}
```

#### 4.3.2 创建群发任务

- **接口路径**：`/api/v1/message/tasks`
- **请求方法**：`POST`
- **接口说明**：创建群发任务，支持客户分组和定时发送
- **请求参数**：

```json
{
  "templateId": 2001,
  "name": "七夕促销群发",
  "receivers": {
    "type": "TAG", // ALL/TAG/GROUP/CUSTOMERS
    "tagIds": [101, 102], // 标签：意向客户、高消费
    "groupIds": [], // 群组ID
    "customerIds": [] // 指定客户ID
  },
  "variables": {
    "product": "尊享会员"
  },
  "devices": [1, 2, 3],
  "scheduledTime": "2023-08-15T09:00:00",
  "intervalSeconds": 5, // 发送间隔，避免被封
  "batchSize": 50 // 每批发送数量
}
```

### 4.4 自动点赞与互动接口

#### 4.4.1 创建自动点赞任务

- **接口路径**：`/api/v1/wechat/interaction/like`
- **请求方法**：`POST`
- **接口说明**：创建自动点赞任务
- **请求参数**：

```json
{
  "devices": [1, 2, 3],
  "frequency": "DAILY", // ONCE/DAILY/WEEKLY
  "targetType": "ALL_CONTACTS", // ALL_CONTACTS/TAGS/GROUPS
  "tagIds": [101, 102],
  "groupIds": [],
  "maxPerDay": 20, // 每天最大点赞数量
  "timeRange": {
    "start": "09:00:00",
    "end": "21:00:00"
  },
  "active": true
}
```

### 4.5 自动建群接口

#### 4.5.1 创建建群任务

- **接口路径**：`/api/v1/wechat/group/create`
- **请求方法**：`POST`
- **接口说明**：创建自动建群任务
- **请求参数**：

```json
{
  "name": "七夕活动交流群",
  "devices": [1],
  "members": {
    "type": "TAG", // TAG/CUSTOMERS
    "tagIds": [101, 102],
    "customerIds": []
  },
  "welcome": "欢迎加入七夕活动交流群，这里会发布最新的活动信息和优惠券！",
  "scheduledTime": "2023-08-10T14:00:00",
  "maxMembers": 100
}
```

### 4.6 AI助手接口

#### 4.6.1 生成内容

- **接口路径**：`/api/v1/ai/generate/content`
- **请求方法**：`POST`
- **接口说明**：使用AI生成内容
- **请求参数**：

```json
{
  "prompt": "请生成一篇关于七夕节的营销文案，包含促销信息和感情诉求",
  "type": "ARTICLE", // ARTICLE/MOMENTS/MESSAGE
  "length": "MEDIUM", // SHORT/MEDIUM/LONG
  "tone": "WARM", // PROFESSIONAL/WARM/HUMOROUS
  "keywords": ["七夕", "促销", "礼物", "爱情"],
  "includeImage": true
}
```

- **响应结果**：

```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "title": "爱的告白，从一份走心的七夕礼物开始",
    "content": "...(生成的内容)...",
    "suggestions": [
      "增加产品具体折扣信息",
      "添加促销截止日期增加紧迫感"
    ],
    "imageUrl": "https://example.com/images/ai_generated_1.jpg"
  },
  "timestamp": 1628247972123
}
```

## 5. 服务实现

### 5.1 内容分发服务

```java
@Service
@Slf4j
public class ContentDistributionServiceImpl implements ContentDistributionService {

    @Autowired
    private ContentRepository contentRepository;
    
    @Autowired
    private DistributionRepository distributionRepository;
    
    @Autowired
    private ChannelService channelService;
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    @Override
    @Transactional
    public ContentDistributionVO createDistribution(Long contentId, ContentDistributionDTO dto) {
        log.info("Creating distribution for content: {}", contentId);
        
        // 1. 验证内容是否存在
        Content content = contentRepository.findById(contentId)
                .orElseThrow(() -> new ContentNotFoundException("Content not found: " + contentId));
        
        // 2. 创建分发记录
        List<ContentDistribution> distributions = new ArrayList<>();
        
        for (String channelCode : dto.getChannels()) {
            Channel channel = channelService.getByCode(channelCode);
            
            ContentDistribution distribution = new ContentDistribution();
            distribution.setContentId(contentId);
            distribution.setChannelId(channel.getId());
            distribution.setStatus(DistributionStatus.PENDING);
            distribution.setScheduledTime(dto.getScheduledTime());
            
            distributions.add(distribution);
        }
        
        List<ContentDistribution> savedDistributions = distributionRepository.saveAll(distributions);
        
        // 3. 如果是立即发布，发送消息到队列处理
        if (dto.isPublishNow()) {
            for (ContentDistribution distribution : savedDistributions) {
                sendDistributionMessage(distribution);
            }
        }
        
        // 4. 返回结果
        return buildDistributionVO(content, savedDistributions);
    }
    
    @Override
    public void processScheduledDistributions() {
        log.info("Processing scheduled distributions");
        
        // 查找所有已到发布时间但尚未发布的分发记录
        Date now = new Date();
        List<ContentDistribution> distributions = distributionRepository
                .findByStatusAndScheduledTimeBefore(DistributionStatus.PENDING, now);
        
        for (ContentDistribution distribution : distributions) {
            sendDistributionMessage(distribution);
            
            // 更新状态为处理中
            distribution.setStatus(DistributionStatus.PROCESSING);
            distributionRepository.save(distribution);
        }
    }
    
    private void sendDistributionMessage(ContentDistribution distribution) {
        DistributionMessage message = new DistributionMessage();
        message.setDistributionId(distribution.getId());
        message.setContentId(distribution.getContentId());
        message.setChannelId(distribution.getChannelId());
        
        rocketMQTemplate.convertAndSend(
            "content-distribution-topic",
            message
        );
    }
    
    private ContentDistributionVO buildDistributionVO(Content content, List<ContentDistribution> distributions) {
        // 构建返回VO对象
    }
}
```

### 5.2 朋友圈同步服务

```java
@Service
@Slf4j
public class MomentsSyncServiceImpl implements MomentsSyncService {

    @Autowired
    private MomentsTaskRepository taskRepository;
    
    @Autowired
    private DeviceService deviceService;
    
    @Autowired
    private MaterialService materialService;
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    @Autowired
    private TaskScheduler taskScheduler;

    @Override
    @Transactional
    public MomentsTaskVO createMomentsTask(MomentsTaskDTO dto) {
        log.info("Creating moments sync task");
        
        // 1. 验证设备状态
        List<Device> devices = deviceService.getDevicesByIds(dto.getDevices());
        validateDevices(devices);
        
        // 2. 创建任务记录
        MomentsTask task = new MomentsTask();
        task.setContent(dto.getContent());
        task.setScheduledTime(dto.getScheduledTime());
        task.setVisibleTo(dto.getVisibleTo());
        task.setAutoLike(dto.isAutoLike());
        task.setAutoComment(dto.isAutoComment());
        task.setCommentTexts(String.join("|", dto.getCommentTexts()));
        task.setStatus(MomentsTaskStatus.SCHEDULED);
        
        // 3. 保存任务和关联信息
        MomentsTask savedTask = taskRepository.save(task);
        
        // 4. 保存图片关联
        saveMomentsImages(savedTask.getId(), dto.getImages());
        
        // 5. 保存设备关联
        saveMomentsDevices(savedTask.getId(), dto.getDevices());
        
        // 6. 如果是立即执行的任务，触发执行
        if (dto.getScheduledTime() == null || dto.getScheduledTime().before(new Date())) {
            executeMomentsTask(savedTask.getId());
        } else {
            // 安排定时任务
            scheduleMomentsTask(savedTask);
        }
        
        // 7. 返回结果
        return buildMomentsTaskVO(savedTask, devices);
    }
    
    @Override
    public void executeMomentsTask(Long taskId) {
        log.info("Executing moments task: {}", taskId);
        
        MomentsTask task = taskRepository.findById(taskId)
                .orElseThrow(() -> new TaskNotFoundException("Moments task not found: " + taskId));
        
        // 更新状态为处理中
        task.setStatus(MomentsTaskStatus.PROCESSING);
        taskRepository.save(task);
        
        // 获取关联设备
        List<Long> deviceIds = getMomentsTaskDevices(taskId);
        
        // 发送消息到队列处理
        MomentsExecutionMessage message = new MomentsExecutionMessage();
        message.setTaskId(taskId);
        message.setDeviceIds(deviceIds);
        
        rocketMQTemplate.convertAndSend(
            "moments-execution-topic",
            message
        );
    }
    
    private void validateDevices(List<Device> devices) {
        // 验证设备状态逻辑
    }
    
    private void saveMomentsImages(Long taskId, List<MomentsImageDTO> images) {
        // 保存图片关联逻辑
    }
    
    private void saveMomentsDevices(Long taskId, List<Long> deviceIds) {
        // 保存设备关联逻辑
    }
    
    private void scheduleMomentsTask(MomentsTask task) {
        // 安排定时任务逻辑
        taskScheduler.schedule(
            () -> executeMomentsTask(task.getId()),
            task.getScheduledTime()
        );
    }
}
```

### 5.3 设备控制服务

```java
@Service
@Slf4j
public class DeviceControlServiceImpl implements DeviceControlService {

    @Autowired
    private DeviceRepository deviceRepository;
    
    @Autowired
    private DeviceSessionRegistry sessionRegistry;
    
    @Override
    public DeviceCommandResult executeCommand(Long deviceId, DeviceCommand command) {
        log.info("Executing command {} on device {}", command.getType(), deviceId);
        
        // 1. 检查设备状态
        Device device = deviceRepository.findById(deviceId)
                .orElseThrow(() -> new DeviceNotFoundException("Device not found: " + deviceId));
                
        if (device.getStatus() != DeviceStatus.ONLINE) {
            throw new DeviceOfflineException("Device is offline: " + deviceId);
        }
        
        // 2. 获取设备会话
        DeviceSession session = sessionRegistry.getSession(deviceId);
        if (session == null) {
            throw new DeviceSessionNotFoundException("Device session not found: " + deviceId);
        }
        
        // 3. 发送命令到设备
        DeviceCommandResult result = null;
        try {
            // 构建命令
            String commandJson = buildCommandJson(command);
            
            // 发送命令
            String responseJson = session.sendCommand(commandJson);
            
            // 解析结果
            result = parseCommandResult(responseJson);
        } catch (Exception e) {
            log.error("Failed to execute command on device: " + deviceId, e);
            throw new DeviceCommandException("Command execution failed", e);
        }
        
        return result;
    }
    
    @Override
    public List<DeviceStatusVO> getDevicesStatus(List<Long> deviceIds) {
        // 获取设备状态逻辑
    }
    
    private String buildCommandJson(DeviceCommand command) {
        // 构建命令JSON
    }
    
    private DeviceCommandResult parseCommandResult(String responseJson) {
        // 解析命令结果
    }
}
```

### 5.4 AI内容生成服务

```java
@Service
@Slf4j
public class AiContentServiceImpl implements AiContentService {

    @Value("${ai.service.url}")
    private String aiServiceUrl;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private MaterialService materialService;

    @Override
    public AiGeneratedContentVO generateContent(AiContentGenerationDTO dto) {
        log.info("Generating AI content for prompt: {}", dto.getPrompt());
        
        // 1. 构建请求参数
        Map<String, Object> requestParams = new HashMap<>();
        requestParams.put("prompt", dto.getPrompt());
        requestParams.put("type", dto.getType().name());
        requestParams.put("length", dto.getLength().name());
        requestParams.put("tone", dto.getTone().name());
        requestParams.put("keywords", dto.getKeywords());
        requestParams.put("includeImage", dto.isIncludeImage());
        
        // 2. 调用AI服务
        AiGeneratedContentVO result = null;
        try {
            result = restTemplate.postForObject(
                aiServiceUrl + "/generate",
                requestParams,
                AiGeneratedContentVO.class
            );
        } catch (Exception e) {
            log.error("Failed to generate AI content", e);
            throw new AiServiceException("AI content generation failed", e);
        }
        
        // 3. 如果生成了图片，保存到素材库
        if (result != null && result.getImageUrl() != null) {
            saveMaterial(result);
        }
        
        return result;
    }
    
    private void saveMaterial(AiGeneratedContentVO content) {
        // 保存生成的图片到素材库
        MaterialDTO materialDTO = new MaterialDTO();
        materialDTO.setName("AI生成图片-" + System.currentTimeMillis());
        materialDTO.setType(MaterialType.IMAGE);
        materialDTO.setUrl(content.getImageUrl());
        materialDTO.setCategoryId(getAiGeneratedCategoryId());
        
        Material material = materialService.createMaterial(materialDTO);
        content.setMaterialId(material.getId());
    }
    
    private Long getAiGeneratedCategoryId() {
        // 获取或创建AI生成内容分类
    }
}
```

## 6. 定时任务

### 6.1 朋友圈同步任务

```java
@Component
@Slf4j
public class MomentsSyncScheduler {

    @Autowired
    private MomentsSyncService momentsSyncService;
    
    @Autowired
    private MomentsTaskRepository taskRepository;
    
    /**
     * 每分钟检查待执行的朋友圈同步任务
     */
    @Scheduled(cron = "0 * * * * ?")
    public void processMomentsTasks() {
        log.info("Processing scheduled moments tasks");
        
        // 查找所有已到执行时间但尚未执行的任务
        Date now = new Date();
        List<MomentsTask> tasks = taskRepository.findByStatusAndScheduledTimeBefore(
            MomentsTaskStatus.SCHEDULED, now);
        
        for (MomentsTask task : tasks) {
            try {
                momentsSyncService.executeMomentsTask(task.getId());
            } catch (Exception e) {
                log.error("Failed to execute moments task: " + task.getId(), e);
                
                // 更新任务状态为失败
                task.setStatus(MomentsTaskStatus.FAILED);
                task.setErrorMessage(e.getMessage());
                taskRepository.save(task);
            }
        }
    }
}
```

### 6.2 自动点赞任务

```java
@Component
@Slf4j
public class AutoLikeScheduler {

    @Autowired
    private AutoLikeService autoLikeService;
    
    /**
     * 每小时执行一次自动点赞任务
     */
    @Scheduled(cron = "0 0 * * * ?")
    public void processAutoLikeTasks() {
        log.info("Processing auto like tasks");
        
        try {
            autoLikeService.executeAutoLikeTasks();
        } catch (Exception e) {
            log.error("Failed to process auto like tasks", e);
        }
    }
}
```

## 7. 异常处理

### 7.1 异常类型

| 异常类                        | 错误码   | 说明                           |
|------------------------------|---------|-------------------------------|
| ContentNotFoundException     | 404     | 内容不存在                      |
| DeviceNotFoundException      | 404     | 设备不存在                      |
| DeviceOfflineException       | 400     | 设备离线                        |
| TaskExecutionException       | 500     | 任务执行失败                    |
| AiServiceException           | 503     | AI服务调用异常                  |
| MaterialNotFoundException    | 404     | 素材不存在                      |
| ContentPublishException      | 500     | 内容发布失败                    |
| RateLimitExceededException   | 429     | 超过频率限制                    |

## 8. 数据统计分析

### 8.1 内容效果统计接口

- **接口路径**：`/api/v1/statistics/content`
- **请求方法**：`GET`
- **接口说明**：获取内容发布效果统计

### 8.2 设备使用统计接口

- **接口路径**：`/api/v1/statistics/devices`
- **请求方法**：`GET`
- **接口说明**：获取设备使用情况统计

## 9. 与前端的交互流程

1. 前端创建内容或任务，通过相应接口发送到后端
2. 后端处理请求，创建数据库记录，返回任务ID和状态
3. 对于定时任务，后端安排定时执行
4. 任务执行时，后端通过消息队列分发到相应的处理服务
5. 处理服务调用设备控制接口执行具体操作
6. 前端可通过轮询或WebSocket获取任务执行状态和结果
7. 任务完成后，前端展示执行结果和统计数据

## 10. 安全与性能优化

### 10.1 安全措施

1. 所有接口必须进行JWT认证
2. 设备通信采用WebSocket + TLS加密
3. AI服务调用采用API密钥认证
4. 防止短时间内创建过多任务，实施速率限制
5. 敏感操作记录详细日志

### 10.2 性能优化

1. 使用消息队列分散任务处理压力
2. 大批量任务采用分批执行策略
3. 设备命令执行采用异步模式
4. 高频访问数据使用Redis缓存
5. 定时任务使用分布式调度器，避免单点压力 

---

## 文件 21: 后端-后端架构概述.md

*文件大小：8.21 KB*

---

# 存客宝后端架构概述

## 一、整体架构

存客宝后端采用微服务架构设计，支持高并发、分布式部署和弹性扩展。系统分为核心业务模块、AI智能服务、数据存储层、消息队列以及第三方平台集成等部分，通过统一的API网关对外提供服务。

![后端架构图](架构图位置)

## 二、技术架构层次

- **应用服务层**：处理业务逻辑，实现各种功能模块
- **安全认证层**：提供用户身份验证和权限控制
- **数据访问层**：抽象数据库操作，提供数据持久化服务
- **缓存服务层**：提供高性能数据缓存能力
- **API网关层**：统一接口管理，负责路由和负载均衡
- **消息服务层**：实现系统内异步通信和解耦
- **AI服务层**：提供智能分析和自动化处理能力
- **部署运维层**：支持容器化部署和自动化运维

## 三、主要模块划分

为了实现上述架构目标，后端系统可以划分为以下主要模块：

1.  **用户与权限管理模块 (User & Permission Management Module)**
    *   功能：负责处理用户注册、登录、身份验证、会话管理以及基于角色的访问控制 (RBAC) 或其他权限管理机制。
    *   核心关注点：安全性、用户数据一致性、可扩展性。

2.  **核心业务逻辑模块 (Core Business Logic Module)**
    *   功能：包含存客宝的核心业务流程，例如客户关系管理 (CRM) 功能、营销活动管理、销售流程自动化等。
    *   核心关注点：业务规则的准确实现、流程的灵活性和可配置性、与其他模块的解耦。

3.  **数据持久化与管理模块 (Data Persistence & Management Module)**
    *   功能：负责所有业务数据的存储、检索、更新和删除。包括与数据库的交互、数据校验、事务管理等。
    *   核心关注点：数据一致性、完整性、查询性能、数据备份与恢复策略。

4.  **对外接口模块 (External API Module)**
    *   功能：提供 RESTful API、GraphQL 或其他形式的接口，供前端应用、移动应用或第三方系统集成调用。
    *   核心关注点：接口的安全性 (认证、授权、限流)、版本控制、文档清晰性、易用性。

5.  **消息与通知模块 (Messaging & Notification Module)**
    *   功能：处理系统内部及对外的消息通知，例如邮件通知、短信通知、应用内推送、异步任务处理等。
    *   核心关注点：消息的可靠传递、实时性、可扩展性。

6.  **任务调度与后台作业模块 (Task Scheduling & Background Job Module)**
    *   功能：执行定期的、耗时的或异步的后台任务，如数据同步、报表生成、缓存更新等。
    *   核心关注点：任务的可靠性、可监控性、执行效率。

7.  **配置管理模块 (Configuration Management Module)**
    *   功能：管理系统的各类配置项，如数据库连接信息、第三方服务凭证、业务参数等，支持动态更新和不同环境的配置。
    *   核心关注点：配置的安全性、易管理性、变更追踪。

8.  **日志与监控模块 (Logging & Monitoring Module)**
    *   功能：记录系统运行日志、错误信息，并对系统关键指标进行监控和告警。
    *   核心关注点：日志的全面性、查询效率、监控的实时性和准确性、告警的及时性。

9.  **第三方服务集成模块 (Third-party Service Integration Module)**
    *   功能：封装与外部服务的集成逻辑，如支付网关、短信服务、邮件服务、云存储等。
    *   核心关注点：接口的稳定性、错误处理、服务降级策略。

这种模块化的设计有助于降低系统的复杂度，提高可维护性和可扩展性。各模块之间应通过定义良好的接口进行通信，以实现高内聚、低耦合。

## 四、架构特点

1. **领域驱动设计**：基于业务领域模型划分系统边界，保持模块内高内聚、模块间低耦合
2. **服务解耦**：核心业务按领域模型拆分为多个服务，支持团队并行开发、独立部署
3. **统一接口标准**：API网关实现统一接口规范、认证鉴权、限流熔断
4. **数据分层**：业务数据、缓存、数据分析分层管理，满足不同场景需求
5. **安全框架**：全链路加密、数据脱敏、操作审计
6. **可伸缩架构**：支持水平扩展，应对业务增长
7. **开发规范**：统一接口设计、异常处理、返回格式
8. **可观测性**：完善的日志、监控、告警体系

## 五、数据流处理

1. **客户数据流**：多渠道获客 → 智能过滤 → 分配/打标 → 社交账号添加 → 客户沉淀
2. **内容数据流**：内容采集 → 分类存储 → 智能处理 → 多平台推送
3. **设备数据流**：设备接入 → 状态监控 → 任务分配 → 操作执行 → 结果回传
4. **分析数据流**：业务数据采集 → 数据清洗 → 多维分析 → 可视化呈现

## 六、系统扩展原则

- **模块化设计**：新增业务场景可通过新增模块实现，不影响现有功能
- **适配器模式**：通过标准化适配器支持新渠道、新平台的灵活对接
- **多租户架构**：系统设计考虑多租户场景，支持业务和客户规模扩展
- **事件驱动架构**：关键业务采用事件驱动模式，提高系统吞吐和可扩展性
- **服务治理**：实现服务注册、发现、负载均衡和容错机制

## 五、部署与运维考量

### 1. 部署策略
*   **容器化部署**：推荐使用 Docker 等容器化技术，简化部署流程，保证环境一致性。可配合 Kubernetes (K8s) 等容器编排工具实现自动化部署、扩缩容和故障恢复。
*   **持续集成/持续部署 (CI/CD)**：建立自动化的构建、测试和部署流水线，提高交付效率和质量。
*   **多环境部署**：区分开发、测试、预发布和生产环境，各环境配置隔离。

### 2. 监控与告警
*   **应用性能监控 (APM)**：集成 APM 工具，监控应用性能指标，如响应时间、吞吐量、错误率等。
*   **基础设施监控**：监控服务器、数据库、网络等基础设施的状态。
*   **日志集中管理**：将各模块日志收集到统一的日志管理平台，方便查询和分析。
*   **告警机制**：针对关键指标设置告警阈值，及时通知运维人员处理问题。

### 3. 安全性
*   **输入验证**：对所有外部输入进行严格验证和清理，防止注入攻击 (如 SQL 注入、XSS)。
*   **身份认证与授权**：确保所有接口和资源访问都有严格的认证和授权机制。
*   **数据加密**：对敏感数据（如密码、用户个人信息）进行加密存储和传输。
*   **依赖安全**：定期扫描和更新项目依赖的第三方库，防止已知漏洞。
*   **API 安全**：API 接口应考虑防刷、防重放、数据签名等安全措施。

### 4. 可扩展性与高可用
*   **水平扩展**：通过增加服务实例数量来提高系统处理能力。
*   **负载均衡**：在多个服务实例前部署负载均衡器，分发请求。
*   **数据库扩展**：考虑读写分离、分库分表等数据库扩展方案。
*   **缓存策略**：合理使用缓存（如 Redis、Memcached）减轻数据库压力，提升响应速度。
*   **服务降级与熔断**：在部分服务不可用时，保证核心功能可用，防止雪崩效应。

## 六、未来展望

随着业务的发展，后端架构需要持续演进。未来可能考虑的方向包括：
*   **微服务化**：将单体应用或大型模块拆分为更小、更自治的微服务，进一步提高灵活性和可扩展性。
*   **服务网格 (Service Mesh)**：引入服务网格来管理微服务之间的通信、监控和安全。
*   **事件驱动架构 (EDA)**：更多地采用异步消息和事件驱动的方式来解耦服务。
*   **大数据与AI集成**：集成大数据分析平台和人工智能能力，挖掘数据价值，提升智能化水平。

本架构概述提供了一个通用的后端设计指导，具体实现需根据业务需求和团队情况进行调整和细化。

---

> 本文档描述了存客宝后端整体架构设计，详细的模块实现文档请参考各子目录。 

---

## 文件 22: 后端-集成管理-后端开发文档.md

*文件大小：11.72 KB*

---

# 第三方服务集成管理模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
第三方服务集成管理模块是平台与外部系统和服务进行交互的枢纽。它负责统一配置、管理和监控所有对外部第三方服务（如消息推送服务、支付网关、数据分析工具、身份验证提供商、云存储服务等）的连接与调用。

### 1.2 设计目标
- **统一管理**: 提供集中的界面和API来管理所有第三方服务的配置信息。
- **安全性**: 确保敏感凭证（API密钥、Token等）的安全存储和使用。
- **可靠性与容错**: 保证与外部服务通信的稳定性，并提供优雅的错误处理和重试机制。
- **可扩展性**: 易于添加对新的第三方服务的支持（例如通过适配器模式）。
- **可观测性**: 记录详细的集成调用日志，监控集成点的健康状况和性能。
- **解耦**: 将业务逻辑与具体的第三方服务实现细节解耦。
- **易用性**: 简化开发人员配置和使用第三方服务的流程。

## 二、模块概述

本模块提供对平台集成的各类外部第三方服务的全生命周期管理。这包括服务的注册与配置、凭证管理、健康检查、调用适配、以及与外部服务交互的日志记录和监控。其目的是标准化外部服务集成方式，提高系统的稳定性和可维护性。

## 三、核心概念

- **第三方服务 (Third-Party Service)**: 平台依赖的外部系统或API，例如短信/邮件服务商、支付网关、社交媒体平台、地图服务、企业级SaaS工具等。
- **集成点 (Integration Point)**: 系统中调用第三方服务的具体位置或功能。
- **适配器 (Adapter)**: 针对特定第三方服务封装其API调用、认证、数据格式转换等逻辑的组件。这是实现可扩展性的关键。
- **配置凭证 (Configuration & Credentials)**: 连接和使用第三方服务所需的参数，如API Key, Secret, App ID, 服务端点URL, 回调地址等。
- **集成契约 (Integration Contract)**: 定义了平台与特定类型第三方服务交互的标准化接口或数据格式。
- **健康检查 (Health Check)**: 用于检测与第三方服务连接是否正常、配置是否有效的功能。

## 四、核心数据实体/模型

1.  **第三方服务配置 (ThirdPartyServiceConfiguration)**
    *   `service_id` (主键): 服务配置的唯一标识符。
    *   `service_name` (字符串, 必填): 服务的可读名称 (如 "邮件发送服务-SendGrid", "短信服务-Twilio")。
    *   `service_type` (枚举/字符串, 必填): 服务的类型 (如 EMAIL_SERVICE, SMS_SERVICE, PAYMENT_GATEWAY, OAUTH_PROVIDER)。用于关联适配器。
    *   `description` (文本, 可选): 服务描述。
    *   `configurations` (JSON/加密文本, 必填): 存储该服务的具体配置参数和凭证（如API Key, Secret, 端点URL等）。**此字段必须加密存储敏感信息。**
    *   `is_enabled` (布尔, 默认: true): 该服务配置是否启用。
    *   `default_timeout_ms` (整数, 可选): 调用此服务的默认超时时间（毫秒）。
    *   `retry_policy` (JSON, 可选): 配置调用失败时的重试策略（如最大次数、退避算法）。
    *   `health_check_endpoint` (字符串, 可选): 用于健康检查的API端点（如果适用）。
    *   `created_at` (时间戳): 创建时间。
    *   `updated_at` (时间戳): 最后更新时间。

2.  **集成调用日志 (IntegrationCallLog)**
    *   `log_id` (主键): 日志唯一标识符。
    *   `service_id` (外键): 关联的第三方服务配置ID。
    *   `service_type` (字符串): 服务类型。
    *   `request_timestamp` (时间戳): 请求发起时间。
    *   `response_timestamp` (时间戳, 可选): 收到响应时间。
    *   `duration_ms` (整数, 可选): 调用耗时（毫秒）。
    *   `request_endpoint` (字符串): 调用的外部API端点。
    *   `request_payload` (文本/JSON, 可选, 注意脱敏): 发送给第三方服务的请求体。
    *   `response_status_code` (整数, 可选): 第三方服务返回的HTTP状态码。
    *   `response_payload` (文本/JSON, 可选, 注意脱敏): 第三方服务返回的响应体。
    *   `is_success` (布尔): 调用是否成功。
    *   `error_message` (文本, 可选): 如果失败，记录错误信息。
    *   `correlation_id` (字符串, 可选): 用于追踪的关联ID。

## 五、功能模块划分

1.  **服务配置管理模块**
    *   第三方服务配置的CRUD操作（创建、读取、更新、删除）。
    *   启用/禁用特定服务配置。
    *   安全地管理和存储服务凭证。
    *   版本化配置 (可选)。
2.  **集成适配器管理与执行模块**
    *   加载和管理针对不同`service_type`的适配器。
    *   提供统一的内部接口，供业务模块通过适配器调用外部服务，屏蔽具体实现细节。
    *   处理请求参数转换、认证头构建、响应解析等。
3.  **连接性测试与健康检查模块**
    *   提供测试特定服务配置连通性的功能。
    *   (可选) 定期对已启用的服务进行健康检查，并在失败时告警。
4.  **日志与监控模块**
    *   记录所有对第三方服务的调用尝试（成功与失败）。
    *   提供查询集成调用日志的接口。
    *   监控集成点的调用频率、成功率、平均耗时等关键指标。

## 六、API接口设计指导原则

- **资源**: `integrations/services` (第三方服务配置), `integrations/logs` (集成调用日志)。
- **服务配置API**: (示例)
    - `POST /integrations/services`: 添加新的第三方服务配置。
    - `GET /integrations/services`: 获取已配置的服务列表 (可按类型、状态筛选)。
    - `GET /integrations/services/{service_id}`: 获取特定服务配置详情 (凭证应脱敏或不返回)。
    - `PUT /integrations/services/{service_id}`: 更新服务配置。
    - `DELETE /integrations/services/{service_id}`: 删除服务配置。
    - `POST /integrations/services/{service_id}/enable`: 启用服务。
    - `POST /integrations/services/{service_id}/disable`: 禁用服务。
    - `POST /integrations/services/{service_id}/test-connection`: 测试与该第三方服务的连接性。
- **集成日志API**: (示例)
    - `GET /integrations/logs`: 获取集成调用日志列表 (支持按服务ID、时间范围、状态等筛选)。
    - `GET /integrations/logs/{log_id}`: 获取特定日志详情。
- **通用原则**: 遵循RESTful, JSON格式，标准化HTTP状态码和错误响应，所有接口需认证授权。

## 七、主要业务流程示例

### 1. 管理员添加并启用一个新的短信服务集成
    1.  管理员通过后台界面或API提交添加新服务配置的请求。
        *   请求体包含：`service_name`="阿里云短信服务", `service_type`="SMS_PROVIDER_ALIYUN", `configurations`={ "accessKeyId": "...", "accessKeySecret": "...", "signName": "...", "templateCode": "..." }, `is_enabled`=false。
    2.  API接收请求，对`configurations`中的敏感信息进行加密处理后，持久化到数据库。
    3.  管理员调用 `POST /integrations/services/{new_service_id}/test-connection` 测试配置是否正确。
        *   模块内部找到对应的"SMS_PROVIDER_ALIYUN"适配器，使用配置尝试发送一条测试短信或调用服务商的测试接口。
    4.  测试成功后，管理员调用 `POST /integrations/services/{new_service_id}/enable` 启用该服务。

### 2. 业务模块通过集成点发送邮件
    1.  用户注册成功后，账户服务需要发送一封欢迎邮件。
    2.  账户服务调用一个内部的"通知服务"或直接与"集成服务"交互，请求发送邮件。
        *   请求参数可能为：`service_type_preference`=["EMAIL_PROVIDER_PRIMARY", "EMAIL_PROVIDER_BACKUP"], `recipient`="user@example.com", `subject`="Welcome!", `body`="Hello..."。
    3.  集成服务模块：
        a.  查找已启用的、类型匹配的邮件服务配置（如 SendGrid）。
        b.  获取对应的邮件服务适配器。
        c.  使用适配器和配置信息，调用第三方邮件服务的API发送邮件。
        d.  记录本次调用的详细日志到 `IntegrationCallLog` 表，包括请求、响应、状态等。
    4.  向账户服务返回发送成功或失败的结果。

## 八、技术考量与开发注意事项

1.  **适配器模式 (Adapter Pattern)**: 强烈推荐为每种第三方服务或每种服务类型（如邮件、短信）实现适配器。这使得添加新服务或替换服务商变得容易，而无需修改核心业务逻辑。
2.  **凭证安全管理**:
    *   API密钥、密码等敏感凭证绝不能硬编码或明文存储在配置文件中。
    *   应使用专门的密钥管理服务 (如 HashiCorp Vault, AWS KMS, Azure Key Vault) 或数据库加密功能进行安全存储。
    *   访问凭证的权限应受到严格控制。
3.  **超时与重试机制**:
    *   为外部调用设置合理的超时时间。
    *   对可恢复的错误（如网络抖动、服务商临时不可用）实现重试逻辑（例如指数退避）。配置应灵活。
4.  **容错与降级**:
    *   当某个第三方服务不可用时，系统应能优雅处理，避免级联失败。
    *   考虑备用服务商切换逻辑（如主短信通道失败，自动切换到备用通道）。
    *   对于非核心集成，可实现熔断机制。
5.  **异步处理**: 对于耗时较长或不需要立即响应的集成调用（如批量数据同步），考虑使用消息队列进行异步处理。
6.  **API版本控制与兼容性**: 第三方服务的API可能会更新。适配器需要关注其版本变化，并处理好向后兼容性或进行适配器升级。
7.  **日志记录的粒度与内容**: 日志应足够详细以便排查问题，但需注意脱敏请求/响应中的敏感数据。
8.  **标准化错误处理**: 统一内部错误码和错误信息格式，方便上层业务处理。
9.  **限流与配额**: 注意第三方服务商对API调用频率的限制和配额，避免超出限制导致服务被暂停。模块内部可实现相应的限流控制。
10. **可测试性**: 方便对适配器逻辑、连接测试等进行单元测试和集成测试。使用Mock服务模拟第三方API行为。

## 九、数据校验与错误处理

1.  **配置校验**:
    *   对用户输入的服务配置参数进行格式和有效性校验。
    *   确保关键凭证字段不为空。
2.  **调用前校验**:
    *   检查服务配置是否启用。
    *   检查所需参数是否齐全。
3.  **响应处理**:
    *   根据第三方服务返回的HTTP状态码和响应体判断操作是否成功。
    *   解析错误信息，转换为内部标准错误。
4.  **网络异常处理**: 捕获和处理网络连接超时、DNS解析失败等异常。

## 十、安全性考量

1.  **凭证安全**: (已在技术考量中重点强调) 加密存储，最小权限访问，定期轮换（如果服务商支持）。
2.  **数据传输安全**: 与第三方服务通信优先使用HTTPS/TLS。
3.  **回调安全 (如果集成涉及接收回调)**:
    *   验证回调请求的来源IP是否可信。
    *   使用签名机制（如HMAC）验证回调请求的真实性和完整性。
    *   处理好回调的幂等性。
4.  **防止信息泄露**: 避免在日志或错误信息中无意泄露敏感配置或数据。
5.  **输入验证**: 如果配置中允许用户输入可执行脚本或模板（不推荐），需严格审查和沙箱化执行。
6.  **权限控制**: 严格控制对集成配置API的访问权限，只有授权管理员可进行修改。

---
> 本文档旨在提供第三方服务集成管理的通用后端设计指导。具体实现需根据平台特性和所集成服务的具体要求进行调整。 

---

## 文件 23: 后端-前后端接口约定.md

*文件大小：11.18 KB*

---

# 存客宝前后端接口约定

## 一、概述

存客宝采用前后端分离架构，前端基于Next.js 15，后端基于Spring Boot 2.7构建。为保证前后端的顺畅协作和系统的可维护性，特制定本接口约定规范，明确接口设计原则、请求响应格式、错误处理等内容。

## 二、API设计原则

### 1. RESTful API设计规范

#### 1.1 URL命名

- 使用名词复数形式表示资源集合
- 使用kebab-case（小写字母，单词间用连字符'-'分隔）
- 避免URL中包含动词，通过HTTP方法表达操作类型
- 资源层次结构在URL路径中体现

```
# 良好示例
GET    /api/v1/customers              # 获取客户列表
GET    /api/v1/customers/{id}         # 获取特定客户
POST   /api/v1/customers              # 创建新客户
PUT    /api/v1/customers/{id}         # 更新客户全部信息
PATCH  /api/v1/customers/{id}         # 更新客户部分信息
DELETE /api/v1/customers/{id}         # 删除客户

# 不推荐
GET    /api/v1/getCustomers           # 使用了动词
GET    /api/v1/customer/profile/{id}  # 使用了单数形式
```

#### 1.2 HTTP方法使用

| HTTP方法 | 用途 | 特性 |
|---------|------|------|
| GET | 获取资源 | 安全、幂等、可缓存 |
| POST | 创建资源 | 非幂等、不可缓存 |
| PUT | 全量更新资源 | 幂等、不可缓存 |
| PATCH | 部分更新资源 | 非幂等、不可缓存 |
| DELETE | 删除资源 | 幂等、不可缓存 |

**幂等性说明**：多次调用产生的效果与单次调用相同。

#### 1.3 查询参数使用规范

- **分页参数**：`page`(页码，从1开始)和`size`(每页条数)
  ```
  GET /api/v1/customers?page=1&size=10
  ```

- **排序参数**：`sort`(排序字段)和`order`(排序方向: asc/desc)
  ```
  GET /api/v1/customers?sort=createTime&order=desc
  ```

- **过滤参数**：直接使用字段名作为参数
  ```
  GET /api/v1/customers?status=active&source=wechat
  ```

- **搜索参数**：使用`keyword`或`q`作为参数
  ```
  GET /api/v1/customers?keyword=张三
  ```

- **字段选择**：使用`fields`参数指定返回字段
  ```
  GET /api/v1/customers?fields=id,name,phone
  ```

### 2. 版本控制

API版本控制采用URL路径方式：

```
/api/v1/customers
/api/v2/customers
```

主版本号变更表示不向后兼容的API变更，新功能添加通常在子版本或补丁版本中进行。

### 3. 状态码使用

| 状态码 | 含义 | 使用场景 |
|-------|------|---------|
| 200 OK | 请求成功 | GET请求成功返回数据 |
| 201 Created | 创建成功 | POST请求创建资源成功 |
| 204 No Content | 操作成功，无返回内容 | DELETE请求删除资源成功 |
| 400 Bad Request | 请求参数错误 | 参数验证失败 |
| 401 Unauthorized | 未认证或认证已过期 | 未登录或token失效 |
| 403 Forbidden | 权限不足 | 已登录但无操作权限 |
| 404 Not Found | 资源不存在 | 请求的资源不存在 |
| 409 Conflict | 资源冲突 | 冲突，如重复创建 |
| 422 Unprocessable Entity | 请求格式正确但语义错误 | 验证错误，如业务规则不满足 |
| 429 Too Many Requests | 请求频率超限 | 触发限流 |
| 500 Internal Server Error | 服务器内部错误 | 未预期的服务器错误 |

## 三、请求与响应格式

### 1. 请求头规范

所有API请求应包含以下HTTP头：

```
Content-Type: application/json
Accept: application/json
Authorization: Bearer {token}  // JWT认证Token
X-Request-ID: {uuid}          // 请求追踪ID（可选）
```

### 2. 请求体格式

对于POST、PUT、PATCH请求，请求体采用JSON格式：

```json
{
  "name": "张三",
  "phone": "13800138000",
  "source": "wechat",
  "tags": ["vip", "new"]
}
```

### 3. 响应体格式

所有API响应采用统一的JSON格式：

```json
{
  "code": 200,                // 业务状态码，与HTTP状态码保持一致
  "message": "操作成功",       // 状态描述
  "data": {                   // 响应数据，可以是对象、数组或null
    "id": 123,
    "name": "张三",
    "phone": "13800138000"
  },
  "timestamp": 1628153457000  // 服务器响应时间戳
}
```

对于列表查询，data中返回分页信息：

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "records": [              // 数据记录
      {
        "id": 1,
        "name": "张三"
      },
      {
        "id": 2,
        "name": "李四"
      }
    ],
    "total": 125,             // 总记录数
    "size": 10,               // 每页大小
    "current": 1,             // 当前页码
    "pages": 13               // 总页数
  },
  "timestamp": 1628153457000
}
```

### 4. 错误响应格式

当发生错误时，响应体格式保持一致，仅状态码和内容有变化：

```json
{
  "code": 400,                       // 错误状态码
  "message": "请求参数验证失败",        // 错误信息
  "data": {                          // 错误详情（可选）
    "field": "phone",
    "message": "手机号格式不正确"
  },
  "timestamp": 1628153457000
}
```

对于字段验证错误，data可以包含多个错误：

```json
{
  "code": 422,
  "message": "表单验证失败",
  "data": [
    {
      "field": "phone",
      "message": "手机号格式不正确"
    },
    {
      "field": "email",
      "message": "邮箱不能为空"
    }
  ],
  "timestamp": 1628153457000
}
```

## 四、认证与授权

### 1. 认证机制

采用JWT (JSON Web Token) 进行用户认证：

1. 客户端通过登录接口获取JWT Token
2. 后续请求在Authorization头中携带Token
3. 服务端验证Token的有效性

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 2. Token管理

- Token默认有效期：2小时
- 客户端应处理Token过期情况，通过刷新Token接口重新获取
- 敏感操作可能需要重新验证用户身份

### 3. 权限控制

基于RBAC(基于角色的访问控制)模型：

1. 用户(User)与角色(Role)是多对多关系
2. 角色(Role)与权限(Permission)是多对多关系
3. API接口标记所需权限
4. 用户请求时检查是否具备所需权限

## 五、数据校验

### 1. 通用校验规则

| 字段类型 | 校验规则 |
|---------|---------|
| 用户名   | 长度：5-30，仅允许字母、数字、下划线 |
| 密码    | 长度：8-20，至少包含数字、大小写字母其中两种 |
| 手机号   | 11位数字，符合中国大陆手机号格式 |
| 邮箱    | 符合标准邮箱格式 |
| 身份证号 | 18位，符合中国身份证号规则 |

### 2. 校验失败处理

- 前端应在提交前进行表单验证
- 后端会对所有输入进行验证，校验失败返回422状态码
- 返回的错误信息应包含具体字段和错误原因

## 六、安全与限流

### 1. 接口限流

为防止恶意攻击和服务过载，实施以下限流策略：

- 登录接口：每IP每分钟不超过10次
- 注册接口：每IP每天不超过50次
- 敏感操作：每用户每小时不超过100次
- 普通API：每用户每分钟不超过300次

触发限流时返回429状态码。

### 2. 安全防护

- 所有接口使用HTTPS加密传输
- 敏感数据（如密码）经散列后存储
- 实施防SQL注入、XSS攻击和CSRF防护
- 重要操作需要验证码或二次验证

## 七、API文档与测试

### 1. Swagger文档

API文档基于OpenAPI规范，使用Swagger UI提供在线文档和测试功能：

- 开发环境文档地址：`http://localhost:8080/swagger-ui/index.html`
- 测试环境文档地址：`https://test-api.cunkebao.com/swagger-ui/index.html`

### 2. Postman集合

为便于开发和测试，提供Postman集合文件，包含所有API的示例请求和响应：

- 文件位置：`/docs/postman/cunkebao-api.postman_collection.json`
- 环境变量文件：`/docs/postman/cunkebao-{env}.postman_environment.json`

## 八、开发与协作流程

### 1. API优先开发

采用"API优先"的开发方式：

1. 根据需求设计API接口
2. 前后端共同评审API设计
3. 编写API文档
4. 前端基于API文档进行开发（可使用Mock服务）
5. 后端实现API接口
6. 联调测试

### 2. API变更流程

API变更需遵循以下流程：

1. 提出变更需求和原因
2. 评估变更影响范围
3. 前后端协商确定变更方案
4. 更新API文档
5. 实施变更并通知相关人员

### 3. 版本兼容性

- 尽量保持API向后兼容
- 不兼容的变更应使用新的API版本
- 废弃的API应保留一段过渡期
- 过渡期内，应在响应头中添加弃用提示

## 九、最佳实践与示例

### 1. API接口命名示例

| 资源 | URL | HTTP方法 | 说明 |
|-----|-----|---------|-----|
| 客户管理 | /api/v1/customers | GET | 获取客户列表 |
| | /api/v1/customers/{id} | GET | 获取单个客户 |
| | /api/v1/customers | POST | 创建客户 |
| | /api/v1/customers/{id} | PUT | 更新客户 |
| | /api/v1/customers/{id} | DELETE | 删除客户 |
| | /api/v1/customers/{id}/tags | GET | 获取客户标签 |
| | /api/v1/customers/{id}/tags | POST | 添加客户标签 |
| 设备管理 | /api/v1/devices | GET | 获取设备列表 |
| | /api/v1/devices/{id} | GET | 获取单个设备 |
| | /api/v1/devices/{id}/status | GET | 获取设备状态 |
| | /api/v1/devices/{id}/bind | POST | 绑定设备 |
| 内容管理 | /api/v1/contents | GET | 获取内容列表 |
| | /api/v1/contents/{id} | GET | 获取单个内容 |
| | /api/v1/contents/{id}/push | POST | 推送内容 |

### 2. 请求与响应示例

**示例1：创建客户**

请求：
```http
POST /api/v1/customers HTTP/1.1
Host: api.cunkebao.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "name": "张三",
  "phone": "13800138000",
  "email": "zhangsan@example.com",
  "source": "wechat",
  "tags": ["潜在客户", "教育行业"]
}
```

成功响应：
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "code": 201,
  "message": "创建成功",
  "data": {
    "id": 12345,
    "name": "张三",
    "phone": "13800138000",
    "email": "zhangsan@example.com",
    "source": "wechat",
    "tags": ["潜在客户", "教育行业"],
    "createTime": "2023-06-01T12:00:00Z"
  },
  "timestamp": 1685620800000
}
```

错误响应：
```http
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
  "code": 422,
  "message": "表单验证失败",
  "data": [
    {
      "field": "phone",
      "message": "手机号已存在"
    }
  ],
  "timestamp": 1685620800000
}
```

**示例2：分页查询客户列表**

请求：
```http
GET /api/v1/customers?page=1&size=10&source=wechat&sort=createTime&order=desc HTTP/1.1
Host: api.cunkebao.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

响应：
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "code": 200,
  "message": "操作成功",
  "data": {
    "records": [
      {
        "id": 12345,
        "name": "张三",
        "phone": "13800138000",
        "email": "zhangsan@example.com",
        "source": "wechat",
        "createTime": "2023-06-01T12:00:00Z"
      },
      // 更多记录...
    ],
    "total": 142,
    "size": 10,
    "current": 1,
    "pages": 15
  },
  "timestamp": 1685620800000
}
```

---

> 本文档详细说明了存客宝前后端接口约定规范，前后端开发人员均应遵循，确保系统协作顺畅、代码质量及可维护性。 

---

## 文件 24: 后端-权限管理-后端开发文档.md

*文件大小：18.28 KB*

---

# 存客宝权限管理模块后端开发文档

## 1. 模块概述

权限管理模块负责构建和维护系统内部的访问控制体系，确保用户只能执行其被授权的操作和访问其被允许的数据。本系统采用基于角色的访问控制 (RBAC) 模型，通过将权限赋予角色，再将角色分配给用户来实现权限管理。

模块功能包括：权限点定义、角色管理、角色与权限的关联、用户与角色的关联、以及提供权限校验服务供其他模块调用。

## 2. API接口设计

### 2.1 获取所有权限点列表

- **接口路径**：`/api/v1/permissions`
- **请求方法**：`GET`
- **接口说明**：获取系统中所有已定义的权限点列表。通常用于前端展示权限树或权限选择。
- **权限:** `permission:view` 或 `permission:list`
- **请求参数 (Query Parameters):**

| 参数名 | 类型    | 是否必需 | 描述         | 示例值 |
|--------|--------|----------|--------------|--------|
| name   | string | 否       | 权限点名称关键字 | 用户管理 |
| code   | string | 否       | 权限点编码关键字 | user:view |
| page   | integer| 否       | 页码         | 1      |
| size   | integer| 否       | 每页条数     | 10     |

- **响应数据 (统一格式 `data` 字段):** 返回权限点列表（支持分页）。

```json
{
  "records": [
    {
      "permissionId": 1,
      "name": "用户列表查看",
      "code": "user:view", // 权限点唯一编码，用于后端校验
      "resource": "用户管理", // 关联的资源名称 (可选)
      "description": "查看用户列表数据",
      "createTime": "2023-10-26T10:00:00Z"
    }
    // ... 更多权限点
  ],
  "total": 50,
  "size": 10,
  "current": 1,
  "pages": 5
}
```
- **可能返回状态码:** 200 (成功), 400, 401, 403, 500

### 2.2 创建权限点

- **接口路径**：`/api/v1/permissions`
- **请求方法**：`POST`
- **接口说明**：创建一个新的权限点。
- **权限:** `permission:create`
- **请求参数 (Request Body):**

| 参数名      | 类型   | 是否必需 | 描述         | 示例值 |
|-------------|--------|----------|--------------|--------|
| name        | string | 是       | 权限点名称   | 用户删除 |
| code        | string | 是       | 权限点唯一编码 | user:delete |
| resource    | string | 否       | 关联的资源名称 | 用户管理 |
| description | string | 否       | 权限点描述   | 删除用户记录 |

- **响应数据 (统一格式 `data` 字段):** 返回新创建的权限点信息。

```json
{
  "permissionId": 2,
  "name": "用户删除",
  "code": "user:delete",
  "createTime": "2023-10-26T10:05:00Z"
}
```
- **可能返回状态码:** 201 (创建成功), 400 (参数错误/编码重复), 401, 403, 422 (数据校验失败), 500

### 2.3 更新权限点

- **接口路径**：`/api/v1/permissions/{permissionId}`
- **请求方法**：`PUT`
- **接口说明**：更新指定权限点的信息。
- **权限:** `permission:update`
- **请求参数 (Path Parameters):**

| 参数名       | 类型    | 是否必需 | 说明         | 示例值 |
|--------------|--------|----------|--------------|--------|
| permissionId | integer | 是       | 权限点ID     | 1      |

- **请求体 (Request Body):** 结构与创建权限点类似，可以只包含需要更新的字段。

- **响应数据 (统一格式 `data` 字段):** 返回更新后的权限点信息。

```json
{
  "permissionId": 1,
  "name": "用户列表查看 (更新)",
  "updateTime": "2023-10-26T10:10:00Z"
}
```
- **可能返回状态码:** 200 (更新成功), 400, 401, 403, 404 (权限点不存在), 422, 500

### 2.4 删除权限点

- **接口路径**：`/api/v1/permissions/{permissionId}`
- **请求方法**：`DELETE`
- **接口说明**：删除指定权限点。如果该权限点已与角色关联，则不允许删除或需要先解除关联。
- **权限:** `permission:delete`
- **请求参数 (Path Parameters):**

| 参数名       | 类型    | 是否必需 | 说明         | 示例值 |
|--------------|--------|----------|--------------|--------|
| permissionId | integer | 是       | 权限点ID     | 2      |

- **响应数据 (统一格式 `data` 字段):** 返回成功信息。

```json
{
  "message": "权限点删除成功"
}
```
- **可能返回状态码:** 200, 401, 403, 404, 409 (已关联角色), 500

### 2.5 获取角色列表

- **接口路径**：`/api/v1/roles`
- **请求方法**：`GET`
- **接口说明**：获取系统中所有角色列表。支持分页和筛选。
- **权限:** `role:view` 或 `role:list`
- **请求参数 (Query Parameters):**

| 参数名 | 类型    | 是否必需 | 描述       | 示例值 |
|--------|--------|----------|------------|--------|
| name   | string | 否       | 角色名称关键字 | 管理员 |
| page   | integer| 否       | 页码       | 1      |
| size   | integer| 否       | 每页条数   | 10     |

- **响应数据 (统一格式 `data` 字段):** 返回角色列表（支持分页）。

```json
{
  "records": [
    {
      "roleId": 101,
      "name": "系统管理员",
      "code": "ROLE_ADMIN", // 角色唯一编码，通常以 ROLE_ 开头
      "description": "拥有系统最高权限",
      "createTime": "2023-10-26T10:20:00Z"
    }
    // ... 更多角色
  ],
  "total": 5,
  "size": 10,
  "current": 1,
  "pages": 1
}
```
- **可能返回状态码:** 200, 400, 401, 403, 500

### 2.6 创建新角色

- **接口路径**：`/api/v1/roles`
- **请求方法**：`POST`
- **接口说明**：创建一个新的角色。
- **权限:** `role:create`
- **请求参数 (Request Body):**

| 参数名      | 类型   | 是否必需 | 描述         | 示例值 |
|-------------|--------|----------|--------------|--------|
| name        | string | 是       | 角色名称     | 运营专员 |
| code        | string | 是       | 角色唯一编码 | ROLE_OPERATOR |
| description | string | 否       | 角色描述     | 负责日常运营工作 |

- **响应数据 (统一格式 `data` 字段):** 返回新创建的角色信息。

```json
{
  "roleId": 102,
  "name": "运营专员",
  "code": "ROLE_OPERATOR",
  "createTime": "2023-10-26T10:25:00Z"
}
```
- **可能返回状态码:** 201, 400 (参数错误/编码重复), 401, 403, 422, 500

### 2.7 更新角色信息

- **接口路径**：`/api/v1/roles/{roleId}`
- **请求方法**：`PUT`
- **接口说明**：更新指定角色的信息。
- **权限:** `role:update`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 说明   | 示例值 |
|--------|--------|----------|--------|--------|
| roleId | integer | 是       | 角色ID | 101    |

- **请求体 (Request Body):** 结构与创建角色类似，可以只包含需要更新的字段。

- **响应数据 (统一格式 `data` 字段):** 返回更新后的角色信息。

```json
{
  "roleId": 101,
  "name": "超级管理员",
  "updateTime": "2023-10-26T10:30:00Z"
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404 (角色不存在), 422, 500

### 2.8 删除角色

- **接口路径**：`/api/v1/roles/{roleId}`
- **请求方法**：`DELETE`
- **接口说明**：删除指定角色。如果该角色已分配给用户或已关联权限点，则不允许删除或需要先解除关联。
- **权限:** `role:delete`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 说明   | 示例值 |
|--------|--------|----------|--------|--------|
| roleId | integer | 是       | 角色ID | 102    |

- **响应数据 (统一格式 `data` 字段):** 返回成功信息。

```json
{
  "message": "角色删除成功"
}
```
- **可能返回状态码:** 200, 401, 403, 404, 409 (已分配用户或关联权限), 500

### 2.9 获取角色关联的权限点列表

- **接口路径**：`/api/v1/roles/{roleId}/permissions`
- **请求方法**：`GET`
- **接口说明**：获取指定角色当前关联的所有权限点列表。
- **权限:** `role:permission:view`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 说明   | 示例值 |
|--------|--------|----------|--------|--------|
| roleId | integer | 是       | 角色ID | 101    |

- **响应数据 (统一格式 `data` 字段):** 返回该角色关联的权限点列表。

```json
[
  {
    "permissionId": 1,
    "name": "用户列表查看",
    "code": "user:view"
  },
  {
    "permissionId": 3,
    "name": "用户创建",
    "code": "user:create"
  }
  // ... 更多权限点
]
```
- **可能返回状态码:** 200, 401, 403, 404, 500

### 2.10 为角色分配权限点

- **接口路径**：`/api/v1/roles/{roleId}/permissions`
- **请求方法**：`POST`
- **接口说明**：为指定角色批量分配权限点。通常是全量更新，即提交该角色应拥有的所有权限点ID。
- **权限:** `role:permission:assign`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 说明   | 示例值 |
|--------|--------|----------|--------|--------|
| roleId | integer | 是       | 角色ID | 101    |

- **请求体 (Request Body):**

| 参数名         | 类型           | 是否必需 | 描述             | 示例值     |
|----------------|----------------|----------|------------------|------------|
| permissionIds  | array<integer> | 是       | 要分配的权限点ID列表 | `[1, 3, 5]` |

- **响应数据 (统一格式 `data` 字段):** 返回更新后的角色关联权限信息或成功信息。

```json
{
  "message": "角色权限分配成功",
  "roleId": 101,
  "assignedPermissionIds": [1, 3, 5] // 返回实际关联的权限ID列表
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 500

### 2.11 获取用户关联的角色列表

- **接口路径**：`/api/v1/users/{userId}/roles`
- **请求方法**：`GET`
- **接口说明**：获取指定用户当前关联的所有角色列表。
- **权限:** `user:role:view`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 说明   | 示例值 |
|--------|--------|----------|--------|--------|
| userId | integer | 是       | 用户ID | 1001   |

- **响应数据 (统一格式 `data` 字段):** 返回该用户关联的角色列表。

```json
[
  {
    "roleId": 101,
    "name": "系统管理员",
    "code": "ROLE_ADMIN"
  },
  {
    "roleId": 103,
    "name": "产品经理",
    "code": "ROLE_PRODUCT_MANAGER"
  }
  // ... 更多角色
]
```
- **可能返回状态码:** 200, 401, 403, 404, 500

### 2.12 为用户分配角色

- **接口路径**：`/api/v1/users/{userId}/roles`
- **请求方法**：`POST`
- **接口说明**：为指定用户批量分配角色。通常是全量更新，即提交该用户应拥有的所有角色ID。
- **权限:** `user:role:assign`
- **请求参数 (Path Parameters):**

| 参数名 | 类型    | 是否必需 | 说明   | 示例值 |
|--------|--------|----------|--------|--------|
| userId | integer | 是       | 用户ID | 1001   |

- **请求体 (Request Body):**

| 参数名   | 类型           | 是否必需 | 描述         | 示例值     |
|----------|----------------|----------|--------------|------------|
| roleIds  | array<integer> | 是       | 要分配的角色ID列表 | `[101, 103]` |

- **响应数据 (统一格式 `data` 字段):** 返回更新后的用户关联角色信息或成功信息。

```json
{
  "message": "用户角色分配成功",
  "userId": 1001,
  "assignedRoleIds": [101, 103] // 返回实际关联的角色ID列表
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 500

## 3. 数据模型设计

基于角色的访问控制 (RBAC) 模型涉及权限点、角色以及它们与用户的关联。

### 3.1 权限点表 `t_permission`

用于定义系统中的各种操作权限点。

| 字段名        | 类型         | 是否必需 | 说明                                   | 索引        |
|--------------|--------------|----------|----------------------------------------|------------|
| id           | BIGINT (PK)  | 是       | 主键                                   |            |
| name         | VARCHAR(100) | 是       | 权限点名称 (如 "用户列表查看")             | Index      |
| code         | VARCHAR(100) | 是       | 权限点唯一编码 (如 "user:view")，用于后端校验 | UNIQUE Index |
| resource     | VARCHAR(100) | 否       | 关联的资源名称 (如 "用户管理")，用于界面分组展示 | Index      |
| description  | VARCHAR(500) | 否       | 权限点描述                             |            |
| create_time  | DATETIME     | 是       | 创建时间                               |            |
| update_time  | DATETIME     | 是       | 更新时间                               |            |

### 3.2 角色表 `t_role`

用于定义系统中的各种角色。

| 字段名        | 类型         | 是否必需 | 说明                       | 索引        |
|--------------|--------------|----------|----------------------------|------------|
| id           | BIGINT (PK)  | 是       | 主键                       |            |
| name         | VARCHAR(100) | 是       | 角色名称 (如 "系统管理员")       | Index      |
| code         | VARCHAR(100) | 是       | 角色唯一编码 (如 "ROLE_ADMIN") | UNIQUE Index |
| description  | VARCHAR(500) | 否       | 角色描述                   |            |
| create_time  | DATETIME     | 是       | 创建时间                   |            |
| update_time  | DATETIME     | 是       | 更新时间                   |            |

### 3.3 角色权限关联表 `t_role_permission`

关联角色和权限点，表示某个角色拥有哪些权限。

| 字段名        | 类型         | 是否必需 | 说明         | 索引        | 与其他表关系              |
|--------------|--------------|----------|--------------|------------|--------------------------|
| id           | BIGINT (PK)  | 是       | 主键         |            |                          |
| role_id      | BIGINT (FK)  | 是       | 角色ID       | Index      | role_id -> t_role.id     |
| permission_id| BIGINT (FK)  | 是       | 权限点ID     | Index      | permission_id -> t_permission.id |
| create_time  | DATETIME     | 是       | 创建时间     |            |                          |

**注意:** `role_id` 和 `permission_id` 的组合应是唯一的，防止重复关联。

### 3.4 用户角色关联表 `t_user_role`

关联用户和角色，表示某个用户拥有哪些角色。

| 字段名        | 类型         | 是否必需 | 说明     | 索引        | 与其他表关系           |
|--------------|--------------|----------|----------|------------|-----------------------|
| id           | BIGINT (PK)  | 是       | 主键     |            |                       |
| user_id      | BIGINT (FK)  | 是       | 用户ID   | Index      | user_id -> t_user.id  |
| role_id      | BIGINT (FK)  | 是       | 角色ID   | Index      | role_id -> t_role.id |
| create_time  | DATETIME     | 是       | 创建时间 |            |                       |

**注意:** `user_id` 和 `role_id` 的组合应是唯一的，防止重复分配。

## 4. 异常处理

- `PermissionNotFoundException`: 权限点不存在异常
- `RoleNotFoundException`: 角色不存在异常
- `UserNotFoundException`: 用户不存在异常
- `PermissionAlreadyExistsException`: 权限点编码已存在异常
- `RoleAlreadyExistsException`: 角色编码已存在异常
- `RoleInUseException`: 角色已分配给用户或关联权限，无法删除异常
- `PermissionInUseException`: 权限点已关联角色，无法删除异常
- `PermissionAssignmentException`: 权限分配异常
- `RoleAssignmentException`: 角色分配异常

## 5. 开发注意事项和实现要点

1.  **RBAC模型实现:**
    - 核心在于维护 `t_role_permission` 和 `t_user_role` 两张关联表。
    - 在代码层面，实现 RoleService, PermissionService, UserRoleService, RolePermissionService 等服务类来管理权限点、角色和它们之间的关联关系。
2.  **权限校验集成:**
    - 将权限校验逻辑集成到 Spring Security 或类似的 AOP (面向切面编程) 框架中。
    - 在需要进行权限控制的 API 接口或方法上使用注解 (如 `@PreAuthorize("hasAuthority('user:view')")`) 来声明所需的权限。
    - 实现自定义的权限评估器，根据当前登录用户的角色和角色权限关联表来判断用户是否拥有某个权限。
3.  **用户权限信息加载和缓存:**
    - 用户登录成功后，需要加载该用户拥有的所有角色，并通过角色关联查询其拥有的所有权限点。
    - 将用户的角色和权限信息缓存起来 (如使用 Redis)，以提高后续权限校验的效率，避免每次请求都查询数据库。
    - 考虑缓存的过期时间和更新策略（例如，角色或权限更新后，需要清除相关用户的缓存）。
4.  **数据验证:**
    - 对创建和更新权限点、角色、分配关联关系的请求参数进行严格验证，如名称、编码的格式和唯一性，关联ID的有效性等。
    - 使用 Spring Validation 框架结合注解进行声明式验证。验证失败时，按照 `./前后端接口约定.md` 中的约定返回 422 状态码和详细的错误信息列表。
5.  **错误处理:**
    - 遵循 `./前后端接口约定.md` 中的错误处理规范。
    - 捕获并处理权限点/角色不存在、编码重复、关联关系错误、权限不足等异常，返回统一的错误响应格式。
6.  **日志记录:**
    - 记录所有权限管理相关的操作日志，包括权限点和角色的增删改、角色权限分配、用户角色分配等。
    - 日志应包含操作人、操作时间、操作类型、操作对象（如权限点ID、角色ID、用户ID）、操作结果等信息。
    - 记录权限校验失败的日志，便于安全审计。
7.  **数据权限 (扩展):**
    - 当前 RBAC 模型主要控制功能权限。如果需要实现数据权限（例如，某个用户只能看到自己创建的数据），需要在业务代码中结合用户与数据的关联关系进行额外的过滤或使用更复杂的权限模型 (如 ABAC)。
8.  **接口设计:**
    - 获取权限点和角色列表的接口应支持分页、筛选和排序。
    - 为角色或用户分配权限/角色的接口可以设计为全量更新，或者提供增量更新的接口。
9.  **初始化数据:**
    - 系统启动时，需要初始化一些基础权限点和角色（如超级管理员角色和基本权限），以及将初始管理员用户与超级管理员角色关联。

--- 

---

## 文件 25: 后端-认证授权模块开发文档.md

*文件大小：13.44 KB*

---

# 认证与授权模块设计指南

## 一、引言

### 1.1 模块定位与重要性
认证与授权模块是任何安全系统的基石，负责确认用户、服务或其他系统的身份（认证），并控制其对资源的访问权限（授权）。一个健壮的认证授权模块对于保护系统数据、防止未授权访问和确保业务流程的合规性至关重要。

### 1.2 设计目标
- **身份验证 (Authentication)**: 可靠地验证请求方（用户、服务）的身份。
- **权限管理 (Authorization)**: 精确控制已认证身份对系统各项功能和数据的访问权限。
- **安全性**: 提供强大的安全保障，抵御常见的认证授权漏洞和攻击。
- **灵活性与可扩展性**: 支持多种认证机制，适应不同的客户端类型和业务发展带来的权限模型变化。
- **易用性**: 为最终用户提供流畅的认证体验，为管理员提供便捷的权限配置管理。
- **可审计性**: 记录所有关键的认证和授权活动，以供审计和追踪。

## 二、核心概念

- **主体 (Principal/Subject)**: 请求访问系统资源的实体，通常是用户，也可以是其他服务或设备。
- **身份认证 (Authentication)**: 验证主体所声称身份的过程。常用的凭证类型包括密码、令牌、生物特征、数字证书等。
- **授权 (Authorization)**: 在身份认证成功后，判断主体是否有权执行特定操作或访问特定资源的过程。
- **凭证 (Credentials)**: 主体用于证明其身份的信息，如用户名/密码、API密钥、令牌等。
- **令牌 (Token)**: 一种包含主体身份和/或权限信息的数字凭证，常用于无状态认证机制中。JWT (JSON Web Token) 是一种常见的令牌格式。
- **角色 (Role)**: 一组权限的集合，可以将权限批量授予用户。是实现基于角色的访问控制 (RBAC) 的核心。
- **权限 (Permission/Privilege)**: 对特定资源执行特定操作的许可。例如，"查看客户列表"、"编辑订单"等。
- **资源 (Resource)**: 系统中受保护的对象，如API端点、数据记录、文件、功能模块等。
- **访问控制列表 (ACL)**: （早期概念）直接将用户/组与资源权限关联。
- **基于角色的访问控制 (RBAC - Role-Based Access Control)**: 通过角色间接将用户与权限关联，简化权限管理。
- **基于属性的访问控制 (ABAC - Attribute-Based Access Control)**: 基于主体属性、资源属性和环境条件动态决定访问权限，更为灵活和细粒度。
- **单点登录 (SSO - Single Sign-On)**: 用户一次登录后，可以访问多个相互信任的应用系统，无需重复认证。
- **多因素认证 (MFA - Multi-Factor Authentication)**: 要求用户提供两种或以上不同类型的凭证进行身份验证，增强安全性。

## 三、认证机制设计

### 3.1 认证流程概述
1.  **凭证提交**: 主体通过客户端向认证服务提交凭证。
2.  **凭证验证**: 认证服务校验凭证的有效性（如密码比对、令牌签名验证）。
3.  **身份确认/会话建立**: 验证成功后，系统确认主体身份，并通常会建立一个安全会话或颁发一个有时效性的访问令牌。
4.  **后续请求**: 在会话有效期内或令牌有效期内，主体使用已建立的会话标识或令牌进行后续的资源访问请求。

### 3.2 常见认证方案

- **基于密码的认证**: 
    - 传统方式，用户提供用户名和密码。
    - 密码必须经过加盐哈希处理 (如BCrypt, SCrypt, Argon2) 后存储，禁止明文存储。
    - 考虑密码策略：复杂度、历史记录、过期时间。
- **基于令牌的认证 (Token-Based Authentication)**:
    - 适用于无状态服务、API、移动应用和单页应用 (SPA)。
    - **JWT (JSON Web Token)** 是一种流行实现：紧凑、自包含，可通过签名保证完整性。包含头部、载荷（声明）、签名三部分。
    - **令牌生命周期管理**: 颁发、验证、刷新（Refresh Token机制）、吊销（黑名单机制、短效令牌）。
    - **令牌存储**: 客户端应安全存储令牌 (如HTTPOnly Secure Cookie, LocalStorage/SessionStorage - 注意XSS风险)。
- **OAuth 2.1 / OpenID Connect (OIDC)**:
    - **OAuth 2.1**: 授权框架，允许第三方应用在用户授权的前提下访问其在某个服务提供商上的资源，而不暴露用户凭证。定义了多种授权流程 (Grant Types) 如授权码流程、客户端凭证流程等。
    - **OIDC**: 构建在OAuth 2.1之上的身份层，提供用户身份验证功能，并以ID Token (一种JWT) 的形式返回用户信息。
    - 适用于第三方应用授权登录、构建统一身份认证中心 (IdP - Identity Provider)。
- **API密钥 (API Keys)**:
    - 通常用于服务器到服务器的认证，或对特定API的访问控制。
    - 密钥应视为敏感凭证，妥善保管，支持轮换和吊销。
- **多因素认证 (MFA)**:
    - 结合多种认证因素，如"你知道的"（密码）、"你拥有的"（手机令牌、硬件密钥）、"你是的"（指纹、人脸）。
    - 大大增强安全性，推荐用于高敏感操作或账户。

### 3.3 多终端认证策略
- **统一认证端点**: 尽量为不同类型的客户端（Web、移动App、桌面应用、第三方服务）提供统一的认证接口和协议（如OIDC）。
- **差异化令牌策略**: 可以根据客户端类型调整令牌的有效期、刷新机制和安全要求。
- **设备绑定/信任**: (可选) 对于移动或桌面应用，可以实现设备绑定或信任设备列表，简化后续登录流程。

## 四、授权机制设计

### 4.1 授权流程概述
1.  **身份识别**: 请求到达资源服务器时，首先确认请求主体的身份（通常通过验证令牌或会话）。
2.  **权限评估**: 根据主体的身份（如用户ID、角色）和请求的资源/操作，查询权限配置，判断是否授权。
3.  **访问决策**: 允许或拒绝访问。

### 4.2 常见授权模型

- **基于角色的访问控制 (RBAC)**:
    - **核心思想**: 将权限分配给角色，再将角色分配给用户。
    - **组件**: 用户 (User)、角色 (Role)、权限 (Permission)。以及用户-角色映射、角色-权限映射。
    - **优点**: 简化了大量用户的权限管理，逻辑清晰。
    - **考量**: 角色爆炸问题（角色过多），对于非常动态或上下文相关的权限控制可能不够灵活。
- **基于属性的访问控制 (ABAC)**:
    - **核心思想**: 基于策略，策略由主体属性、资源属性、操作属性和环境属性共同决定访问权限。
    - **示例**: "允许'经理'角色的用户在'工作时间'内访问'自己部门'的'财务报表'"。
    - **优点**: 非常灵活和细粒度，能表达复杂的授权逻辑。
    - **考量**: 策略定义和管理可能较复杂，性能开销可能较高。

### 4.3 权限控制粒度
- **API端点/路由级别**: 控制对特定API接口的访问。
- **服务/方法级别**: 在代码中对服务层或具体业务方法进行权限检查。
- **数据/资源实例级别**: 控制对特定数据记录或资源实例的访问（如"用户只能编辑自己的帖子"）。实现可能较复杂，可能需要结合业务逻辑或数据过滤。

### 4.4 权限表示与存储
- **权限标识**: 通常使用字符串表示权限，如 `order:create`, `user:view_profile`, `report:financial:generate`。
- **数据模型 (概念性)**:
    - **用户 (User)**: `user_id`, `username`, 等其他身份信息。
    - **角色 (Role)**: `role_id`, `role_name`。
    - **权限 (Permission)**: `permission_id`, `permission_key` (如 `order:create`), `description`。
    - **用户-角色关联 (UserRole)**: `user_id`, `role_id`。
    - **角色-权限关联 (RolePermission)**: `role_id`, `permission_id`。
- **权限缓存**: 为提高性能，用户的权限集合可以在认证成功后加载并缓存一段时间。

## 五、核心数据实体 (概念性)

1.  **用户 (Principal/User)**: 系统的行为主体。
    *   `principal_id` (唯一标识)
    *   `username` (登录名)
    *   `hashed_password` (加盐哈希后的密码)
    *   `status` (激活、禁用、锁定等)
    *   其他身份相关属性 (邮箱、手机号、关联的角色列表等)
2.  **角色 (Role)**: 权限的集合。
    *   `role_id` (唯一标识)
    *   `role_name` (如 "管理员", "编辑", "访客")
    *   `description`
3.  **权限 (Permission)**: 对特定资源执行操作的许可。
    *   `permission_id` (唯一标识)
    *   `permission_string` (全局唯一的权限标识符, e.g., `ARTICLE_CREATE`, `USER_VIEW_ALL`)
    *   `resource_type` (可选, 关联的资源类型)
    *   `action_type` (可选, 操作类型: create, read, update, delete, execute)
    *   `description`
4.  **用户-角色映射 (UserRoleAssignment)**: 表达用户拥有哪些角色。
5.  **角色-权限映射 (RolePermissionAssignment)**: 表达角色包含哪些权限。
6.  **(可选) 令牌黑名单/吊销列表 (TokenRevocationList)**: 存储已失效或被主动吊销的令牌。

## 六、API接口设计指导原则 (概念性)

- **认证接口**: 
    - `POST /auth/login` (或 `/oauth/token`): 提交凭证，获取访问令牌和可选的刷新令牌。
    - `POST /auth/logout`: (如果支持) 使当前令牌失效或清除服务端会话。
    - `POST /auth/refresh`: 使用刷新令牌获取新的访问令牌。
    - `GET /auth/userinfo` (或 `/oauth/userinfo`): 获取当前认证用户的信息。
- **响应**: 
    - 成功登录应返回令牌信息 (访问令牌、类型如Bearer、有效期、刷新令牌)。
    - 认证失败应返回标准HTTP错误码 (如 `401 Unauthorized`) 和清晰的错误原因。
- **安全性**: 所有认证相关接口必须使用HTTPS。

## 七、安全考量与最佳实践

### 7.1 凭证管理
- **密码存储**: 始终使用强哈希算法（如BCrypt, SCrypt, Argon2）加盐存储密码。
- **密码策略**: 强制密码复杂度、长度、定期更换、历史密码校验。
- **防暴力破解**: 实现账户锁定机制（尝试次数过多后临时锁定）、验证码、IP限制。

### 7.2 令牌安全
- **令牌生成**: 使用安全的随机数生成器创建令牌，JWT签名密钥应足够复杂并妥善保管。
- **令牌传输**: 始终通过HTTPS传输令牌。
- **令牌存储 (客户端)**: 
    - Web: 优先考虑使用`HttpOnly`和`Secure`属性的Cookie。若使用LocalStorage/SessionStorage，需防范XSS攻击。
    - 移动端: 使用操作系统提供的安全存储机制 (如iOS Keychain, Android Keystore)。
- **令牌有效期**: 访问令牌 (Access Token) 应具有较短的有效期（如几分钟到几小时）。刷新令牌 (Refresh Token) 可以有较长有效期，但需安全存储且支持吊销。
- **令牌吊销**: 提供机制使令牌（特别是刷新令牌）在用户登出、密码修改或检测到安全风险时失效（如黑名单机制）。
- **JWT载荷**: 不要在JWT载荷中存放过多敏感信息，因为其内容是可读的（Base64编码）。

### 7.3 会话管理 (如果采用有状态会话)
- 使用安全的会话ID生成机制，会话ID应通过安全的Cookie传输。
- 实现会话超时、用户登出时服务端会话失效。

### 7.4 权限管理
- **最小权限原则**: 只授予主体完成其任务所必需的最小权限。
- **职责分离**: 关键操作的权限应分配给不同角色，避免单点滥用。
- **定期审计**: 定期审查用户角色和权限分配的合理性。

### 7.5 防护常见攻击
- **跨站脚本攻击 (XSS)**: 对所有用户输入进行严格验证和清理，对输出到页面的内容进行恰当编码。
- **跨站请求伪造 (CSRF)**: 使用CSRF令牌、SameSite Cookie属性、校验Referer头等方法防御。
- **点击劫持 (Clickjacking)**: 使用`X-Frame-Options`响应头或CSP `frame-ancestors`指令。
- **重放攻击**: 令牌或请求中包含一次性随机数 (Nonce) 或时间戳，并进行校验。

### 7.6 错误处理与日志审计
- **错误信息**: 避免在错误信息中泄露过多系统内部细节或敏感信息。
- **日志记录**: 详细记录所有认证尝试（成功与失败）、授权决策、权限变更、管理员操作等安全相关事件。
- **监控与告警**: 对异常登录行为、权限滥用尝试等设置监控和告警。

## 八、技术选型考量 (通用)

- **认证与授权框架**: 如Spring Security (Java), Passport.js (Node.js), IdentityServer ( .NET), Keycloak (独立IdP)。选择时考虑社区支持、成熟度、功能集、与现有技术栈的集成。
- **令牌实现**: JWT是常用标准。考虑库的安全性、易用性。
- **数据存储**: 用于存储用户、角色、权限信息的数据库选型。考虑数据一致性、查询性能。
- **缓存服务**: 用于缓存权限数据、令牌黑名单等。考虑性能、可靠性。

## 九、演进与扩展

- **逐步引入MFA**: 从高权限用户或敏感操作开始逐步推广多因素认证。
- **支持联合身份认证 (Federated Identity)**: 如通过SAML或OIDC与外部身份提供商集成。
- **权限模型演进**: 从RBAC向更细粒度的ABAC演进，以适应更复杂的业务需求。
- **API安全性增强**: 考虑引入API网关统一处理部分安全策略，实现更精细的API访问控制。

---
> 本文档为认证与授权模块的设计提供了通用指南，旨在构建一个安全、可靠、灵活的身份验证和访问控制体系。具体实现需根据业务需求和所选技术栈进行适配。 

---

## 文件 26: 后端-日志审计-后端开发文档.md

*文件大小：11.98 KB*

---

# 日志审计模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
日志审计模块是保障系统安全性、满足合规性要求、以及支持问题排查和行为分析的关键基础设施。它负责全面、准确、安全地记录用户及系统在平台上的关键操作和重要事件，并提供高效的查询与分析能力。

### 1.2 设计目标
- **全面性**: 覆盖所有需要审计的关键操作和系统事件。
- **准确性**: 保证日志信息的真实和精确，记录足够上下文。
- **安全性与完整性**: 保护审计日志不被未授权访问、篡改或删除。
- **高效性**: 日志的记录不应显著影响主业务流程性能；日志查询应高效便捷。
- **可追溯性**: 能够根据日志清晰追溯操作行为和事件发生过程。
- **合规性**: 满足相关法律法规和行业标准对日志记录和保存的要求。
- **易用性**: 提供方便的日志查询、筛选和导出功能。

## 二、模块概述

本模块专注于记录系统中用户执行的关键操作、系统自动触发的重要事件以及可能的安全相关事件。这些日志用于后续的审计追踪、用户行为分析、系统故障排查、安全事件响应和满足合规性审查。模块通常包括日志的收集、存储、管理、查询和分析等功能。

## 三、核心概念与架构组件

### 3.1 核心概念
- **审计日志 (Audit Log) / 操作日志 (Operation Log)**: 一条记录，描述了"谁 (Who)"在"什么时间 (When)"从"哪里 (Where)"对"什么对象 (What)"执行了"什么操作 (Which Action)"以及"结果如何 (Outcome)"。
- **事件源 (Event Source)**: 产生需要记录日志的操作或事件的模块或服务。
- **操作主体 (Actor/Principal)**: 执行操作的用户、系统进程或API客户端。通常包含用户ID、用户名、角色等。
- **操作对象 (Target/Resource)**: 操作所作用的目标实体，如某个订单、某篇文档、某个配置项。包含对象类型和对象ID。
- **操作类型 (Action Type)**: 具体执行的操作，如创建、更新、删除、登录、授权、审批等。
- **操作上下文 (Context)**: 与操作相关的额外信息，如IP地址、User-Agent、会话ID、请求参数、变更前后的数据快照等。
- **日志级别 (Severity/Level, 可选)**: 区分日志的重要性，如INFO, WARNING, ERROR, CRITICAL。

### 3.2 关键技术考量
- **日志收集方式**:
    - *AOP (Aspect-Oriented Programming)*: 通过切面自动拦截方法调用并记录日志，对业务代码侵入小。适用于记录特定Service层方法的调用。
    - *拦截器/过滤器 (Interceptors/Filters)*: 在Web框架层面拦截HTTP请求，记录API调用日志。
    - *事件监听机制*: 订阅系统内部的关键业务事件并记录日志。
    - *手动埋点*: 在业务代码中显式调用日志记录接口。灵活性高，但维护成本也高。
- **异步处理**: 日志记录应异步执行，避免阻塞主业务线程。通常通过消息队列 (MQ) 实现。
- **日志存储方案**:
    - *关系型数据库 (RDBMS)*: 适用于日志量不大、查询需求相对简单的场景。需要考虑定期归档和性能优化。
    - *NoSQL数据库 (如MongoDB, Elasticsearch)*: Elasticsearch特别适合日志存储和全文检索，是ELK/EFK Stack的核心。MongoDB等文档数据库也常用于存储半结构化的日志数据。
    - *专用日志管理系统 (如Splunk, LogRhythm, Graylog)*: 提供更全面的日志收集、存储、分析、告警和可视化功能。
- **日志格式**: 采用结构化日志格式（如JSON），方便机器解析、查询和分析。避免纯文本日志。
- **敏感信息处理**: 必须对日志中可能出现的敏感信息（如密码、密钥、身份证号、银行卡号）进行脱敏、加密或不记录处理。
- **日志轮转与归档 (Log Rotation & Archiving)**: 制定策略定期将旧日志从主存储归档到低成本存储，并清理过期日志，防止存储无限增长。

## 四、核心数据实体/模型 (以存储在数据库为例)

**审计日志 (AuditLogEntry)**
*   `log_id` (主键): 日志条目的唯一标识符。
*   `timestamp` (时间戳, 必填): 操作或事件发生的时间。
*   `actor_id` (字符串, 可选): 操作主体的ID (如用户ID)。
*   `actor_name` (字符串, 可选): 操作主体的名称 (如用户名)。
*   `actor_type` (枚举, 可选): 主体类型 (USER, SYSTEM, API_CLIENT)。
*   `ip_address` (字符串, 可选): 操作来源IP地址。
*   `user_agent` (字符串, 可选): 客户端User-Agent。
*   `session_id` (字符串, 可选): 会话ID。
*   `action_type` (字符串, 必填): 操作类型/事件名称 (如 "USER_LOGIN", "ORDER_CREATE", "CONFIG_UPDATE")。
*   `resource_type` (字符串, 可选): 被操作资源的类型 (如 "Order", "User", "Product")。
*   `resource_id` (字符串, 可选): 被操作资源的ID。
*   `operation_status` (枚举, 必填: SUCCESS, FAILURE, PENDING): 操作结果状态。
*   `request_details` (JSON/文本, 可选): 请求参数或操作的输入数据 (注意脱敏)。
*   `response_details` (JSON/文本, 可选): 操作的输出结果或错误信息 (注意脱敏)。
*   `data_before_change` (JSON/文本, 可选): (对于修改操作) 变更前的数据快照。
*   `data_after_change` (JSON/文本, 可选): (对于修改操作) 变更后的数据快照。
*   `description` (文本, 可选): 对操作的简要描述或备注。
*   `correlation_id` (字符串, 可选): 用于追踪跨服务调用的关联ID。
*   `service_name` (字符串, 可选): 产生日志的服务/模块名称。

## 五、功能模块划分

1.  **日志收集代理/SDK (Log Collector/SDK)**
    *   提供API或注解，供业务模块方便地发送日志数据。
    *   负责日志数据的初步格式化和元数据附加（如时间戳、服务名）。
    *   (可选) 本地缓存和批量发送，以减少对消息队列或后端存储的直接压力。
2.  **日志处理与丰富模块 (Log Processing & Enrichment)**
    *   (通常在MQ消费者或日志摄入管道中) 对原始日志进行解析、校验、格式转换。
    *   丰富日志内容，如根据IP地址补充地理位置信息，根据用户ID补充用户信息等。
3.  **日志存储模块 (Log Storage)**
    *   将处理后的日志数据持久化到选定的存储系统。
    *   负责索引的创建和管理，以支持高效查询。
4.  **日志查询与分析接口 (Log Query & Analysis API)**
    *   提供API接口，支持根据多种条件（如时间范围、操作主体、操作类型、资源ID等）进行日志的筛选、排序和分页查询。
    *   (可选) 支持聚合分析功能。
5.  **日志管理与运维模块**
    *   日志的轮转、归档、清理策略的配置与执行。
    *   监控日志系统本身的健康状况（如积压、写入/查询性能）。
    *   (可选) 审计日志自身的访问和修改记录（元审计）。

## 六、API接口设计指导原则 (主要指查询接口)

- **资源**: `audit-logs` 或 `operation-logs`。
- **查询API**: (示例)
    - `GET /audit-logs`: 获取审计日志列表。
        *   支持参数：`startTime`, `endTime`, `actorId`, `actionType`, `resourceType`, `resourceId`, `status`, `ipAddress`, `page`, `size`, `sortBy`, `sortOrder`。
        *   支持自由文本搜索（如果后端使用Elasticsearch等支持全文检索的存储）。
    - `GET /audit-logs/{log_id}`: 获取单条审计日志详情。
- **安全性**: 查询接口本身需要严格的权限控制，只有授权用户（如管理员、审计员）才能访问。
- **性能**: 查询接口应针对常见查询模式进行优化。避免无限制的查询，强制分页。
- **导出功能**: (可选) 提供将查询结果导出为CSV、JSON等格式的功能。

## 七、主要业务流程示例

### 1. 用户登录操作的日志记录流程 (使用AOP和MQ)
    1.  用户在登录界面输入用户名密码，点击登录。
    2.  请求到达后端认证服务的登录处理方法。
    3.  配置在登录方法上的AOP切面被触发（例如，`@AuditLoggable(action="USER_LOGIN")`注解）。
    4.  切面逻辑捕获方法参数（用户名）、当前用户信息（如果部分已认证）、IP地址、User-Agent等。
    5.  登录方法执行，认证服务判断登录成功或失败。
    6.  AOP切面在方法执行后，获取执行结果（成功/失败，用户ID等）。
    7.  切面组装一条审计日志消息（包含上述所有信息），发送到消息队列 (MQ) 的审计日志主题。
    8.  独立的日志消费服务从MQ消费该消息。
    9.  日志消费服务对消息进行处理（如格式化、丰富化），然后将其存入Elasticsearch或数据库。

### 2. 管理员查询特定用户操作日志的流程
    1.  管理员在后台管理界面的审计日志查询页面。
    2.  输入筛选条件：用户ID = "user123", 时间范围 = "过去7天"，操作类型 = "ORDER_UPDATE"。
    3.  前端将这些条件作为参数，调用后端的 `GET /audit-logs` API。
    4.  API后端接收请求，根据参数构建查询语句（如Elasticsearch的DSL查询）。
    5.  向日志存储（如Elasticsearch）执行查询。
    6.  获取查询结果（分页数据），返回给前端。
    7.  前端将日志列表展示给管理员。

## 八、技术考量与开发注意事项

1.  **日志覆盖范围**: 仔细规划哪些操作是"关键操作"必须记录。不足或过多都可能带来问题。
2.  **日志内容详细程度**: 既要包含足够信息用于追溯，又要避免记录过多冗余或敏感数据。平衡信息量与存储成本/查询性能。
3.  **敏感信息处理**: 严格遵守数据保护法规（如GDPR, CCPA），对日志中的个人身份信息 (PII) 和其他敏感数据进行脱敏、加密或匿名化处理。制定明确的脱敏规则。
4.  **异步记录与性能影响**: 确保日志记录过程对主业务性能影响最小化。使用异步写入，合理配置MQ和消费者。
5.  **存储选型与容量规划**: 根据预期日志量、保留周期、查询需求选择合适的存储方案。定期评估容量并进行扩展或归档。
6.  **查询性能**: 为常用查询字段创建索引。对于大数据量，优化查询语句，或使用专门的日志分析工具。
7.  **日志的不可否认性与完整性保护**: (高级特性) 可考虑使用数字签名或区块链技术确保日志不被篡改。严格控制对日志存储系统的直接访问权限。
8.  **日志轮转与归档策略**: 定义清晰的日志保留策略（如在线保留30天，归档保留1年），并自动化执行。
9.  **标准化**: 尽可能统一整个系统的日志格式和字段定义，便于集中管理和分析。
10. **与监控告警集成**: (可选) 将某些关键审计事件（如多次登录失败、高危操作）接入监控告警系统。

## 九、数据校验与错误处理 (针对日志系统本身)

1.  **日志数据校验**: 日志收集端或处理端应对日志数据的基本格式和必填字段进行校验。
2.  **写入失败处理**: 如果日志写入MQ或最终存储失败，应有重试机制和错误记录，避免日志丢失。
3.  **消费者异常处理**: MQ消费者在处理日志消息时发生异常，应能妥善处理，避免消息丢失或无限重试阻塞队列。

## 十、安全性考量 (针对审计日志系统自身)

1.  **访问控制**: 严格控制对审计日志查询接口和存储系统的访问权限。只有授权人员可查看审计日志。
2.  **防篡改**: 保护审计日志存储不被未授权修改或删除。定期备份。
3.  **传输安全**: 日志数据在传输过程中（如从应用到MQ，从MQ到存储）应加密。
4.  **元审计 (Self-Auditing)**: (可选) 记录对审计日志系统本身的管理操作（如配置更改、用户权限分配）和对审计日志的查询访问记录。
5.  **敏感数据暴露风险**: 即使经过脱敏，也需评估日志查询结果中是否存在间接暴露敏感信息的风险。 

---

## 文件 27: 后端-社群运营-后端开发文档.md

*文件大小：1.30 KB*

---

### 社群运营模块后端开发文档

#### 模块概述

负责社群（如微信群、企业微信群）的创建、管理、成员同步、消息发送、群数据统计等功能。

#### 后端技术栈

- 主要技术：Spring Boot, MyBatis-Plus
- 数据库：MySQL
- 缓存：Redis
- 第三方平台API集成 (如 企业微信API)
- 消息队列 (如 RabbitMQ, Kafka) - 用于异步消息处理、成员同步

#### 核心实体与数据表

- 社群表 (community)
- 社群成员表 (community_member)
- 群消息记录表 (community_message_log)
- 欢迎语/SOP 配置表 (welcome_message, sop_config)

#### 主要API接口

- GET /api/communities: 获取社群列表
- GET /api/communities/{id}: 获取社群详情
- POST /api/communities: 创建新社群 (通过第三方API)
- PUT /api/communities/{id}: 更新社群信息
- DELETE /api/communities/{id}: 删除社群
- GET /api/communities/{id}/members: 获取社群成员列表
- POST /api/communities/{id}/messages: 发送群消息
- POST /api/communities/{id}/sync-members: 同步群成员
- PUT /api/communities/{id}/welcome-message: 配置群欢迎语

#### 开发注意事项

- 与第三方社群平台API的稳定集成。
- 大量群成员和消息的处理能力。
- 消息发送的频率控制和合规性。
- 社群数据的实时同步和统计分析。 

---

## 文件 28: 后端-首页功能开发文档.md

*文件大小：8.51 KB*

---

# 应用首页模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块作为应用的核心入口界面，负责汇总和展示用户最关注的业务数据概览、关键指标和快捷功能入口。首页是用户体验的重要组成部分，通过数据可视化和便捷操作提升用户工作效率，并引导用户使用系统的核心功能。

### 1.2. 设计目标
- **数据整合**: 汇总全系统关键业务数据，提供全局数据视图
- **个性化展示**: 根据用户角色和权限提供个性化的数据和功能
- **快捷入口**: 提供常用功能的快速访问链接，减少操作路径
- **实时更新**: 保证关键业务指标的及时更新和显示
- **高性能**: 确保首页快速加载，提供良好的用户体验

## 2. 核心概念

- **业务概览 (Business Overview)**: 汇总展示的关键业务指标和数据
- **快捷入口 (Quick Access)**: 常用功能的快速访问链接
- **数据卡片 (Data Card)**: 展示特定业务数据的界面组件
- **趋势图表 (Trend Chart)**: 展示数据随时间变化的可视化图表
- **通知消息 (Notification)**: 系统公告、提醒和个人消息
- **待办事项 (Pending Tasks)**: 需要用户处理的任务或事项
- **数据汇总 (Data Aggregation)**: 从多个业务模块收集和整合数据的过程

## 3. 核心数据实体/模型 (Conceptual)

- **`DashboardData` (首页数据)**
    - `businessMetrics` (核心业务指标)
    - `quickAccessLinks` (快捷入口链接)
    - `recentActivities` (近期活动/消息)
    - `pendingTasks` (待处理任务)
    - `trendData` (趋势数据)

- **`BusinessMetric` (业务指标)**
    - `metricId` (指标唯一标识)
    - `name` (指标名称)
    - `value` (指标当前值)
    - `unit` (指标单位)
    - `trend` (与上期相比的趋势)
    - `growthRate` (增长率)
    - `category` (指标分类)

- **`QuickAccessLink` (快捷入口)**
    - `linkId` (链接唯一标识)
    - `name` (链接名称)
    - `icon` (图标标识)
    - `url` (目标链接或路由)
    - `permission` (所需权限)
    - `relatedMetric` (关联的数据指标)

- **`RecentActivity` (近期活动)**
    - `activityId` (活动唯一标识)
    - `title` (活动标题)
    - `description` (活动描述)
    - `time` (发生时间)
    - `type` (活动类型)
    - `status` (活动状态)
    - `related` (相关实体引用)

- **`TrendData` (趋势数据)**
    - `trendId` (趋势数据唯一标识)
    - `name` (趋势名称)
    - `timePoints` (时间点列表)
    - `dataPoints` (数据点列表)
    - `unit` (数据单位)
    - `category` (趋势分类)

## 4. 功能模块划分

### 4.1. 数据汇总核心模块
- **功能**:
    - 收集和整合各业务模块的核心数据
    - 计算派生指标和汇总统计
    - 提供统一的首页数据访问接口
- **主要接口 (Conceptual)**:
    - 首页概览数据查询
    - 业务指标详情查询

### 4.2. 快捷功能入口管理模块
- **功能**:
    - 管理常用功能入口列表
    - 根据用户权限和角色过滤功能入口
    - 支持个性化定制功能入口
- **主要接口 (Conceptual)**:
    - 快捷入口列表查询
    - 个人快捷入口配置

### 4.3. 通知与活动模块
- **功能**:
    - 管理系统公告、提醒和个人消息
    - 按优先级和时间顺序排序活动信息
    - 提供消息已读和处理状态标记
- **主要接口 (Conceptual)**:
    - 最新通知查询
    - 消息已读标记
    - 通知详情查询

### 4.4. 趋势分析模块
- **功能**:
    - 收集指定业务指标随时间变化的数据
    - 计算趋势和增长率
    - 生成图表数据格式输出
- **主要接口 (Conceptual)**:
    - 趋势数据查询
    - 多指标比较分析

## 5. 主要业务流程示例

### 5.1. 首页数据加载流程
1. 用户登录系统后，前端请求首页概览数据。
2. 后端根据用户ID和权限校验授权状态。
3. 后端从缓存或各模块服务获取用户可访问的业务数据。
4. 后端整合数据，计算需要的派生指标。
5. 后端根据用户角色和权限过滤数据，并返回个性化的首页数据。
6. 前端接收数据并进行渲染展示。

### 5.2. 快捷入口加载与使用流程
1. 用户请求快捷入口列表数据。
2. 后端根据用户权限获取该用户可访问的功能入口列表。
3. 后端关联每个入口的最新数据指标（如有），并返回前端。
4. 前端展示快捷入口图标和关联数据。
5. 用户点击快捷入口，前端导航至对应功能页面。

### 5.3. 趋势数据分析流程
1. 用户请求特定业务指标的趋势数据。
2. 后端验证用户对该数据的访问权限。
3. 后端从时序数据存储或预计算结果中获取历史数据点。
4. 后端处理数据，计算趋势、环比等分析指标。
5. 后端返回处理后的图表数据格式。
6. 前端接收数据并使用图表库进行可视化展示。

## 6. 技术考量与开发注意事项

### 6.1. 数据整合与性能
- **服务聚合**: 使用适当的模式（如API聚合、数据复制、事件驱动）整合多个业务模块的数据
- **缓存策略**: 对频繁访问的数据实施多级缓存策略
  - 对变化不频繁的数据可使用较长的缓存时间
  - 对实时性要求高的数据使用短期缓存或实时查询
- **异步加载**: 采用异步方式加载非关键数据，优先展示核心指标
- **数据预计算**: 对于复杂计算的统计数据，定时预计算并存储结果

### 6.2. 数据安全与权限控制
- **访问控制**: 严格基于用户角色和权限过滤数据和功能入口
- **数据脱敏**: 对敏感业务数据进行适当脱敏处理
- **审计日志**: 记录关键数据访问操作，以便追踪和审计
- **数据分级**: 根据数据敏感度和重要性实施分级展示策略

### 6.3. 实时性与一致性
- **数据实时性**: 根据业务需求平衡数据实时性和系统性能
  - 对关键指标可采用推送机制实现准实时更新
  - 使用适当的缓存失效策略确保数据及时刷新
- **数据一致性**: 确保跨模块数据在时间维度上的一致性
  - 统一数据时间戳标准
  - 考虑数据加载顺序对一致性的影响

### 6.4. 可扩展性设计
- **模块化设计**: 采用模块化设计，便于添加新的数据卡片和功能
- **配置驱动**: 使用配置驱动的方式定义业务指标和展示内容
- **插件架构**: 考虑使用插件架构支持第三方数据源和可视化组件
- **前后端分离**: 明确前后端职责边界，提供标准化的数据接口

## 7. 接口设计指导原则 (Conceptual)

### 7.1. 首页概览数据接口
- **功能描述**: 获取用户首页展示的关键数据
- **请求参数**: 用户标识、客户端类型、数据范围参数等
- **返回数据**: 业务核心指标、趋势数据、通知消息等综合信息

### 7.2. 快捷入口列表接口
- **功能描述**: 获取首页展示的常用功能快捷入口
- **请求参数**: 用户标识、客户端类型等
- **返回数据**: 功能入口列表，包含名称、图标、链接、关联数据等

### 7.3. 趋势数据接口
- **功能描述**: 获取特定指标的历史趋势数据
- **请求参数**: 指标标识、时间范围、时间粒度等
- **返回数据**: 时间点列表、数据点列表、单位、增长率等

### 7.4. 通知消息接口
- **功能描述**: 获取用户的最新通知和消息
- **请求参数**: 用户标识、消息类型、数量限制等
- **返回数据**: 通知消息列表，包含标题、时间、类型等信息

## 8. 数据校验与错误处理

### 8.1. 常见数据校验规则
- **用户认证**: 验证用户身份和会话有效性
- **权限验证**: 确认用户对请求数据的访问权限
- **参数验证**: 验证时间范围、筛选条件等参数的有效性

### 8.2. 错误处理策略
- **服务不可用**: 当某个业务模块服务不可用时，返回其他可用数据，并标记不可用部分
- **数据异常**: 对明显异常的数据进行合理处置，避免前端展示错误数据
- **权限不足**: 明确提示权限不足的错误信息，指引用户获取权限的途径
- **系统错误**: 记录详细错误日志，返回友好错误提示

## 9. 可扩展性与定制化

- **个性化配置**: 支持用户自定义首页布局和关注的数据指标
- **业务指标扩展**: 提供标准机制添加新的业务指标和数据源
- **主题样式**: 支持不同的主题样式和展示方式
- **多端适配**: 为不同终端设备提供适配的数据结构和展示策略

--- 

---

## 文件 29: 后端-数据库配置开发文档.md

*文件大小：10.40 KB*

---

# 数据库与缓存服务配置指南

## 一、概述

本指南旨在为后端开发人员提供关于配置和管理数据存储与缓存服务的通用规范和最佳实践。合理的配置对于系统性能、可靠性和可维护性至关重要。我们将讨论关系型数据库、NoSQL数据库以及缓存服务配置的核心要素、多环境策略、连接管理和事务控制等。

## 二、核心数据存储配置 (例如：关系型数据库、文档数据库等)

### 1. 基础配置要素

无论选择何种类型的核心数据存储，以下配置要素通常是必需的：

-   **连接参数**:
    *   服务器地址 (Hostname/IP)
    *   端口号
    *   数据库实例名或集合名
    *   字符集/编码 (例如 UTF-8)
-   **认证凭据**:
    *   用户名
    *   密码或认证令牌
    *   (可选) 认证机制或数据库
-   **连接池管理**:
    *   初始连接数 (Initial Size): 系统启动时预创建的连接数量。
    *   最小空闲连接数 (Min Idle): 连接池中应保持的最小备用连接数。
    *   最大活动连接数 (Max Active/Total): 连接池允许创建和管理的最大连接总数。
    *   连接获取超时 (Connection Timeout): 应用程序等待从池中获取连接的最大时长。
    *   最大空闲时间 (Max Idle Time): 连接在被关闭前可以保持空闲的最长时间。
    *   连接最大生命周期 (Max Lifetime): 单个连接可以存活的最长时间，有助于防止陈旧连接。
    *   连接有效性检测 (Connection Validation): 定期检查池中连接是否仍然有效的机制（例如，执行一个简单的查询）。
-   **性能与行为配置**:
    *   语句缓存 (Prepared Statement Cache): 是否以及如何缓存预编译的SQL语句或查询模板。
    *   超时设置 (Query Timeout, Transaction Timeout): 控制查询执行和事务的超时时间。
    *   日志与监控 (Logging & Monitoring): 配置数据库操作日志、慢查询日志以及性能指标的收集。
-   **安全考量**:
    *   传输层加密 (TLS/SSL): 配置客户端与数据库服务器之间的加密连接。
    *   参数化查询/预编译语句: 作为防止SQL注入等攻击的基本措施。

### 2. 多环境配置策略

为确保开发、测试和生产环境的稳定性和隔离性，应采用以下策略：

-   **环境隔离**: 每个环境（如开发、测试、预发布、生产）应使用完全独立的数据库实例。
-   **配置外部化**:
    *   数据库连接信息和其他敏感配置不应硬编码在应用程序代码中。
    *   应使用环境变量、专门的配置文件（如 `.env`, `config.json`, `application.properties` 等，具体格式依技术栈而定）或配置中心服务来管理这些配置。
-   **按环境加载配置**: 应用程序应能根据当前运行环境自动加载相应的数据库配置。
-   **权限最小化原则**:
    *   为每个环境的数据库连接使用不同的用户账户。
    *   授予每个账户完成其任务所必需的最小权限集合。例如，生产环境的应用程序账户可能只有读写特定表的权限，而没有修改表结构或管理用户的权限。
-   **敏感信息保护**: 生产环境的数据库密码等敏感凭据应通过安全的方式管理和注入，例如使用密钥管理服务或安全的配置注入机制。

### 3. 数据源抽象与管理

在应用程序层面，数据源的配置和管理应考虑以下设计：

-   **配置绑定**: 将外部配置项（来自文件、环境变量或配置中心）灵活地映射到应用程序内部的数据源对象属性。
-   **生命周期管理**:
    *   应用程序启动时，应能正确初始化数据源（包括连接池的创建）。
    *   应用程序关闭时，应能优雅地关闭数据源，释放所有数据库连接和相关资源。
-   **健康检查接口**: (可选) 提供一个端点或机制，允许监控系统检查数据源的健康状态。
-   **日志记录**: 在数据源初始化、连接获取/释放、发生错误等关键节点记录详细日志，便于问题排查。

## 三、缓存服务配置 (例如：Redis, Memcached)

缓存服务对于提升应用性能、降低后端负载至关重要。

### 1. 基础配置要素

-   **连接参数**:
    *   服务器地址 (Hostname/IP)
    *   端口号
-   **认证凭据**:
    *   密码 (如果缓存服务配置了密码保护)
-   **数据库/命名空间**: (如果适用) 某些缓存服务支持多个逻辑数据库或命名空间。
-   **连接池管理**: (与核心数据存储类似)
    *   最大活动连接数
    *   最大/最小空闲连接数
    *   连接获取超时
-   **超时与重试**:
    *   操作超时 (Operation Timeout): 执行缓存操作（如GET, SET）的超时时间。
    *   连接重试策略: 当连接失败时的重试次数和间隔。
-   **序列化机制**:
    *   选择合适的序列化方式（如JSON, Protobuf, Java Serialization等）来存储和检索缓存对象。
    *   需考虑性能、跨语言兼容性和数据大小。

### 2. 集群与高可用配置 (如适用)

对于生产环境，缓存服务通常需要集群化以实现高可用性和可扩展性：

-   **节点信息**: 列出集群中所有节点的地址和端口。
-   **集群模式**: 指明是主从复制模式、哨兵模式还是分片集群模式。
-   **故障转移与路由**:
    *   最大重定向次数 (Max Redirects): 在集群模式下，当一个节点指示数据在另一个节点时，客户端应尝试的最大重定向次数。
    *   读写策略: 配置读操作是从节点读取还是主节点读取。

### 3. 缓存策略与管理

-   **默认过期时间 (Default TTL)**: 为缓存条目设置一个全局的默认生存时间。
-   **空值缓存 (Caching Null Values)**: 决定是否缓存表示"未找到"的空结果，以防止缓存穿透。
-   **缓存预热 (Cache Warming)**: (可选) 系统启动时预先加载常用数据到缓存中。
-   **缓存淘汰策略 (Eviction Policy)**: 当缓存达到容量上限时，选择何种策略（如LRU, LFU, FIFO）来移除旧的或不常用的条目。

## 四、多数据源与事务管理考量

在某些复杂场景下，应用程序可能需要连接和操作多个不同的数据存储实例或类型。

### 1. 多数据源配置原则

-   **明确区分**: 清晰地定义每个数据源的用途（例如，主数据库用于写操作，从数据库用于读操作；或一个数据库用于用户数据，另一个用于订单数据）。
-   **独立配置**: 为每个数据源提供独立的连接参数、连接池设置等。
-   **动态路由 (可选)**: 如果应用需要根据上下文（如请求类型、用户区域）动态选择数据源，则需要实现相应的路由逻辑。
-   **配置示例 (概念性)**:
    ```
    data_sources:
      primary_db:
        driver: "com.mysql.cj.jdbc.Driver" # 示例，实际驱动根据数据库类型而定
        url: "jdbc:mysql://master-db-host:3306/main_app_db"
        username: "app_writer"
        password: "${DB_MASTER_PASSWORD}" # 从环境变量或安全存储获取
        pool_options:
          max_connections: 50
          min_idle_connections: 5
      read_replica_db:
        driver: "com.mysql.cj.jdbc.Driver"
        url: "jdbc:mysql://read-replica-host:3306/main_app_db"
        username: "app_reader"
        password: "${DB_REPLICA_PASSWORD}"
        read_only: true
        pool_options:
          max_connections: 100
          min_idle_connections: 10
      analytics_db:
        type: "elasticsearch" # 示例，表明可以是不同类型的数据库
        hosts: ["es-node1:9200", "es-node2:9200"]
        # ...其他特定于Elasticsearch的配置
    ```

### 2. 事务管理

-   **本地事务**: 当操作仅限于单个数据库实例时，使用该数据库提供的标准事务机制。
-   **分布式事务 (谨慎使用)**:
    *   当一个业务操作需要跨多个数据库实例或不同类型的数据库（例如，一个关系型数据库和一个消息队列）并保持原子性时，可能需要分布式事务。
    *   常见的解决方案包括两阶段提交 (2PC)、Saga模式、TCC (Try-Confirm-Cancel) 模式等。
    *   分布式事务会显著增加系统复杂性和开销，应优先考虑通过业务流程设计或最终一致性来避免。
-   **事务传播行为**: 定义当一个事务方法调用另一个事务方法时，事务上下文如何传播（例如，总是启动新事务、加入现有事务、不支持事务等）。
-   **事务隔离级别**: 根据业务需求选择合适的事务隔离级别（如读未提交、读已提交、可重复读、串行化），以平衡数据一致性和并发性能。
-   **声明式与编程式事务**:
    *   **声明式**: 通过注解或配置来管理事务边界，是推荐的方式，代码更简洁。
    *   **编程式**: 在代码中显式控制事务的开始、提交和回滚，用于更细粒度的控制。

## 五、安全与监控

### 1. 安全最佳实践

-   **凭证管理**:
    *   绝不在代码版本控制中存储明文密码或密钥。
    *   使用环境变量、外部配置文件、Vault等密钥管理工具或云服务商提供的秘密管理服务。
-   **网络隔离**:
    *   限制数据库服务器的网络访问，只允许必要的应用服务器IP访问。
    *   如果可能，将数据库置于私有网络中。
-   **定期审计与更新**:
    *   定期审计数据库用户权限。
    *   及时更新数据库软件和驱动程序到最新稳定版，以修补已知漏洞。
-   **备份与恢复**:
    *   制定并定期测试数据备份和恢复计划。

### 2. 监控要点

-   **连接池指标**:
    *   活动连接数、空闲连接数、等待连接的线程数。
    *   连接获取/释放频率、连接创建/销毁频率。
-   **查询性能**:
    *   平均查询响应时间、慢查询数量和详情。
    *   查询吞吐量 (QPS)。
-   **数据库资源使用**:
    *   CPU、内存、磁盘I/O、网络带宽。
    *   数据库连接数、锁等待情况。
-   **缓存命中率**: 对于缓存服务，监控缓存命中率是评估其有效性的关键指标。
-   **错误与异常**: 监控数据库操作相关的错误和异常数量及类型。

通过实施这些配置指南和最佳实践，可以构建一个健壮、高效且易于维护的后端数据层。具体的实现细节会因所选技术栈和业务需求而有所不同，但核心原则保持不变。 

---

## 文件 30: 后端-数据统计-后端开发文档.md

*文件大小：20.54 KB*

---

# 数据统计与分析模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
数据统计与分析模块是现代应用系统中不可或缺的核心组件，旨在将原始业务数据转化为有价值的洞察，从而驱动明智的业务决策、优化运营策略、提升用户体验和促进业务增长。它为运营、市场、产品及管理团队提供理解业务表现、发现趋势、衡量KPI达成情况的关键数据支持。

### 1.2 设计目标
- **准确性与一致性**: 提供精确、可靠的数据，确保跨不同报表和指标的数据口径一致。
- **及时性**: 根据业务需求提供近实时或准实时的数据更新，以及高效的离线批量处理能力。
- **全面性与多维度**: 覆盖核心业务流程的关键绩效指标 (KPIs)，支持从多个维度（如时间、渠道、用户属性、产品分类等）进行数据钻取和分析。
- **高性能与可伸缩性**: 高效处理大规模数据集的聚合、查询和展示，系统架构应支持水平扩展以应对数据量和并发访问的增长。
- **易用性与可视化**: 提供清晰易懂的数据展现方式（通过API或与BI工具集成），支持用户友好的查询和自定义报表功能。
- **安全性与合规性**: 确保数据的安全存储和访问，遵守数据隐私法规（如GDPR, CCPA），对敏感数据进行脱敏或聚合处理。
- **可维护性与可扩展性**: 统计逻辑、数据模型和ETL流程应易于维护和扩展，以适应业务变化和新的分析需求。

## 二、模块概述

本模块负责平台内各类运营数据的收集、清洗、转换、聚合、存储和分析展示。它涵盖了从原始数据源（如业务数据库、应用日志、用户行为埋点）到最终统计报表和分析洞察的全链路数据处理。主要功能包括但不限于：用户行为分析、业务运营指标统计（如订单、销售额）、产品性能分析、营销活动效果评估、用户画像构建等。模块最终通过API接口或与商业智能(BI)工具集成，向上层应用或数据分析人员提供服务。

## 三、API接口设计原则与示例

数据统计与分析模块的API主要用于提供聚合后的统计数据和分析结果。API设计应遵循RESTful原则，确保接口的清晰性、一致性和易用性。

### 3.1 通用设计原则
- **资源化**: 将可查询的统计指标或报表视为资源。
- **标准化参数**: 对时间范围、维度、度量、筛选条件、分页、排序等使用标准化的查询参数。
- **统一响应格式**: 返回结构化的JSON数据，包含清晰的元数据和数据体。
- **版本控制**: 对API进行版本管理。
- **安全性**: 所有API均需认证授权。
- **性能考量**: API应高效响应，避免执行耗时过长的实时计算，优先返回预计算或缓存数据。

### 3.2 示例：获取概览统计数据

- **功能描述**: 获取平台在指定时间范围内的核心运营指标概览。
- **HTTP方法**: `GET`
- **资源路径 (概念性)**: `/statistics/overview`
- **请求参数 (Query Parameters)**:

| 参数名          | 类型    | 是否必需 | 描述                                       | 示例值                       |
|-----------------|--------|----------|--------------------------------------------|------------------------------|
| `start_time`    | string | 否       | 统计开始时间 (ISO 8601 UTC格式)             | "2023-10-01T00:00:00Z"      |
| `end_time`      | string | 否       | 统计结束时间 (ISO 8601 UTC格式)             | "2023-10-31T23:59:59Z"      |
| `time_zone`     | string | 否       | (可选) 查询时区，若不传则默认为UTC或系统配置 | "Asia/Shanghai"              |

- **响应数据示例 (JSON):**

```json
{
  "query_parameters": {
    "start_time": "2023-10-01T00:00:00Z",
    "end_time": "2023-10-31T23:59:59Z"
  },
  "data": {
    "total_users": 15000,
    "new_users_in_period": 1500,
    "active_users_in_period": 8000,
    "total_orders": 8000,
    "orders_in_period": 500,
    "total_sales_amount": 1200000.50,
    "sales_amount_in_period": 85000.00,
    "average_order_value_in_period": 170.00
    // ... 其他可配置的概览指标
  }
}
```

### 3.3 示例：获取趋势性统计数据 (例如：用户增长趋势)

- **功能描述**: 查询某一指标（如新增用户数、活跃用户数、订单量）在指定时间范围内按特定时间粒度（天、周、月）的趋势。
- **HTTP方法**: `GET`
- **资源路径 (概念性)**: `/statistics/trends/{metric_name}` (例如 `/statistics/trends/new_users`)
- **请求参数 (Query Parameters):**

| 参数名          | 类型    | 是否必需 | 描述                                       | 示例值                       |
|-----------------|--------|----------|--------------------------------------------|------------------------------|
| `start_time`    | string | 是       | 统计开始时间 (ISO 8601 UTC格式)             | "2023-10-01T00:00:00Z"      |
| `end_time`      | string | 是       | 统计结束时间 (ISO 8601 UTC格式)             | "2023-10-31T23:59:59Z"      |
| `time_unit`     | string | 是       | 时间聚合单位 (`DAY`, `WEEK`, `MONTH`)        | "DAY"                        |
| `dimensions`    | string | 否       | (可选) 按指定维度拆分, 逗号分隔 (e.g., "channel,user_segment") | "channel"                    |
| `filters`       | string | 否       | (可选) 过滤条件 (e.g., "channel=organic&country=US") | "source=utm_campaign_A"      |

- **响应数据示例 (JSON):**

```json
{
  "query_parameters": {
    "metric_name": "new_users",
    "start_time": "2023-10-01T00:00:00Z",
    "end_time": "2023-10-31T23:59:59Z",
    "time_unit": "DAY",
    "dimensions": ["channel"]
  },
  "data": [
    {
      "date": "2023-10-26",
      "channel": "Direct",
      "value": 150
    },
    {
      "date": "2023-10-26",
      "channel": "Organic Search",
      "value": 220
    },
    {
      "date": "2023-10-27",
      "channel": "Direct",
      "value": 130
    }
    // ... 更多按时间单位和维度聚合的数据点
  ]
}
```

### 3.4 示例：获取分布或排行统计数据 (例如：产品销售排行)

- **功能描述**: 查询某一度量（如销售额、销量）在特定维度（如产品、渠道）上的排行或分布。
- **HTTP方法**: `GET`
- **资源路径 (概念性)**: `/statistics/rankings/{metric_name}/by/{dimension_name}` (e.g. `/statistics/rankings/sales_amount/by/product`)
- **请求参数 (Query Parameters):**

| 参数名          | 类型    | 是否必需 | 描述                                       | 示例值                       |
|-----------------|--------|----------|--------------------------------------------|------------------------------|
| `start_time`    | string | 否       | 统计开始时间                                 | "2023-10-01T00:00:00Z"      |
| `end_time`      | string | 否       | 统计结束时间                                 | "2023-10-31T23:59:59Z"      |
| `sort_by`       | string | 否       | 排序依据的度量 (默认是查询的`metric_name`)    | "sales_volume"               |
| `sort_order`    | string | 否       | 排序方向 (`ASC`, `DESC`)                     | "DESC"                       |
| `limit`         | integer| 否       | 返回 Top N 结果                             | 10                           |
| `filters`       | string | 否       | (可选) 过滤条件                             | "category_id=5"              |

- **响应数据示例 (JSON):**

```json
{
  "query_parameters": {
    "metric_name": "sales_amount",
    "dimension_name": "product",
    "sort_order": "DESC",
    "limit": 10
  },
  "data": [
    {
      "product_id": "P101",
      "product_name": "畅销商品A",
      "sales_amount": 24000.00,
      "sales_volume": 150
    },
    {
      "product_id": "P205",
      "product_name": "热门商品B",
      "sales_amount": 18500.00,
      "sales_volume": 90
    }
    // ... 更多排行数据
  ]
}
```

## 四、数据架构与模型设计

数据统计与分析模块的核心在于如何有效地组织和存储数据，以便进行高效的查询和分析。通常不直接在原始业务数据库 (OLTP系统) 上进行复杂统计，以避免影响核心业务性能。而是构建一个独立的数据分析环境 (OLAP系统)。

### 4.1 数据分层理念
典型的分析数据架构会采用分层设计，例如：

-   **ODS (Operational Data Store - 操作数据层)**: 存储从各个业务系统实时或准实时同步过来的原始数据副本，或经过轻微清洗的数据。主要用于数据集成和为后续处理提供数据源。
-   **DWD (Data Warehouse Detail - 数据仓库明细层)**: 对ODS层数据进行清洗、转换、规范化处理，形成一致性的、主题域化的明细数据。此层数据是后续聚合的基础。
-   **DWS (Data Warehouse Summary - 数据仓库汇总层) / ADS (Application Data Service - 应用数据服务层) 或数据集市 (Data Mart)**: 
    *   **DWS/汇总层**: 基于DWD层数据，按照不同的分析维度进行轻度或高度的聚合，生成宽表或预计算的汇总指标。例如，每日用户活跃汇总、每小时订单汇总等。
    *   **ADS/应用层/数据集市**: 面向具体的分析应用或报表需求，从DWS或DWD抽取数据，形成更 spécifiques 的数据集。例如，营销活动效果分析数据集市、用户画像标签库等。

### 4.2 核心建模概念
在DWD和DWS/ADS层，常采用维度建模技术：

-   **事实表 (Fact Table)**: 存储业务过程产生的度量值（可累加的数值型数据，如销售额、订单数、点击次数）以及与维度表关联的外键。事实表通常是数据仓库中最大的表。
    *   *类型*: 事务事实表、周期快照事实表、累积快照事实表。
-   **维度表 (Dimension Table)**: 存储分析业务事实所围绕的环境或上下文信息（即"谁、什么、何时、何地、为何、如何"）。例如，时间维度、用户维度、产品维度、渠道维度、地理位置维度。
    *   维度通常包含描述性属性，用于查询时的筛选、分组和聚合。
    *   *缓慢变化维度 (SCD)*: 处理维度数据随时间变化的技术 (如类型1、类型2、类型3等)。
-   **星型模型 (Star Schema)**: 由一个中心事实表和一组直接连接到它的维度表组成，结构像星星。查询性能较好，易于理解。
-   **雪花模型 (Snowflake Schema)**: 星型模型的变体，其中某些维度表被进一步规范化（拆分）成更小的维度表，形成雪花状。可以减少数据冗余，但查询时可能需要更多连接。
-   **OLAP Cube (联机分析处理立方体)**: (概念上) 预先计算了多个维度和度量的聚合数据，支持快速的多维数据分析、切片、钻取、旋转等操作。物理上可以由关系型数据库（ROLAP）、多维数据库（MOLAP）或混合型（HOLAP）实现。

### 4.3 数据来源
统计分析的数据来源于系统内各个业务模块的原始数据，例如：
-   用户与账户模块: 用户基本信息、注册信息、账户状态等。
-   产品与目录模块: 产品信息、分类信息、价格信息等。
-   订单与交易模块: 订单详情、支付记录、退款记录等。
-   营销与活动模块: 活动参与记录、优惠券使用记录、推广渠道来源等。
-   客户关系管理 (CRM) 模块: 客户交互记录、标签信息、跟进记录等。
-   用户行为日志: 前后端应用产生的用户行为埋点日志（如页面浏览、点击、停留时长）、API调用日志等。
-   第三方平台数据: 外部广告平台数据、社交媒体数据等（如果需要整合）。

## 五、核心架构与处理流程

### 5.1 数据流与ETL/ELT
数据统计分析模块的典型数据流如下：

1.  **数据采集 (Data Ingestion/Collection)**:
    *   从各种数据源（业务数据库、日志文件、消息队列、第三方API）收集原始数据。
    *   采集方式：数据库CDC (Change Data Capture)、日志抓取 (如Flume, Logstash)、API轮询/Webhook、MQ消费等。
2.  **数据处理与转换 (ETL/ELT - Extract, Transform, Load / Extract, Load, Transform)**:
    *   **抽取 (Extract)**: 从源系统读取数据。
    *   **转换 (Transform)**: 这是核心步骤，包括：
        *   *数据清洗*: 处理缺失值、异常值、重复数据，统一数据格式。
        *   *数据集成*: 合并来自不同源的数据。
        *   *数据规范化/标准化*: 统一编码、单位、命名等。
        *   *数据计算与派生*: 生成新的指标或维度属性（如计算用户年龄段、转换时间戳格式、标记会话）。
        *   *数据聚合*: 按需进行预聚合，生成汇总数据。
    *   **加载 (Load)**: 将处理后的数据加载到目标数据存储中（如数据仓库、数据集市、OLAP Cube）。
    *   *ETL vs ELT*: ETL在加载到数据仓库前完成大部分转换；ELT先将原始或轻度处理的数据加载到数据湖或数据仓库的暂存区，再利用数据仓库的计算能力进行转换。
3.  **数据存储 (Data Storage)**:
    *   选择合适的存储技术，如关系型数据库 (PostgreSQL, MySQL with optimizations for analytics)、列式数据库 (ClickHouse, Apache Doris, StarRocks)、数据湖 (HDFS, S3 + Presto/Spark SQL)、NoSQL数据库 (Elasticsearch for log analytics) 等。
4.  **数据服务与查询 (Data Serving & Querying)**:
    *   通过API接口向上层应用提供聚合统计数据。
    *   支持BI工具（如Tableau, Power BI, Superset, Metabase）通过SQL、MDX等方式连接数据源进行自助式分析和报表制作。
    *   提供用户自定义报表和仪表盘功能。

### 5.2 技术选型考量
-   **批处理 vs. 流处理**:
    *   *批处理*: 定时（如每小时、每日）对一段时间内积累的数据进行批量处理。适用于对实时性要求不高的场景。常用技术：Spark Batch, Flink Batch, MapReduce, Hive, Presto, Airflow/DolphinScheduler等调度工具。
    *   *流处理*: 对实时产生的数据流进行即时处理和分析。适用于实时监控、实时推荐、实时风控等场景。常用技术：Flink Streaming, Spark Streaming, Kafka Streams, Storm.
    *   *Lambda/Kappa架构*: 结合批处理和流处理的混合架构。
-   **数据湖 vs. 数据仓库 vs. 数据集市**:
    *   *数据湖 (Data Lake)*: 存储各种类型（结构化、半结构化、非结构化）的原始数据，灵活但需要较强的数据治理能力。
    *   *数据仓库 (Data Warehouse)*: 存储经过清洗、转换和集成的结构化数据，面向主题，支持企业级分析和报告。
    *   *数据集市 (Data Mart)*: 数据仓库的子集，面向特定部门或业务线的分析需求。
-   **计算引擎**: Spark, Flink, Presto, ClickHouse, Doris, StarRocks等，根据数据量、查询复杂度、实时性要求选择。
-   **调度与工作流管理**: Apache Airflow, Apache DolphinScheduler, Azkaban等，用于编排和调度ETL/ELT作业。

## 六、关键统计指标与分析维度 (示例)

定义清晰的KPIs和分析维度是数据统计模块的基础。

### 6.1 常见核心指标 (KPIs)
-   **用户相关**: 新增用户数 (Daily/Weekly/Monthly New Users - DNU/WNU/MNU), 活跃用户数 (DAU/WAU/MAU), 用户留存率 (次日、7日、30日), 用户流失率, 平均用户生命周期价值 (LTV), 用户会话时长, 访问频率。
-   **客户/销售相关**: 新增客户数, 客户转化率 (从线索到客户), 订单量, 销售额 (GMV/Revenue), 客单价 (AOV - Average Order Value), 付费用户数 (DPU/MPU - Daily/Monthly Paying Users), 复购率。
-   **产品/内容相关**: 产品/内容浏览量, 产品/内容使用率/完成率, 畅销/热门排行, 产品/内容转化率。
-   **流量/渠道相关**: 渠道来源用户数, 渠道转化率, 各渠道ROI, 页面浏览量 (PV), 独立访客数 (UV), 跳出率。
-   **营销活动相关**: 活动参与人数, 活动转化率, 活动ROI。

### 6.2 常见分析维度
-   **时间维度**: 年、季度、月、周、日、小时。
-   **用户维度**: 用户ID, 用户注册时间, 用户分群/标签 (如新老用户、高价值用户), 用户画像属性 (年龄、性别、地区等)。
-   **地理维度**: 国家、省份/州、城市。
-   **渠道维度**: 广告渠道、推广来源、搜索引擎、社交媒体、合作伙伴等。
-   **产品维度**: 产品ID, 产品名称, 产品分类, 品牌。
-   **设备维度**: PC, Mobile (iOS, Android), App版本, 浏览器类型。

## 七、功能模块划分 (概念性)

1.  **数据采集层**: 负责从各业务系统和服务中收集原始数据。
2.  **数据处理/ETL层**: 执行数据的清洗、转换、聚合等操作。
3.  **数据存储/仓库层**: 存储处理后的明细数据、汇总数据、维度数据和事实表。
4.  **数据服务/API层**: 向前端应用、BI工具或第三方系统提供标准化的数据查询接口。
5.  **分析与可视化接口层**: (可选) 支持与BI工具集成，或提供内建的报表和仪表盘配置功能。
6.  **元数据管理模块**: 管理指标定义、数据字典、数据血缘、ETL作业信息等。
7.  **任务调度与监控模块**: 调度ETL作业，监控作业执行状态和数据质量。

## 八、主要业务流程示例：计算并展示"日活跃用户数 (DAU)"

1.  **数据采集**: 用户行为日志（包含用户ID、访问时间、事件类型等）被实时收集到消息队列 (如Kafka) 或定期批量导入ODS层。
2.  **ETL处理 (批处理，每日执行)**:
    a.  **抽取**: 从ODS层或日志存储中抽取过去一日的用户行为日志。
    b.  **转换**: 
        i.  清洗日志：去除无效记录、机器人流量等。
        ii. 识别独立用户：对用户ID进行去重。
        iii.关联维度：(可选) 关联用户维度表获取用户属性。
    c.  **加载**: 将当日活跃的用户ID列表或聚合后的DAU总数加载到DWS层的"每日用户活跃汇总表"中，记录统计日期和DAU值。
3.  **API服务**: 
    a.  前端或BI工具请求DAU趋势数据，调用 `/statistics/trends/daily_active_users` API，指定时间范围和时间粒度（DAY）。
    b.  API服务层查询"每日用户活跃汇总表"，按日期聚合DAU值。
    c.  返回时间序列数据给调用方进行展示。

## 九、数据质量、校验与错误处理

1.  **数据源校验**: 监控数据源的可用性和数据延迟。
2.  **ETL过程监控**: 监控ETL作业的执行状态（成功、失败、运行时长），对失败作业进行告警和重试。
3.  **数据准确性校验**: 
    *   设置数据质量规则（如某指标值不应为负、总和应等于各部分之和）。
    *   与业务系统关键指标进行定期核对（如统计订单总额与财务系统核对）。
    *   监控数据漂移或异常波动。
4.  **空值与异常值处理**: 定义处理策略（如填充默认值、中位数/平均数替换、标记为异常等）。
5.  **日志与审计**: 详细记录ETL各步骤的日志，便于问题排查。审计数据变更历史。

## 十、安全性与合规性考量

1.  **数据访问控制**: 对统计数据和API接口进行严格的权限控制，确保只有授权用户可以访问相应数据。
2.  **数据隐私保护**: 
    *   对包含个人身份信息 (PII) 的数据，在ETL过程中或展示前进行脱敏处理（如匿名化、假名化、聚合到不可识别个体）。
    *   遵守相关数据保护法规 (如GDPR, CCPA, 《个人信息保护法》)。
    *   用户画像和行为分析应在合规前提下进行。
3.  **数据传输与存储安全**: 敏感数据在传输和存储时应加密。
4.  **审计日志**: 记录对统计系统本身配置的修改、重要ETL作业的执行情况以及敏感数据的访问记录。
5.  **防止数据泄露**: 确保数据导出和共享功能有严格的审批和监控机制。

## 十一、性能优化与扩展性

1.  **查询优化**: 
    *   合理设计数据模型（如星型/雪花模型、宽表）。
    *   为常用查询字段创建索引。
    *   使用分区表技术。
    *   SQL查询优化。
    *   利用物化视图或预聚合结果。
2.  **ETL性能**: 
    *   优化ETL脚本，减少不必要的数据扫描和计算。
    *   利用分布式计算框架 (Spark, Flink) 的并行处理能力。
    *   增量处理代替全量处理。
3.  **存储优化**: 选择合适的存储引擎和压缩算法。
4.  **缓存机制**: 对高频访问的统计结果或报表数据进行缓存。
5.  **水平扩展**: 设计可水平扩展的计算和存储架构，以应对数据量增长。

--- 

---

## 文件 31: 后端-通知管理-后端开发文档.md

*文件大小：12.32 KB*

---

# 通知管理模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
通知管理模块是系统中负责与用户及内部系统进行信息传递的关键组件。它统一管理和调度所有类型的出站消息，包括但不限于站内信、电子邮件、短信 (SMS)、App推送、以及可能的即时通讯消息 (如Webhook回调)。其目的是确保信息能够及时、准确、可靠地送达目标接收者。

### 1.2 设计目标
- **多渠道支持与统一管理**: 支持多种通知渠道，并提供统一的配置、发送和监控接口。
- **模板化与个性化**: 支持通知内容的模板化，允许使用变量进行个性化定制。
- **可靠发送**: 保证通知的高送达率，具备失败重试、状态跟踪和错误处理机制。
- **高效异步处理**: 通知发送不应阻塞核心业务流程，采用异步处理机制。
- **用户友好**: 用户可以管理自己的通知偏好设置，避免不必要的打扰。
- **可观测性**: 提供通知发送状态的监控、日志记录和统计分析。
- **可扩展性**: 易于集成新的通知渠道和第三方服务。
- **安全性**: 保护通知内容和用户数据的安全，防止信息泄露和滥用。

## 二、模块概述

本模块负责平台内所有类型通知消息的生命周期管理，包括模板创建与维护、通知任务的生成与调度、通过不同渠道（如站内信、短信、邮件、App推送等）的实际发送、发送状态的追踪记录以及相关的统计分析功能。

## 三、核心概念与架构组件

### 3.1 核心概念
- **通知模板 (Notification Template)**: 预定义的通知内容结构，包含固定文本和可替换的变量占位符。模板可以针对不同渠道和语言。
- **通知渠道 (Notification Channel)**: 发送通知的具体途径，如 Email, SMS, App Push, Web Push, 站内信 (In-App Message), Webhook等。
- **接收者 (Recipient)**: 通知的目标用户或系统。可以是单个用户ID、用户组、邮箱地址、手机号码、设备Token等。
- **通知消息/任务 (Notification Message/Task)**: 基于模板和具体数据生成的一条待发送或已发送的通知实例。
- **发送策略 (Sending Strategy)**: 控制通知发送的规则，如优先级、发送时间窗口、频率限制、渠道选择逻辑等。
- **发送日志/回执 (Delivery Log/Receipt)**: 记录每条通知的发送尝试、最终状态（成功、失败、已读、已点击等）以及来自渠道服务商的回执信息。

### 3.2 关键架构组件考量
- **模板引擎**: 用于解析通知模板，并将变量替换为实际内容。
    - *选型考量*: 语法简洁性、功能丰富度（条件判断、循环等）、性能、安全性（防止模板注入）、多语言支持。常见的有Thymeleaf, Freemarker, Handlebars, Jinja2等。
- **消息队列 (MQ)**: 用于异步化通知发送任务，解耦业务逻辑与实际发送操作，提高系统吞吐量和可靠性。
    - *选型考量*: (同自动化任务模块中的MQ考量)
- **渠道适配器/网关 (Channel Adapter/Gateway)**: 封装与各种第三方通知服务（如邮件服务商SendGrid/Mailgun, 短信服务商Twilio/Vonage, 推送服务FCM/APNS）的集成逻辑。
    - 每个渠道适配器负责处理该渠道特有的API调用、认证、参数格式化、错误处理和回执解析。
- **持久化存储**: 存储通知模板、发送日志、用户通知偏好设置等。
- **用户偏好管理服务**: 允许用户配置接收哪些类型的通知以及通过哪些渠道接收。

## 四、核心数据实体/模型

1.  **通知模板 (NotificationTemplate)**
    *   `template_id` (主键): 模板唯一标识符。
    *   `name` (字符串, 必填): 模板名称/用途描述。
    *   `channel_type` (枚举, 必填): 适用的通知渠道 (e.g., EMAIL, SMS, IN_APP, PUSH)。
    *   `subject_template` (文本, 可选, 邮件类模板需要): 标题模板。
    *   `content_template` (文本, 必填): 内容模板 (支持变量占位符，如 `${user_name}`或 `{{order_id}}`)。
    *   `template_language` (字符串, 可选, 默认: en-US): 模板语言代码。
    *   `status` (枚举: active, inactive, draft): 模板状态。
    *   `version` (整数, 可选): 模板版本号。
    *   `created_at`, `updated_at` (时间戳)。

2.  **通知发送日志 (NotificationLog)**
    *   `log_id` (主键): 日志唯一标识符。
    *   `template_id` (外键, 可选): 使用的通知模板ID。
    *   `recipient_identifier` (字符串, 必填): 接收者标识 (如用户ID, 邮箱, 手机号)。
    *   `channel_type` (枚举, 必填): 实际发送渠道。
    *   `subject` (文本, 可选): 实际发送的标题。
    *   `content` (文本, 必填): 实际发送的内容。
    *   `status` (枚举: pending, sent, delivered, failed, read, clicked): 发送状态。
    *   `scheduled_send_time` (时间戳, 可选): 计划发送时间。
    *   `actual_send_time` (时间戳, 可选): 实际发送时间。
    *   `provider_message_id` (字符串, 可选): 第三方服务商返回的消息ID。
    *   `error_message` (文本, 可选): 发送失败时的错误信息。
    *   `retry_count` (整数): 已重试次数。

3.  **站内信 (InboxMessage)** (如果支持站内信渠道)
    *   `message_id` (主键): 站内信唯一标识符。
    *   `user_id` (外键, 必填): 接收用户ID。
    *   `sender_info` (字符串/JSON, 可选): 发送者信息 (如系统、其他用户)。
    *   `title` (字符串, 必填): 站内信标题。
    *   `body` (文本, 必填): 站内信内容 (可支持HTML或Markdown)。
    *   `is_read` (布尔, 默认: false): 是否已读。
    *   `read_at` (时间戳, 可选): 阅读时间。
    *   `created_at` (时间戳): 创建时间。
    *   `metadata` (JSON, 可选): 附加信息，如关联的业务对象ID。

4.  **用户通知偏好 (UserNotificationPreference)** (可选)
    *   `user_id` (主键/外键)。
    *   `notification_type` (字符串, 例如: "order_update", "marketing_promo", "system_alert")。
    *   `channel_type` (枚举)。
    *   `is_enabled` (布尔, 默认: true)。

## 五、功能模块划分

1.  **模板管理模块**
    *   通知模板的CRUD操作。
    *   模板版本控制和审批流程 (可选)。
    *   模板变量的定义与预览功能。
    *   多语言模板支持。
2.  **渠道管理模块**
    *   配置和管理不同的通知渠道及其参数（如API密钥、发件人地址等）。
    *   渠道健康状态检查。
3.  **通知发送服务**
    *   接收发送请求（可包含接收者、模板ID、变量数据等）。
    *   根据模板和变量生成最终通知内容。
    *   根据用户偏好和发送策略选择合适的渠道。
    *   将发送任务推送到消息队列进行异步处理。
    *   与各渠道适配器交互，执行实际发送。
4.  **状态跟踪与回执处理模块**
    *   更新发送日志中的状态 (pending -> sent -> delivered/failed)。
    *   处理来自第三方服务商的异步回执 (DLR - Delivery Receipts)。
    *   失败重试逻辑。
5.  **用户接收管理模块 (如站内信)**
    *   用户站内信列表查询、标记已读/未读、删除等。
    *   未读消息计数。
6.  **用户通知偏好设置模块**
    *   允许用户配置接收哪些类型的通知以及通过哪些渠道。
7.  **监控与统计模块**
    *   统计各渠道发送量、成功率、失败率、打开率、点击率等。
    *   提供仪表盘展示关键指标。
    *   发送异常告警。

## 六、API接口设计指导原则

- **资源**: `templates` (通知模板), `notifications` (通知发送任务/日志), `inbox/messages` (用户站内信), `preferences` (用户通知偏好)。
- **模板管理API**: (示例)
    - `POST /templates`: 创建新模板。
    - `GET /templates`: 获取模板列表 (支持按渠道、状态筛选)。
    - `GET /templates/{template_id}`: 获取模板详情。
    - `PUT /templates/{template_id}`: 更新模板。
- **通知发送API**: (示例)
    - `POST /notifications/send`: 触发发送通知（异步）。请求体可包含 `recipient_ids`, `template_id`, `variables`, `channel_preferences` 等。
    - `GET /notifications/logs`: 查询发送日志 (支持按接收者、状态、时间范围等筛选)。
- **站内信API**: (示例, 若支持)
    - `GET /users/{user_id}/inbox/messages`: 获取用户的站内信列表。
    - `PUT /inbox/messages/{message_id}/read`: 标记站内信为已读。
- **通用原则**: 同其他模块API设计原则 (RESTful, JSON, 标准状态码, 错误处理, 认证授权等)。

## 七、主要业务流程示例

### 1. 管理员创建并启用一个邮件通知模板
    1.  管理员通过UI或API提交创建模板请求，包含名称、渠道类型（EMAIL）、主题模板、内容模板等。
    2.  API校验通过后，将模板数据存入数据库，状态为"草稿"或"激活"。

### 2. 系统触发发送"订单已发货"通知
    1.  订单模块在订单状态变更为"已发货"后，调用通知发送服务的API接口。
    2.  请求参数包含：`template_name` (或 `template_id`) = "order_shipped", `recipient_id` = 用户ID, `variables` = { `order_number`: "12345", `tracking_url`: "..." }。
    3.  通知发送服务：
        a.  查找有效的"order_shipped"模板。
        b.  (可选) 查询用户通知偏好，确定是否允许发送此类通知以及首选渠道。
        c.  使用变量渲染模板，生成最终的邮件主题和内容。
        d.  创建一条通知发送日志记录，初始状态为"待处理"。
        e.  将此发送任务（包含接收者邮箱、主题、内容等）推送到邮件发送消息队列。
    4.  邮件发送Worker从队列中消费任务：
        a.  通过邮件渠道适配器调用第三方邮件服务商API发送邮件。
        b.  更新发送日志状态为"已发送"或"失败"（及原因）。
    5.  (异步) 若邮件服务商提供回执，回执处理服务更新发送日志状态为"已送达"或"投递失败"。

## 八、技术考量与开发注意事项

1.  **模板引擎选择与安全**: 确保模板引擎安全，防止注入。支持丰富的模板功能。
2.  **异步处理与削峰填谷**: 必须异步发送，使用消息队列应对突发大量通知请求。
3.  **失败重试与幂等性**: 对可恢复的发送失败（如网络抖动、服务商临时不可用）进行重试。确保重试不会导致重复发送（依赖第三方服务商的消息ID或自行生成幂等键）。
4.  **第三方服务集成与容错**: 封装与各服务商的API交互，处理认证、限流、错误码。考虑服务商故障时的降级或切换备用服务商策略。
5.  **成本控制**: 监控短信、付费邮件等渠道的发送量和费用。提供预警机制。
6.  **送达率优化**: 遵守服务商发送规范，管理发件人信誉，处理退订和无效地址，优化邮件内容避免进入垃圾箱。
7.  **用户体验**: 避免过度通知，尊重用户偏好。提供清晰的退订机制。
8.  **多语言和时区**: 如果目标用户遍布全球，模板和发送时间需考虑多语言和接收者时区。
9.  **内容合规性**: 确保通知内容符合法律法规和平台政策，特别是营销类通知。
10. **可测试性**: 方便测试模板渲染、各渠道发送逻辑。提供沙箱模式或mock服务商接口。

## 九、数据校验与错误处理

1.  **模板校验**: 校验模板语法、变量占位符是否正确。
2.  **接收者校验**: 校验邮箱地址、手机号码格式是否合法。
3.  **参数校验**: 发送请求中的参数完整性和有效性。
4.  **错误分类与反馈**: 清晰区分配置错误、发送失败（可重试/不可重试）、服务商错误。向调用方或运营人员提供明确的错误信息。

## 十、安全性考量

1.  **凭证安全**: 安全存储和使用第三方服务商的API密钥、账户密码。
2.  **内容安全**: 防止通过通知内容（尤其是用户可自定义部分）发送恶意链接或脚本 (XSS)。
3.  **数据隐私**: 保护接收者个人信息（邮箱、手机号）。日志记录中对敏感信息脱敏。
4.  **防滥用**: 限制发送频率、单次发送数量，防止被用作垃圾信息发送工具。对高风险操作进行二次确认或验证码。
5.  **权限控制**: 严格控制模板管理、发送操作的权限。 

---

## 文件 32: 后端-微服务架构设计.md

*文件大小：17.75 KB*

---

# 微服务架构设计指南

## 一、引言

### 1.1 背景与目的
本文档旨在为构建可扩展、有弹性、易于维护的后端系统提供一套微服务架构设计的指导原则和最佳实践。随着业务的快速发展和系统复杂性的增加，微服务架构能够将大型单体应用拆分为一组小型、独立、松耦合的服务，从而提高开发敏捷性、部署灵活性和技术异构性。

### 1.2 适用范围
本指南适用于需要进行微服务改造的现有系统，或从头开始设计新的基于微服务的系统。具体的技术选型和实现细节可能因项目具体需求而异，但核心原则和设计考量具有普遍适用性。

### 1.3 核心目标
采用微服务架构旨在实现以下核心业务和技术目标：
- **敏捷性与快速迭代**: 允许小团队独立开发、测试、部署和扩展各自的服务。
- **技术多样性**: 允许不同服务根据其特定需求选择最合适的技术栈。
- **故障隔离**: 单个服务的故障不会导致整个系统瘫痪，提高系统整体韧性。
- **可扩展性**: 可以根据各个服务的具体负载独立进行扩展。
- **可维护性**: 代码库更小，逻辑更专注，易于理解和维护。
- **可部署性**: 服务可独立部署，简化CI/CD流程。

## 二、微服务架构核心原则

1.  **单一职责原则 (Single Responsibility Principle)**: 每个微服务应专注于一组内聚的业务功能，并将其做好。
2.  **面向服务设计 (Design for Services)**: 服务应通过明确定义的接口（API）暴露其功能，隐藏内部实现细节。
3.  **围绕业务能力构建 (Organized around Business Capabilities)**: 服务划分应反映业务领域，而非技术分层。
4.  **数据分离与自治 (Decentralized Data Management)**: 每个微服务应拥有其私有数据存储，避免服务间直接共享数据库。跨服务数据访问通过API进行。
5.  **去中心化治理 (Decentralized Governance)**: 团队在遵循统一架构原则的前提下，可以为自己的服务选择合适的技术和工具，但需有统一的服务治理框架。
6.  **为故障设计 (Design for Failure)**: 认识到服务可能且确实会失败，并在架构层面引入容错机制（如超时、重试、熔断、降级）。
7.  **基础设施自动化 (Infrastructure Automation)**: 采用自动化工具进行构建、测试、部署、监控和运维，以支持快速迭代和大规模部署。
8.  **演进式设计 (Evolutionary Design)**: 微服务架构不是一成不变的，应支持服务的持续演进和重构。

## 三、服务划分策略

### 3.1 划分原则
- **基于领域驱动设计 (DDD)**: 识别核心域、支撑域和通用域，根据限界上下文 (Bounded Context) 划分服务。
- **业务功能内聚性**: 将高度相关的业务功能组织在同一个服务中。
- **服务间低耦合**: 最小化服务之间的依赖关系。
- **数据独立性**: 服务应能独立管理其核心数据。
- **团队结构考量 (康威定律)**: 服务边界可以参考团队的组织结构。
- **服务粒度适中**: 避免过细导致服务数量过多、调用链过长；避免过粗导致服务内部复杂性过高、失去微服务的优势。
- **可独立部署和扩展**: 每个服务都应能够独立部署和按需扩展。

### 3.2 服务分类示例 (概念性)
根据业务特性，服务通常可以分为以下几类：

- **核心业务服务**: 直接实现核心业务逻辑的服务。例如：订单服务、用户账户服务、产品服务。
- **支撑业务服务**: 为核心业务提供支撑功能的服务。例如：支付集成服务、通知服务、库存管理服务。
- **聚合服务/编排服务**: 组合多个下游服务的功能，为特定用例或前端提供统一API的服务。
- **基础设施/通用服务**: 提供通用技术能力的服务。例如：认证授权服务、配置管理服务、文件存储服务、日志服务。
- **API网关服务**: 作为所有外部请求的统一入口，处理路由、安全、监控等横切关注点。

*(原文档中具体的服务列表如 `kr-user`, `kr-customer` 等，可以作为此处的具体实例化示例，但应强调其业务职责)*

## 四、架构视图

### 4.1 逻辑架构视图
描述系统的主要功能模块、组件及其相互关系，不涉及具体技术实现。通常包括用户界面层、应用层（API网关、业务服务）、数据持久层等。

*(此处可放置一个高层次的、技术无关的逻辑组件图，替代原文档中特定技术的架构图)*

### 4.2 物理部署视图 (概念性)
描述服务如何部署到物理或虚拟化基础设施上。涉及服务器、容器、网络配置、负载均衡器等。
- **容器化**: 讨论使用Docker等容器技术封装服务的好处。
- **编排**: 讨论使用Kubernetes、Nomad、Swarm或云厂商的容器服务（如ECS, EKS, GKE）进行服务部署、扩展和管理。
- **多区域/多可用区部署**: 讨论高可用性和灾备策略。

### 4.3 开发与技术栈视图 (通用讨论)
- **技术异构性**: 微服务允许不同服务采用最适合其需求的技术栈（语言、框架、数据库）。
- **标准化考量**: 尽管允许异构，但建议在某些方面进行标准化以降低复杂性，例如：
    - API接口规范 (如RESTful + OpenAPI, gRPC)。
    - 日志格式与追踪机制。
    - 基础镜像和安全基线。
    - CI/CD流程。
- **开发流程**: 讨论敏捷开发、DevOps文化在微服务环境下的实践。

## 五、跨服务通信机制

### 5.1 同步通信
- **场景**: 需要即时响应的请求-响应模式。
- **协议**: 
    - HTTP/REST: 广泛使用，易于理解和实现，配合JSON/XML。OpenAPI/Swagger可用于接口定义。
    - gRPC: 高性能，基于HTTP/2，使用Protocol Buffers进行接口定义和序列化，支持多种语言。
- **服务发现**: 客户端需要动态发现服务实例的网络位置。
- **负载均衡**: 客户端或API网关需要将请求分发到多个服务实例。
- **容错处理**: 实现超时、重试、熔断机制。
- **考量**: 紧耦合，调用方需等待响应，链式调用可能导致高延迟和级联故障。

### 5.2 异步通信
- **场景**: 无需即时响应，解耦服务，提高系统整体吞吐量和韧性，适用于事件驱动架构。
- **机制**: 通常通过消息中间件实现。
    - **消息队列 (Message Queue)**: 点对点通信，任务分发。如RabbitMQ, Kafka, ActiveMQ, SQS等。
    - **发布/订阅 (Publish/Subscribe)**: 一对多通信，事件通知。如Kafka, RabbitMQ (Topic/Fanout Exchange), Redis Pub/Sub, SNS等。
- **消息格式**: JSON, Avro, Protocol Buffers等。
- **消息可靠性**: 持久化、发送确认、消费确认、幂等性处理、死信队列。
- **考量**: 增加系统复杂性（消息中间件的运维），数据最终一致性，消息顺序保证（部分中间件支持）。

### 5.3 API网关 (API Gateway)
- **角色**: 作为所有外部客户端请求的统一入口点。
- **核心功能**:
    - **请求路由**: 将外部请求转发到内部相应的微服务。
    - **API组合/编排**: (可选)聚合多个微服务的调用结果返回给客户端。
    - **协议转换**: (可选) 如对外暴露REST，对内使用gRPC。
    - **认证与授权**: 统一处理安全策略。
    - **请求限流与配额**: 防止后端服务过载。
    - **熔断与降级**: 作为统一的熔断点。
    - **日志与监控**: 记录API调用日志，收集监控指标。
    - **负载均衡**: 对后端服务实例进行负载均衡。
    - **SSL/TLS终止**。
- **选型考量**: 性能、可扩展性、功能集、社区支持、云厂商提供或自建 (如Spring Cloud Gateway, Kong, Tyk, Apigee)。

## 六、数据管理策略

### 6.1 数据分离与所有权
- 每个微服务拥有其私有数据存储，负责其数据的完整性和一致性。
- 禁止其他服务直接访问本服务的数据存储；所有数据交互通过服务API进行。

### 6.2 数据库选型
- **按需选择 (Polyglot Persistence)**: 允许每个微服务根据其数据特性和需求选择最合适的数据库技术（如关系型SQL、NoSQL文档库、键值存储、图数据库、时序数据库）。
- **考量因素**: 数据模型、一致性要求 (CAP理论)、事务需求、读写负载、扩展性、运维成本。

### 6.3 分布式数据一致性
- **挑战**: 在多个独立服务间维护数据一致性。
- **最终一致性**: 是微服务架构中常见的选择。通过异步事件、补偿事务等机制，允许数据在短时间内不一致，但最终会达到一致状态。
- **策略**:
    - **Saga模式**: 将长事务拆分为一系列本地事务，每个本地事务完成后发布事件触发下一个本地事务。若某个步骤失败，则执行补偿操作回滚之前的步骤。
    - **两阶段提交 (2PC) / 三阶段提交 (3PC)**: 强一致性方案，但复杂性高，性能影响大，且协调者是单点瓶颈，在微服务中较少直接使用。
    - **事件溯源 (Event Sourcing)**: 将所有状态变更作为一系列事件持久化，当前状态通过重放事件计算得出。常与CQRS结合。
    - **CQRS (Command Query Responsibility Segregation)**: 将读操作和写操作分离，可以使用不同的数据模型和存储来优化各自的性能。
    - **消息队列保证最终一致性**: 通过可靠的消息传递确保状态变更最终被所有相关服务处理。
    - **定期对账/数据同步**: 作为补充手段，检测和修复不一致的数据。

### 6.4 分布式锁
- **场景**: 在分布式环境中控制对共享资源的并发访问，确保操作的原子性（如防止库存超卖）。
- **实现方式**: 基于Redis (如Redlock算法或SETNX命令)、ZooKeeper、数据库乐观锁/悲观锁等。
- **考量**: 死锁风险、锁的粒度、性能开销、可靠性。

## 七、服务治理

服务治理是确保微服务架构健康、稳定运行的关键机制集合。

### 7.1 服务注册与发现
- **目的**: 使得服务实例能够动态注册其网络位置，并被其他服务或API网关发现。
- **组件**: 服务注册中心 (Service Registry)，如Consul, Eureka, Zookeeper, Nacos, etcd，或云平台提供的服务发现机制。
- **流程**: 服务启动时向注册中心注册，并定期发送心跳。客户端查询注册中心获取服务实例列表。
- **健康检查**: 注册中心或客户端应能检测服务实例的健康状况，自动剔除不健康的实例。

### 7.2 配置管理
- **目的**: 集中管理和动态更新微服务的配置信息（如数据库连接、第三方服务凭证、功能开关、参数阈值等），避免硬编码和重启服务。
- **组件**: 配置中心 (Configuration Server)，如Spring Cloud Config, Consul KV, Nacos Config, Apollo，或使用环境变量、Kubernetes ConfigMaps/Secrets。
- **功能**: 配置版本控制、动态刷新、权限管理、多环境隔离。

### 7.3 弹性与容错 (Resilience)
- **超时控制 (Timeouts)**: 为所有网络调用设置合理的超时时间，防止长时间等待阻塞线程。
- **重试机制 (Retries)**: 对瞬时故障或可恢复错误自动进行重试。应配置重试次数、退避策略（如指数退避）。注意幂等性设计。
- **熔断器 (Circuit Breaker)**: 当某个服务的错误率或响应时间超过阈值时，暂时阻止对该服务的进一步调用，快速失败并返回错误或降级响应，防止级联故障。一段时间后尝试半开放状态，恢复正常调用。
- **舱壁隔离 (Bulkheads)**: 限制对某个服务或资源的并发调用数量，防止单个依赖的故障耗尽所有资源，影响其他服务。
- **限流 (Rate Limiting)**: 控制单位时间内允许的请求数量，保护服务不被突发流量冲垮。可在API网关或服务自身实现。
- **服务降级 (Fallback/Degradation)**: 当核心服务不可用或性能下降时，提供替代的、简化的功能或静态响应，保证核心业务流程的可用性。

### 7.4 监控与告警
- **目的**: 实时了解系统运行状态，快速发现和定位问题，评估系统健康度。
- **三驾马车 (Three Pillars of Observability)**:
    - **指标 (Metrics)**: 可聚合的数值型数据，反映系统某个方面随时间变化的度量（如请求速率、错误率、CPU使用率、队列长度）。使用Prometheus, InfluxDB, Graphite等收集，Grafana, Kibana等展示。
    - **日志 (Logging)**: 记录离散事件的文本信息，用于问题排查和审计。应采用结构化日志，并集中收集到如ELK Stack (Elasticsearch, Logstash, Kibana), Splunk, Loki等平台。
    - **追踪 (Tracing)**: 在分布式系统中，记录单个请求跨越多个服务的完整调用链路和耗时，用于分析性能瓶颈和理解服务交互。使用OpenTelemetry, Jaeger, Zipkin, SkyWalking等工具。
- **健康检查端点**: 每个服务应提供HTTP健康检查接口（如 `/health`），供监控系统和负载均衡器使用。
- **告警机制**: 基于关键指标和日志设定告警阈值，通过邮件、短信、IM等渠道及时通知相关人员。

## 八、多环境管理与部署

### 8.1 环境隔离策略
- **目标**: 确保开发、测试、预发布、生产等环境之间的独立性，防止交叉影响。
- **方法**:
    - **网络隔离**: 使用VPC、子网等进行网络隔离。
    - **资源隔离**: 为各环境分配独立的计算资源、存储、数据库实例、消息队列、缓存等。
    - **配置隔离**: 使用配置中心的不同命名空间/Profile，或不同的配置文件版本管理各环境的配置。
    - **凭证管理**: 各环境使用独立的API密钥、数据库密码等凭证。
    - **数据隔离**: 生产环境数据严格保护，非生产环境使用脱敏数据或测试数据。

### 8.2 容器化与编排
- **容器化 (Containerization)**: 使用Docker等技术将每个微服务及其依赖打包成独立的、可移植的容器镜像。
    - **优势**: 环境一致性、快速部署、资源隔离、易于扩展。
    - **Dockerfile**: 定义镜像构建过程。
- **容器编排 (Container Orchestration)**: 使用Kubernetes, Docker Swarm, Apache Mesos或云厂商的托管服务 (如AWS EKS/ECS, Azure AKS, Google GKE) 自动化部署、管理、扩展和联网容器化应用。
    - **核心功能**: 服务发现、负载均衡、自动扩缩容 (HPA)、滚动更新与回滚、自愈能力、配置和密钥管理 (ConfigMaps, Secrets)。

### 8.3 CI/CD (持续集成/持续交付/持续部署)
- **自动化流水线**: 建立从代码提交到构建、测试、打包、部署到各环境的自动化流程。
- **工具链**: Jenkins, GitLab CI/CD, GitHub Actions, ArgoCD等。
- **部署策略**: 
    - **蓝绿部署 (Blue/Green Deployment)**: 同时运行两个相同的生产环境（蓝和绿），流量在两者之间切换。
    - **金丝雀发布 (Canary Release)**: 将新版本逐步引入给一小部分用户，验证无误后再全量发布。
    - **滚动更新 (Rolling Update)**: 逐个替换旧版本的服务实例为新版本实例。

## 九、安全设计

### 9.1 认证与授权 (Authentication & Authorization)
- **统一身份认证**: 建立集中的身份认证服务（如基于OAuth 2.1 / OpenID Connect的认证服务器），负责用户身份验证和令牌颁发 (如JWT)。
- **API网关安全**: API网关作为安全策略的执行点，校验令牌、验证API Key，处理外部认证。
- **服务间认证**: 微服务之间调用也需要认证，确保请求来源可信。常用机制包括：
    - 双向TLS (mTLS)。
    - API Key/Secret。
    - 短期令牌 (如OAuth2客户端凭证模式获取的令牌)。
- **权限控制**: 基于角色的访问控制 (RBAC) 或更细粒度的策略（如ABAC），确保用户和服务只能访问其被授权的资源和操作。

### 9.2 数据安全
- **传输加密**: 所有外部通信和内部服务间通信均使用HTTPS/TLS。
- **静态数据加密**: 对敏感数据（如用户密码、支付信息、个人身份信息）在数据库或文件系统中进行加密存储。
- **敏感数据脱敏**: 在日志、监控、测试环境等非必要场景对敏感数据进行脱敏处理。
- **输入验证与输出编码**: 防止常见的Web攻击，如XSS、SQL注入。
- **密钥管理**: 使用专门的密钥管理服务 (KMS) 或硬件安全模块 (HSM) 安全地存储和管理加密密钥。

### 9.3 网络安全
- **网络分段**: 使用VPC、子网、安全组/防火墙规则限制服务间的网络访问，遵循最小权限原则。
- **API网关防护**: 在API网关层面部署Web应用防火墙 (WAF)，防御DDoS、SQL注入、XSS等常见攻击。
- **依赖安全**: 定期扫描和更新第三方库和基础镜像，修补已知漏洞。

### 9.4 安全审计与监控
- **审计日志**: 记录所有关键操作（如登录、权限变更、重要数据修改、安全配置更改）和安全事件。
- **安全信息和事件管理 (SIEM)**: 集中收集和分析安全日志和告警，进行威胁检测和应急响应。

## 十、演进与未来展望

- **持续优化服务边界**: 根据业务发展和团队变化，定期审视和调整服务边界。
- **引入新技术**: 关注云原生技术、Serverless、服务网格 (Service Mesh如Istio, Linkerd) 等新兴技术的发展，适时引入以提升效率和能力。
- **自动化水平提升**: 持续提升测试、部署、运维、监控等各环节的自动化水平。
- **韧性工程实践**: 引入混沌工程 (Chaos Engineering) 等实践，主动测试和提升系统的容错能力。
- **成本优化**: 关注云资源使用情况，进行成本分析和优化。

---
> 本文档提供了微服务架构设计的通用指导原则和核心考量，具体实践中需结合项目实际情况进行裁剪和调整。 

---

## 文件 33: 后端-我的-流量池功能开发文档.md

*文件大小：11.10 KB*

---

# 客户资源池管理模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块是应用的核心功能之一，负责管理和运营从各渠道获取的客户资源。客户资源池作为企业重要的数据资产，支撑客户关系管理、精准营销和业务转化，对提升获客效率、客户留存率和复购率具有关键作用。

### 1.2. 设计目标
- **集中管理**: 统一存储和管理来自多渠道的客户资源，避免数据孤岛
- **分层分类**: 支持灵活的客户分组、标签和状态管理，便于精细化运营
- **全景视图**: 提供客户全方位信息视图，包括基本属性、行为轨迹、互动记录等
- **批量操作**: 支持高效的批量客户管理和运营操作
- **数据分析**: 提供丰富的统计分析功能，支持数据驱动决策
- **安全合规**: 严格的数据访问控制和隐私保护机制

## 2. 核心概念

- **客户资源 (Customer Resource)**: 系统中的客户基本单元，包含客户的基本信息、属性和状态
- **获客渠道 (Acquisition Channel)**: 客户来源的渠道，如社交媒体、线下活动、网站表单等
- **获客场景 (Acquisition Scene)**: 具体的获客情境，如特定活动、特定广告投放等
- **客户标签 (Customer Tag)**: 用于多维度标记客户特征的标签体系
- **客户分组 (Customer Group)**: 用于组织和管理客户的分类体系，支持树形结构
- **客户状态 (Customer Status)**: 客户在业务流程中的状态，如潜在客户、意向客户、已成交等
- **行为轨迹 (Behavior Trail)**: 客户在系统中或与企业互动的行为记录
- **互动记录 (Interaction Record)**: 企业与客户的沟通互动记录
- **批量任务 (Batch Task)**: 针对多个客户执行的批量操作任务

## 3. 核心数据实体/模型 (Conceptual)

- **`Customer` (客户资源)**
    - `customerId` (客户唯一标识)
    - `name` (姓名)
    - `contactInfo` (联系信息，如电话、邮箱、社交账号等)
    - `source` (获客渠道)
    - `scene` (获客场景)
    - `status` (客户状态)
    - `acquisitionTime` (获客时间)
    - `lastActiveTime` (最近活跃时间)
    - `notes` (备注)
    - `createdBy` (创建者)
    - `createdAt` (创建时间)
    - `updatedAt` (更新时间)

- **`CustomerTag` (客户标签)**
    - `tagId` (标签唯一标识)
    - `name` (标签名称)
    - `createdBy` (创建者)
    - `createdAt` (创建时间)

- **`CustomerTagRelation` (客户-标签关联)**
    - `relationId` (关联唯一标识)
    - `customerId` (客户ID)
    - `tagId` (标签ID)
    - `createdAt` (创建时间)

- **`CustomerGroup` (客户分组)**
    - `groupId` (分组唯一标识)
    - `name` (分组名称)
    - `parentId` (父分组ID，支持层级结构)
    - `createdBy` (创建者)
    - `createdAt` (创建时间)
    - `updatedAt` (更新时间)

- **`CustomerGroupRelation` (客户-分组关联)**
    - `relationId` (关联唯一标识)
    - `customerId` (客户ID)
    - `groupId` (分组ID)
    - `createdAt` (创建时间)

- **`CustomerBehavior` (客户行为)**
    - `behaviorId` (行为唯一标识)
    - `customerId` (客户ID)
    - `type` (行为类型)
    - `description` (行为描述)
    - `data` (行为相关数据)
    - `occurredAt` (发生时间)

- **`CustomerInteraction` (客户互动)**
    - `interactionId` (互动唯一标识)
    - `customerId` (客户ID)
    - `type` (互动类型)
    - `content` (互动内容)
    - `channel` (互动渠道)
    - `initiatedBy` (发起方)
    - `occurredAt` (发生时间)

- **`BatchTask` (批量任务)**
    - `taskId` (任务唯一标识)
    - `type` (任务类型)
    - `status` (任务状态)
    - `parameters` (任务参数)
    - `progress` (执行进度)
    - `result` (执行结果)
    - `createdBy` (创建者)
    - `createdAt` (创建时间)
    - `completedAt` (完成时间)

## 4. 功能模块划分

### 4.1. 客户管理核心模块
- **功能**:
    - 客户的创建、查询、更新操作
    - 客户状态管理
    - 客户基本信息维护
    - 客户详情查看
- **主要接口 (Conceptual)**:
    - 客户列表查询：支持分页、搜索、筛选、排序
    - 客户详情查询
    - 客户信息更新

### 4.2. 分组与标签管理模块
- **功能**:
    - 分组的创建、查询、更新、删除操作
    - 标签的创建、查询、更新、删除操作
    - 客户与分组/标签的关联管理
- **主要接口 (Conceptual)**:
    - 分组列表查询
    - 分组创建/更新/删除
    - 标签列表查询
    - 标签创建/更新/删除
    - 客户分组/标签关联管理

### 4.3. 客户行为与互动记录模块
- **功能**:
    - 记录客户行为轨迹
    - 记录客户互动历史
    - 查询客户行为和互动记录
- **主要接口 (Conceptual)**:
    - 客户行为记录创建
    - 客户行为轨迹查询
    - 客户互动记录创建
    - 客户互动历史查询

### 4.4. 批量操作模块
- **功能**:
    - 批量客户标签管理
    - 批量客户分组调整
    - 批量客户状态变更
    - 批量营销操作（如群发消息、添加社交账号等）
    - 批量任务管理与进度追踪
- **主要接口 (Conceptual)**:
    - 批量更新操作
    - 批量营销操作
    - 批量任务进度查询

### 4.5. 统计分析模块
- **功能**:
    - 客户分布统计（按渠道、状态、标签、分组等）
    - 客户活跃度分析
    - 营销效果分析
    - 趋势分析
- **主要接口 (Conceptual)**:
    - 客户统计数据查询
    - 客户分布统计查询
    - 客户活跃度统计查询

## 5. 主要业务流程示例

### 5.1. 客户资源管理流程
1. 系统从各渠道接收客户资源数据。
2. 系统对新客户数据进行验证、去重和初步分类。
3. 客户数据进入资源池，按照预设规则分配标签和分组。
4. 用户可查看客户资源列表，并对客户进行进一步的标记、分组或状态调整。
5. 系统记录客户信息变更历史，便于追踪管理过程。

### 5.2. 客户查询与分析流程
1. 用户通过搜索、筛选条件查询客户列表。
2. 系统根据条件返回匹配的客户列表（支持分页）。
3. 用户可查看客户详情，包括基本信息、标签、分组、行为轨迹、互动记录等。
4. 用户可查看客户统计分析数据，了解客户分布、活跃度等情况。
5. 基于分析结果，用户可能调整客户分组、标签或执行批量操作。

### 5.3. 批量客户运营流程
1. 用户选择多个客户，发起批量操作请求（如批量添加标签、批量调整分组、批量发送消息）。
2. 系统验证请求参数和操作权限，创建批量操作任务。
3. 系统异步处理批量操作任务，更新操作进度。
4. 用户可查询批量操作任务进度。
5. 批量操作完成后，系统更新相关客户数据和统计信息。
6. 系统记录批量操作结果，包括成功数量、失败记录及原因等。

## 6. 技术考量与开发注意事项

### 6.1. 数据存储与访问
- **存储策略**: 
  - 核心客户数据存储在关系型数据库中，确保数据一致性和完整性
  - 客户行为、互动记录等高频写入、低频查询的数据可考虑采用时序数据库或文档数据库
  - 客户统计分析等数据可存入数据仓库，支持多维度分析
- **缓存策略**: 
  - 热点客户数据、分组列表、标签列表等可以考虑缓存，提升访问性能
  - 批量查询结果缓存，减轻数据库负担
- **查询优化**: 针对客户列表的复杂查询，需优化数据库设计和查询性能

### 6.2. 数据隐私与安全
- **数据脱敏**: 敏感字段（如电话、邮箱、社交账号）在非必要场景进行脱敏处理
- **访问控制**: 实施基于角色和权限的严格访问控制
- **操作审计**: 记录关键操作日志，确保可追溯性
- **合规性**: 符合数据保护法规要求，如必要的用户授权、数据保留期限等

### 6.3. 并发与性能
- **批量操作**: 大量客户的批量操作应采用异步处理机制，避免长时间阻塞
- **读写分离**: 考虑客户查询和客户更新的读写分离，优化性能
- **分库分表**: 对于超大规模客户数据，考虑合理的分库分表策略
- **索引优化**: 针对常用查询条件建立适当的索引

### 6.4. 集成与扩展
- **事件驱动**: 采用事件驱动架构，客户关键状态变更触发事件通知，便于其他模块响应
- **模块间集成**: 与营销自动化、客户服务等模块集成，实现业务闭环
- **API扩展性**: 设计灵活的API，支持未来功能扩展和新的客户属性/行为追踪

## 7. 接口设计指导原则 (Conceptual)

### 7.1. 客户列表查询接口
- **支持多条件查询**: 姓名/联系方式关键词、获客渠道、客户状态、标签、分组等
- **支持灵活排序**: 获客时间、最近活跃时间、状态变更时间等
- **支持分页**: 页码、每页数量
- **返回数据**: 分页客户列表、总数、当前页信息，客户基本信息包含关键字段

### 7.2. 客户详情查询接口
- **支持按ID查询**: 根据客户ID获取详细信息
- **返回数据**: 客户基本信息、标签、分组、行为轨迹、互动记录等完整信息

### 7.3. 客户更新接口
- **基础字段更新**: 支持客户基本信息、状态、备注等更新
- **关联关系更新**: 支持客户标签、分组等关联关系更新
- **返回数据**: 更新成功状态和更新后的关键信息

### 7.4. 批量操作接口
- **批量更新**: 支持一次更新多个客户的共同属性（如标签、分组、状态）
- **批量营销**: 支持针对多个客户执行相同的营销操作
- **异步处理**: 大规模客户操作返回任务ID，支持后续查询进度
- **返回数据**: 任务ID、任务初始状态

## 8. 数据校验与错误处理

### 8.1. 常见数据校验规则
- **联系信息**: 电话、邮箱、社交账号等格式验证
- **客户状态**: 枚举值验证
- **标签/分组**: 存在性验证、数量限制
- **批量操作**: 客户数量限制、操作类型验证

### 8.2. 错误处理策略
- **参数错误**: 返回具体错误字段和原因
- **权限错误**: 明确指出权限不足的具体原因
- **资源不存在**: 明确指出请求的资源未找到
- **业务规则冲突**: 说明业务规则限制和解决方案
- **系统错误**: 记录详细错误日志，返回友好错误信息

## 9. 安全性考量

- **数据访问控制**: 实施基于角色的访问控制(RBAC)，确保用户只能访问授权的客户数据
- **敏感数据保护**: 对敏感客户信息（如联系方式）进行加密存储和传输
- **操作审计**: 记录所有关键操作，支持安全审计
- **防滥用机制**: 限制批量操作频率和范围，防止误操作和恶意使用

## 10. 可扩展性设计

- **客户属性扩展**: 支持自定义客户属性字段，满足不同业务场景需求
- **行为类型扩展**: 支持新增客户行为类型和互动类型的定义
- **批量操作扩展**: 提供批量操作框架，支持新增批量操作类型
- **集成能力**: 提供标准化事件和API，便于与其他业务系统集成

--- 

---

## 文件 34: 后端-我的-内容库功能开发文档.md

*文件大小：10.22 KB*

---

# 内容库管理模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块为应用中的核心功能之一，负责管理用户创建和收集的营销内容资源，是内容营销策略的数据基础。内容库作为知识资产的集中管理中心，支持内容的创建、分类、标签化、检索和重用，提高营销内容的管理效率和使用价值。

### 1.2. 设计目标
- **集中管理**: 提供统一的内容资源库，便于内容的存储、访问和重用。
- **分类组织**: 支持通过分类、标签等多维度组织和查找内容。
- **灵活存取**: 支持多种类型内容（文章、图片、视频、链接等）的存储和管理。
- **高效检索**: 提供强大的搜索和过滤功能，快速定位所需内容。
- **版本控制**: 支持内容的版本管理，追踪内容变更历史。
- **使用分析**: 记录和分析内容的使用情况，支持数据驱动的内容策略优化。

## 2. 核心概念

- **内容资源 (Content Resource)**: 内容库中存储的基本单元，可以是文章、图片、视频、链接等多种类型。
- **内容分类 (Content Category)**: 用于组织内容的分类体系，支持树形层级结构。
- **内容标签 (Content Tag)**: 用于多维度标记内容特征的标签体系。
- **内容附件 (Content Attachment)**: 与内容关联的文件，如图片、文档、视频等。
- **内容版本 (Content Version)**: 内容的历史版本记录，支持版本对比和回滚。
- **使用统计 (Usage Statistics)**: 内容被使用（如被引用、推送、分享）的统计数据。
- **权限控制 (Access Control)**: 控制用户对内容的访问和操作权限。

## 3. 核心数据实体/模型 (Conceptual)

- **`Content` (内容资源)**
    - `contentId` (内容唯一标识)
    - `title` (标题)
    - `type` (类型：文章、图片、视频、链接等)
    - `body` (内容主体，根据类型不同存储形式可能不同)
    - `coverImageUrl` (封面图片URL，可选)
    - `status` (状态：草稿、已发布、已归档等)
    - `categoryId` (所属分类ID，可选)
    - `createdBy` (创建者ID)
    - `createdAt` (创建时间)
    - `updatedAt` (更新时间)
    - `notes` (备注，可选)

- **`ContentCategory` (内容分类)**
    - `categoryId` (分类唯一标识)
    - `name` (分类名称)
    - `createdBy` (创建者ID)
    - `createdAt` (创建时间)
    - `updatedAt` (更新时间)

- **`ContentTag` (内容标签)**
    - `tagId` (标签唯一标识)
    - `name` (标签名称)
    - `createdBy` (创建者ID)
    - `createdAt` (创建时间)

- **`ContentTagRelation` (内容-标签关联)**
    - `relationId` (关联唯一标识)
    - `contentId` (内容ID)
    - `tagId` (标签ID)

- **`ContentAttachment` (内容附件)**
    - `attachmentId` (附件唯一标识)
    - `contentId` (关联的内容ID)
    - `name` (附件名称)
    - `url` (附件URL)
    - `type` (附件类型：图片、文档、视频等)
    - `size` (附件大小，可选)
    - `uploadedAt` (上传时间)

- **`ContentVersion` (内容版本)**
    - `versionId` (版本唯一标识)
    - `contentId` (内容ID)
    - `versionData` (版本内容快照)
    - `createdBy` (创建者ID)
    - `createdAt` (创建时间)

- **`ContentUsage` (内容使用记录)**
    - `usageId` (使用记录唯一标识)
    - `contentId` (内容ID)
    - `usageType` (使用类型：推送、分配、引用等)
    - `usedBy` (使用者ID)
    - `usedAt` (使用时间)
    - `context` (使用上下文信息，可选)

## 4. 功能模块划分

### 4.1. 内容管理核心模块
- **功能**:
    - 内容的创建、查询、更新、删除操作
    - 内容状态管理（发布、归档、恢复等）
    - 内容版本管理（创建版本、版本回滚等）
- **主要接口 (Conceptual)**:
    - 内容列表查询：支持分页、搜索、筛选、排序
    - 内容详情查询
    - 内容创建/更新/删除
    - 内容状态变更
    - 内容版本管理

### 4.2. 分类与标签管理模块
- **功能**:
    - 分类的创建、查询、更新、删除操作
    - 标签的创建、查询、更新、删除操作
    - 内容与标签的关联管理
- **主要接口 (Conceptual)**:
    - 分类列表查询
    - 分类创建/更新/删除
    - 标签列表查询
    - 标签创建/更新/删除
    - 内容标签关联/解除

### 4.3. 附件管理模块
- **功能**:
    - 附件的上传、查询、删除操作
    - 附件与内容的关联管理
    - 附件存储与访问控制
- **主要接口 (Conceptual)**:
    - 附件上传
    - 附件列表查询
    - 附件删除
    - 附件与内容关联/解除

### 4.4. 批量操作模块
- **功能**:
    - 多内容批量标签管理
    - 多内容批量分类调整
    - 多内容批量状态变更
    - 批量操作任务管理与进度追踪
- **主要接口 (Conceptual)**:
    - 批量更新操作
    - 批量任务进度查询

### 4.5. 统计分析模块
- **功能**:
    - 内容使用情况统计与分析
    - 内容分布统计（按分类、标签、类型等）
    - 内容创建、使用趋势分析
- **主要接口 (Conceptual)**:
    - 内容使用统计查询
    - 内容分布统计查询
    - 内容趋势分析查询

## 5. 主要业务流程示例

### 5.1. 内容创建与管理流程
1. 用户发起内容创建请求，提供内容标题、类型、主体内容等信息。
2. 系统验证请求参数，创建内容记录。
3. 用户可选择上传附件，系统将附件与内容关联。
4. 用户可选择设置分类和标签，系统更新关联关系。
5. 用户可选择发布内容或保存为草稿，系统更新内容状态。
6. 系统记录操作日志，便于后续追踪。

### 5.2. 内容检索与使用流程
1. 用户通过搜索、筛选条件查询内容列表。
2. 系统根据条件返回匹配的内容列表（支持分页）。
3. 用户查看内容详情，系统展示内容主体、附件、标签等信息。
4. 用户使用内容（如推送、引用），系统记录使用行为。
5. 系统更新内容使用统计数据。

### 5.3. 内容批量操作流程
1. 用户选择多个内容，发起批量操作请求（如批量添加标签、批量移动分类）。
2. 系统验证请求参数，创建批量操作任务。
3. 系统异步处理批量操作任务，更新操作进度。
4. 用户可查询批量操作任务进度。
5. 批量操作完成后，系统更新相关统计数据和关联关系。
## 6. 技术考量与开发注意事项

### 6.1. 数据存储与访问
- **存储策略**: 根据内容类型和大小，选择适合的存储策略：
    - 小型文本内容可直接存入数据库
    - 大型文本内容考虑使用文本存储服务
    - 媒体文件（图片、视频等）应使用专门的文件存储服务
- **缓存策略**: 热门内容、分类列表、标签列表等可以考虑缓存，提升访问性能
- **查询优化**: 针对内容列表的复杂查询（多条件、排序、分页），需优化数据库查询性能

### 6.2. 文件处理
- **文件上传**: 支持断点续传、分片上传大文件
- **文件安全**: 上传前检查文件类型、大小，防止恶意文件上传
- **文件存储**: 考虑使用专门的对象存储服务，支持高可用和快速访问
- **文件链接**: 考虑生成带访问控制的临时链接，控制文件访问权限

### 6.3. 并发与性能
- **批量操作**: 大量内容的批量操作应采用异步处理机制，避免长时间阻塞
- **读写分离**: 考虑内容查询和内容修改的读写分离，优化性能
- **数据库索引**: 针对常用查询条件（如标题、分类、标签、创建时间等）建立适当的索引

### 6.4. 安全与权限
- **数据权限**: 确保用户只能访问和操作自己有权限的内容
- **操作审计**: 记录关键操作的日志，支持后续审计和问题追踪
- **敏感数据**: 考虑加密存储敏感内容和附件

## 7. 接口设计指导原则 (Conceptual)

### 7.1. 内容列表查询接口
- **支持多条件查询**: 标题关键词、分类、标签、类型、状态等
- **支持灵活排序**: 创建时间、更新时间、使用频率等
- **支持分页**: 页码、每页数量
- **返回数据**: 分页内容列表、总数、当前页信息

### 7.2. 内容详情查询接口
- **支持按ID查询**: 根据内容ID获取详细信息
- **返回数据**: 内容基本信息、主体内容、相关附件、标签、分类、版本历史、使用统计等

### 7.3. 内容创建/更新接口
- **必要参数**: 标题、内容类型、主体内容
- **可选参数**: 分类、标签、封面图、状态、附件等
- **返回数据**: 创建/更新成功的内容基本信息

### 7.4. 批量操作接口
- **批量更新**: 支持一次更新多个内容的共同属性（如分类、标签、状态）
- **异步处理**: 大量内容的批量操作返回任务ID，支持后续查询进度
- **返回数据**: 任务ID、任务初始状态

## 8. 数据校验与错误处理

### 8.1. 常见数据校验规则
- **内容标题**: 长度限制、禁止特殊字符
- **内容类型**: 枚举值验证（article, image, video, link等）
- **标签/分类**: 存在性验证、数量限制
- **附件**: 类型限制、大小限制、数量限制

### 8.2. 错误处理策略
- **参数错误**: 返回具体错误字段和原因，指导前端修正
- **权限错误**: 明确指出权限不足的具体原因
- **资源不存在**: 明确指出哪些请求的资源未找到
- **系统错误**: 记录详细错误日志，但对外展示友好的错误信息

## 9. 安全性考量

- **访问控制**: 根据用户角色和权限控制内容的可见性和操作权限
- **数据隔离**: 确保多租户环境下的数据严格隔离
- **输入验证**: 防止XSS、SQL注入等常见攻击
- **文件安全**: 上传文件的类型验证、病毒扫描
- **敏感操作审计**: 记录内容创建、修改、删除等关键操作日志

## 10. 可扩展性设计

- **模块解耦**: 内容管理核心与附件存储、标签管理等模块解耦，便于独立扩展
- **版本管理**: API接口版本化，支持平滑迭代
- **自定义字段**: 支持自定义内容属性字段，满足不同业务场景需求
- **事件通知**: 采用事件驱动设计，关键操作触发事件通知，便于系统间集成
 

---

## 文件 35: 后端-我的-设备管理功能开发文档.md

*文件大小：7.69 KB*

---

# 设备管理模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块负责管理用户账号关联的硬件或虚拟设备，是系统与外部物理或虚拟执行终端交互的核心接口。设备管理模块支持应用的自动化执行、多设备协同和设备资源监控等功能，是连接用户账号与实际执行设备的桥梁。

### 1.2. 设计目标
- **多设备管理**: 支持一个用户账号绑定和管理多个执行设备
- **状态监控**: 实时监控设备的在线状态、工作状态和健康状况
- **安全控制**: 确保设备操作的安全性，防止未授权访问和操作
- **资源调度**: 优化设备资源分配，提高设备利用率
- **易用性**: 提供简单易用的设备管理接口，降低使用门槛

## 2. 核心概念

- **设备 (Device)**: 系统中可执行操作的终端，可以是物理设备（如手机、平板）或虚拟设备（如模拟器）
- **设备类型 (Device Type)**: 区分不同种类的设备，如手机、模拟器、PC终端等
- **设备标识 (Device ID)**: 唯一标识一个设备的编码
- **设备状态 (Device Status)**: 设备当前的工作状态，如在线、离线、忙碌等
- **设备绑定 (Device Binding)**: 将设备与用户账号关联的过程
- **设备会话 (Device Session)**: 设备当前的登录会话，包含设备的活跃状态信息

## 3. 核心数据实体/模型 (Conceptual)

- **`Device` (设备)**
    - `deviceId` (设备唯一标识)
    - `userId` (所属用户ID)
    - `deviceName` (设备名称，用户可自定义)
    - `deviceType` (设备类型)
    - `status` (当前状态)
    - `bindTime` (绑定时间)
    - `lastActiveTime` (最后活跃时间)
    - `specs` (设备规格信息，如操作系统、版本等)

- **`DeviceSession` (设备会话)**
    - `sessionId` (会话唯一标识)
    - `deviceId` (设备ID)
    - `startTime` (会话开始时间)
    - `lastHeartbeatTime` (最后心跳时间)
    - `status` (会话状态)
    - `config` (会话配置信息)

- **`DeviceOperation` (设备操作记录)**
    - `operationId` (操作唯一标识)
    - `deviceId` (设备ID)
    - `operationType` (操作类型)
    - `operationTime` (操作时间)
    - `operatedBy` (操作者ID)
    - `result` (操作结果)

## 4. 功能模块划分

### 4.1. 设备管理核心模块
- **功能**:
    - 设备的绑定、查询、更新、解绑操作
    - 设备列表管理
    - 设备基本信息维护
- **主要接口 (Conceptual)**:
    - 设备列表查询
    - 设备绑定
    - 设备解绑
    - 设备信息更新

### 4.2. 设备状态监控模块
- **功能**:
    - 设备在线状态监控
    - 设备健康状况检查
    - 设备活跃度跟踪
- **主要接口 (Conceptual)**:
    - 设备状态查询
    - 设备心跳上报
    - 设备健康状况报告

### 4.3. 设备操作与控制模块
- **功能**:
    - 向设备发送操作指令
    - 获取设备执行结果
    - 管理设备操作队列
- **主要接口 (Conceptual)**:
    - 设备操作发送
    - 操作结果查询
    - 操作队列管理

### 4.4. 设备资源监控模块
- **功能**:
    - 监控设备资源使用情况
    - 设备性能统计
    - 设备异常警报
- **主要接口 (Conceptual)**:
    - 资源使用统计查询
    - 设备性能报告
    - 异常事件订阅

## 5. 主要业务流程示例

### 5.1. 设备绑定流程
1. 用户提交设备绑定请求，提供设备标识和类型等信息。
2. 系统验证设备标识的合法性和唯一性。
3. 系统生成绑定令牌，关联用户账号与设备。
4. 设备使用绑定令牌与系统建立信任连接。
5. 系统记录绑定关系，更新设备状态。
6. 系统返回绑定成功信息，用户可以开始管理和使用该设备。

### 5.2. 设备状态监控流程
1. 设备定期向系统发送心跳包，包含设备ID和状态信息。
2. 系统接收心跳包，更新设备的最后活跃时间和状态。
3. 如果设备在预定时间内未发送心跳，系统将标记设备为离线状态。
4. 用户查询设备列表时，可以看到所有设备的实时状态。
5. 系统可能基于状态变更触发通知或警报。

### 5.3. 设备操作执行流程
1. 用户或系统发起设备操作请求。
2. 系统验证操作权限和设备状态。
3. 系统将操作指令发送到目标设备。
4. 设备执行操作并将结果返回给系统。
5. 系统记录操作结果，并将反馈提供给用户。
6. 如果操作失败或设备无响应，系统实施重试或异常处理机制。

## 6. 技术考量与开发注意事项

### 6.1. 数据存储与访问
- **设备信息存储**: 设备基本信息适合存储在关系型数据库中
- **状态数据存储**: 设备实时状态信息可考虑使用缓存或时序数据库
- **缓存策略**: 频繁访问的设备信息和状态应该缓存，提高查询效率
- **数据一致性**: 确保多服务访问时设备信息的一致性

### 6.2. 实时通信
- **心跳机制**: 实现高效的设备心跳机制，确保状态及时更新
- **推送通道**: 建立服务器到设备的推送通道，支持实时指令下发
- **协议选择**: 根据设备类型和网络环境选择合适的通信协议（如WebSocket、MQTT等）
- **连接管理**: 妥善处理连接的建立、维护和断开

### 6.3. 并发与性能
- **高并发处理**: 设计能处理大量设备同时连接和操作的架构
- **异步操作**: 采用异步方式处理耗时操作，避免阻塞
- **批量操作**: 支持批量设备操作，提高效率
- **性能监控**: 实时监控系统性能，及时发现和解决瓶颈

### 6.4. 安全性考量
- **认证机制**: 实施严格的设备认证机制，防止未授权设备接入
- **通信加密**: 加密设备与服务器间的通信内容
- **操作审计**: 记录所有关键操作，便于追踪和审计
- **权限控制**: 基于角色的访问控制，确保用户只能操作自己的设备

## 7. 接口设计指导原则 (Conceptual)

### 7.1. 设备列表查询接口
- **功能描述**: 获取用户账号下的所有设备列表
- **查询参数**: 分页参数、状态过滤、类型过滤等
- **返回数据**: 设备基本信息列表，包含ID、名称、类型、状态等

### 7.2. 设备绑定接口
- **功能描述**: 将新设备绑定到用户账号
- **请求参数**: 设备标识、设备类型、设备名称等
- **返回数据**: 绑定结果、设备ID等

### 7.3. 设备解绑接口
- **功能描述**: 解除设备与用户账号的绑定关系
- **请求参数**: 设备ID
- **返回数据**: 解绑操作结果

### 7.4. 设备信息更新接口
- **功能描述**: 更新设备的名称等基本信息
- **请求参数**: 设备ID、待更新的字段值
- **返回数据**: 更新操作结果

### 7.5. 设备状态查询接口
- **功能描述**: 获取设备的实时状态信息
- **请求参数**: 设备ID
- **返回数据**: 设备当前状态、最后活跃时间等

## 8. 数据校验与错误处理

### 8.1. 常见数据校验规则
- **设备标识**: 格式验证、唯一性验证
- **设备类型**: 支持的类型范围验证
- **用户权限**: 操作权限验证

### 8.2. 错误处理策略
- **设备不存在**: 返回明确的错误提示
- **设备已绑定**: 提供当前绑定信息和解决方案
- **网络故障**: 实施重试机制并返回友好提示
- **操作超时**: 设定合理的超时时间，提供清晰的超时处理

## 9. 可扩展性设计

- **插件架构**: 支持通过插件扩展设备类型和功能
- **事件驱动**: 采用事件机制处理设备状态变更，便于其他模块响应
- **动态配置**: 支持动态调整设备配置和参数，无需重启服务
- **水平扩展**: 设计支持集群部署的架构，根据设备数量灵活扩展 

---

## 文件 36: 后端-我的-微信号管理功能开发文档.md

*文件大小：7.23 KB*

---

# 微信号管理模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块负责管理用户（员工/运营人员）绑定的个人微信号信息，支撑基于个人微信的客户关系管理、营销互动等业务场景。它涉及到微信号的接入、状态监控、信息同步以及与业务操作的关联。

### 1.2. 设计目标
- **统一管理**：提供集中的微信号信息管理功能。
- **状态可见**：能够实时或准实时地监控绑定微信号的在线状态、健康状况。
- **信息同步**：支持同步微信号的基础信息（如昵称、头像）以及好友列表、群聊列表等（根据具体业务需求和技术可行性）。
- **安全隔离**：确保不同用户/员工的微信号数据隔离与安全。
- **可扩展性**：支持未来可能接入的不同微信客户端类型或版本，以及新的管理需求。

## 2. 核心概念

- **绑定微信号 (Bound WeChat Account)**: 指员工/用户授权接入系统进行管理的个人微信号。
- **微信实例 (WeChat Instance)**: 代表一个已登录并与系统建立通信的微信客户端会话。
- **账号状态 (Account Status)**: 微信号的当前状态，如：离线、登录中、在线、异常、被封禁等。
- **好友 (Contact/Friend)**: 绑定微信号的好友列表。
- **群聊 (ChatRoom/Group)**: 绑定微信号加入的群聊列表。
- **标签 (Tag)**: 为好友或群聊打上的分类标签。
- **同步策略 (Synchronization Strategy)**: 定义信息（如好友、群聊、消息）同步的频率和方式。

## 3. 核心数据实体/模型 (Conceptual)

- **`ManagedWeChatAccount` (受控微信号信息)**
    - `accountId` (系统内微信号唯一ID)
    - `userId` (关联的系统用户ID)
    - `wxid` (微信号原始ID，可选)
    - `nickname` (微信昵称)
    - `avatarUrl` (微信头像链接)
    - `loginQrCode` (当前登录二维码，如有)
    - `status` (在线状态: OFFLINE, LOGGING_IN, ONLINE, ERROR, BANNED)
    - `lastLoginTime` (最后登录时间)
    - `lastSyncTime` (信息最后同步时间)
    - `deviceInfo` (登录设备信息摘要)
    - `remarks` (备注)

- **`WeChatContact` (微信联系人/好友)**
    - `contactId` (系统内联系人唯一ID)
    - `managedAccountId` (所属受控微信号ID)
    - `wxid` (好友原始wxid)
    - `nickname` (好友昵称)
    - `alias` (好友备注名)
    - `avatarUrl` (好友头像)
    - `gender` (性别)
    - `region` (地区)
    - `tags` (标签列表)
    - `isFriend` (是否为好友关系)

- **`WeChatChatRoom` (微信群聊)**
    - `chatRoomId` (系统内群聊唯一ID)
    - `managedAccountId` (所属受控微信号ID)
    - `roomId` (群聊原始ID)
    - `topic` (群名称)
    - `avatarUrl` (群头像)
    - `ownerWxid` (群主wxid)
    - `memberCount` (群成员数量)
    - `members` (群成员列表摘要，可选，可能非常大)
    - `isMuted` (是否免打扰)

## 4. 功能模块划分

### 4.1. 微信号接入与认证模块
- **功能**:
    - 提供扫码登录、授权链接等方式接入新的个人微信号。
    - 管理登录会话，处理登录状态的回调。
    - 安全存储和管理认证凭据（如token）。
- **主要接口 (Conceptual)**:
    - `GET /wechat/accounts/login-qrcode` (获取登录二维码)
    - `POST /wechat/accounts/callback/login-status` (接收登录状态回调)

### 4.2. 微信号信息管理模块
- **功能**:
    - 查看已绑定的微信号列表及其状态。
    - 编辑微信号备注信息。
    - 解绑/删除微信号。
- **主要接口 (Conceptual)**:
    - `GET /wechat/accounts` (查询用户绑定的微信号列表)
    - `PUT /wechat/accounts/{accountId}` (更新微信号备注等)
    - `DELETE /wechat/accounts/{accountId}` (解绑微信号)

### 4.3. 状态监控与心跳模块
- **功能**:
    - 定期检测绑定微信号的在线状态。
    - 处理异常掉线和重连逻辑。
    - 提供状态变更通知。
- **内部机制**:
    - 可能依赖于微信客户端SDK或协议的心跳包。

### 4.4. 数据同步模块 (按需实现)
- **功能**:
    - 同步微信号的好友列表、群聊列表。
    - 同步好友/群聊的详细信息（昵称、头像等）。
    - (可选) 同步聊天记录（需谨慎评估隐私和合规风险）。
- **主要接口 (Conceptual)**:
    - `POST /wechat/accounts/{accountId}/sync/contacts` (手动触发联系人同步)
    - `POST /wechat/accounts/{accountId}/sync/chatrooms` (手动触发群聊同步)
- **内部机制**:
    - 定时任务或事件驱动的同步。

### 4.5. 微信操作代理模块 (支撑上层业务)
- **功能**:
    - 代表绑定的微信号执行操作，如发送消息、添加好友、邀请入群等（具体能力取决于微信客户端SDK或协议）。
    - 这些接口通常由其他业务模块（如CRM、营销自动化）调用。
- **主要接口 (Conceptual, 示例)**:
    - `POST /wechat/actions/send-message`
    - `POST /wechat/actions/add-friend`

## 5. 技术考量与开发注意事项

- **微信客户端集成方案**:
    - **基于官方SDK/API**: 如果微信官方提供针对个人号管理的开发者工具（可能性较低，通常针对公众号/企业微信）。
    - **非官方库/协议封装**: 使用第三方开源库（如Wechaty, Puppet等）或自行逆向/实现微信客户端协议。此方案存在稳定性、合规性及被封号的风险。
    - **Hook技术/Xposed模块**: 在安卓模拟器或真实设备上通过Hook方式控制微信APP。此方案技术门槛高，且同样面临风险。
    - **明确所选方案的技术栈、优缺点及潜在风险。**
- **安全性**:
    - 认证凭据的安全存储。
    - 防止未授权访问和操作。
    - 操作频率控制，避免因操作过于频繁导致账号异常。
- **稳定性与容错**:
    - 处理网络波动、微信客户端崩溃、API变更等问题。
    - 设计合理的重试机制和状态恢复机制。
- **合规性与隐私**:
    - 严格遵守微信平台的使用协议。
    - 明确告知用户数据收集和使用的范围，获取用户授权。
    - 对于好友信息、聊天记录等敏感数据，需有严格的权限控制和审计。
- **资源消耗**:
    - 每个微信实例可能会消耗一定的内存和CPU资源，需要评估服务器承载能力。
- **可维护性**:
    - 微信协议或客户端版本更新可能导致接口失效，需要预留快速迭代和修复的能力。

## 6. 数据校验与错误处理

- 对来自微信客户端的数据进行有效性校验。
- 定义清晰的错误码和错误信息，便于排查问题。
- 记录详细的操作日志和错误日志。

## 7. 安全性考量

- **账号安全**: 防止用户微信号被盗用或滥用。提醒用户开启微信自身安全设置。
- **数据安全**: 传输加密，敏感信息存储加密。
- **操作风险**: 避免执行可能被微信平台判定为违规的操作（如频繁加好友、骚扰信息等）。
- **系统访问安全**: 对管理接口进行严格的权限控制。

## 8. 演进与扩展

- 支持更多类型的微信客户端 (如不同平台的PC版、Mac版等)。
- 增强自动化交互能力 (如基于规则的自动回复)。
- 与更多业务系统集成，提供更丰富的基于个人微信的解决方案。 

---

## 文件 37: 后端-系统集成与第三方平台对接文档.md

*文件大小：31.35 KB*

---

# 存客宝系统集成与第三方平台对接文档

## 1. 概述

存客宝私域流量运营平台需要与多种第三方平台进行集成，包括微信、抖音、小红书等社交媒体平台，以及CRM、ERP等企业内部系统。本文档描述了系统与各平台的对接方式、接口调用流程、授权管理以及常见问题处理方法。

### 1.1 主要集成平台

- **社交媒体平台**：微信（个人号、公众号、小程序）、抖音、小红书
- **电商平台**：淘宝、京东、拼多多
- **企业协作平台**：钉钉、企业微信
- **AI服务**：OpenAI、智谱AI
- **内部系统**：CRM、ERP、OA系统

### 1.2 集成架构

![集成架构图](集成架构图位置)

存客宝采用中间适配层设计，通过统一的集成适配器封装各平台的差异，对内部系统提供一致的接口和数据结构。

## 2. 微信平台集成

### 2.1 微信个人号集成

存客宝通过自研设备控制方案实现微信个人号的集成，主要包含以下功能：

- 自动登录与状态维护
- 好友添加与管理
- 消息收发与管理
- 朋友圈发布与互动
- 群管理与群消息
- 素材分发与文件传输

#### 2.1.1 设备控制协议

```java
/**
 * 设备命令类型
 */
public enum DeviceCommandType {
    LOGIN,               // 登录
    SEND_MESSAGE,        // 发送消息
    ADD_FRIEND,          // 添加好友
    CREATE_GROUP,        // 创建群
    POST_MOMENTS,        // 发朋友圈
    LIKE_MOMENTS,        // 点赞朋友圈
    COMMENT_MOMENTS,     // 评论朋友圈
    ACCEPT_FRIEND,       // 接受好友请求
    UPLOAD_FILE,         // 上传文件
    DOWNLOAD_FILE,       // 下载文件
    GET_FRIENDS,         // 获取好友列表
    GET_GROUPS,          // 获取群列表
    GET_MOMENTS,         // 获取朋友圈列表
    LOGOUT               // 登出
}

/**
 * 设备命令请求
 */
public class DeviceCommandRequest {
    private String commandId;
    private DeviceCommandType type;
    private Map<String, Object> params;
    private Date timestamp;
}

/**
 * 设备命令响应
 */
public class DeviceCommandResponse {
    private String commandId;
    private boolean success;
    private Object data;
    private String errorMessage;
    private Date timestamp;
}
```

#### 2.1.2 设备链接管理服务

```java
@Service
public class DeviceConnectionService {

    private final Map<Long, DeviceSession> deviceSessions = new ConcurrentHashMap<>();
    
    @Autowired
    private DeviceRepository deviceRepository;
    
    /**
     * 设备连接处理
     */
    public void handleConnection(WebSocketSession session, String deviceKey) {
        Device device = deviceRepository.findByDeviceKey(deviceKey);
        if (device == null) {
            closeSession(session, "Unknown device");
            return;
        }
        
        DeviceSession deviceSession = new DeviceSession(session, device);
        deviceSessions.put(device.getId(), deviceSession);
        
        // 更新设备状态
        device.setStatus(DeviceStatus.ONLINE);
        device.setLastActiveTime(new Date());
        deviceRepository.save(device);
    }
    
    /**
     * 设备断开处理
     */
    public void handleDisconnection(WebSocketSession session) {
        // 实现设备断开逻辑
    }
    
    /**
     * 发送命令到设备
     */
    public DeviceCommandResponse sendCommand(Long deviceId, DeviceCommandRequest command) {
        DeviceSession session = deviceSessions.get(deviceId);
        if (session == null) {
            throw new DeviceOfflineException("Device is not connected: " + deviceId);
        }
        
        return session.sendCommand(command);
    }
}
```

### 2.2 微信公众号集成

通过微信公众号开放平台API实现自动化管理，包括：

- 消息接收与处理
- 自动回复配置
- 图文素材管理
- 粉丝管理
- 模板消息发送
- 菜单配置

#### 2.2.1 公众号授权配置

```java
@Service
public class WechatMpService {

    @Value("${wechat.mp.appId}")
    private String appId;
    
    @Value("${wechat.mp.appSecret}")
    private String appSecret;
    
    @Value("${wechat.mp.token}")
    private String token;
    
    @Value("${wechat.mp.aesKey}")
    private String aesKey;
    
    @Autowired
    private WechatMpAccountRepository accountRepository;
    
    private WxMpService wxMpService;
    
    @PostConstruct
    public void init() {
        WxMpDefaultConfigImpl config = new WxMpDefaultConfigImpl();
        config.setAppId(appId);
        config.setSecret(appSecret);
        config.setToken(token);
        config.setAesKey(aesKey);
        
        wxMpService = new WxMpServiceImpl();
        wxMpService.setWxMpConfigStorage(config);
    }
    
    /**
     * 处理微信服务器验证
     */
    public String verifyServer(String signature, String timestamp, String nonce, String echostr) {
        if (wxMpService.checkSignature(timestamp, nonce, signature)) {
            return echostr;
        }
        return "非法请求";
    }
    
    /**
     * 处理微信消息
     */
    public String processMessage(String requestBody, String signature, String timestamp, String nonce, String encType, String msgSignature) {
        // 实现消息处理逻辑
    }
    
    /**
     * 发送模板消息
     */
    public boolean sendTemplateMessage(String openId, String templateId, String url, Map<String, String> data) {
        // 实现模板消息发送逻辑
    }
}
```

### 2.3 微信小程序集成

通过微信小程序的开放接口，实现以下功能：

- 用户登录与授权
- 获取用户信息
- 消息订阅与推送
- 小程序码生成
- 数据解密

#### 2.3.1 小程序登录流程

```java
@RestController
@RequestMapping("/api/v1/wechat/mini")
public class WechatMiniController {

    @Autowired
    private WechatMiniService wechatMiniService;
    
    @Autowired
    private UserService userService;
    
    /**
     * 小程序登录
     */
    @PostMapping("/login")
    public R<WechatMiniLoginVO> login(@RequestBody WechatMiniLoginDTO dto) {
        // 通过code获取会话信息
        WxMaJscode2SessionResult sessionResult = wechatMiniService.getSessionInfo(dto.getCode());
        
        // 解密用户信息
        WxMaUserInfo userInfo = null;
        if (dto.getEncryptedData() != null && dto.getIv() != null) {
            userInfo = wechatMiniService.decryptUserInfo(
                    sessionResult.getSessionKey(), dto.getEncryptedData(), dto.getIv());
        }
        
        // 用户注册或登录
        Long userId = userService.loginByWechatMini(sessionResult.getOpenid(), userInfo);
        
        // 生成登录令牌
        String token = authService.generateToken(userId);
        
        // 返回登录结果
        WechatMiniLoginVO result = new WechatMiniLoginVO();
        result.setToken(token);
        result.setOpenid(sessionResult.getOpenid());
        
        return R.ok(result);
    }
}
```

## 3. 抖音平台集成

### 3.1 抖音开放平台授权

通过抖音开放平台实现以下功能：

- 账号授权与管理
- 视频发布与管理
- 用户数据获取
- 评论管理
- 粉丝互动

#### 3.1.1 抖音授权流程

```java
@Service
public class DouyinService {

    @Value("${douyin.clientKey}")
    private String clientKey;
    
    @Value("${douyin.clientSecret}")
    private String clientSecret;
    
    @Autowired
    private DouyinAccountRepository accountRepository;
    
    /**
     * 获取授权URL
     */
    public String getAuthUrl(String redirectUri, String state) {
        return "https://open.douyin.com/platform/oauth/connect?" +
                "client_key=" + clientKey +
                "&response_type=code" +
                "&scope=user_info,video.create,video.list,video.data" +
                "&redirect_uri=" + URLEncoder.encode(redirectUri, StandardCharsets.UTF_8) +
                "&state=" + state;
    }
    
    /**
     * 获取访问令牌
     */
    public DouyinTokenVO getAccessToken(String code) {
        // 调用抖音API获取访问令牌
        String url = "https://open.douyin.com/oauth/access_token?" +
                "client_key=" + clientKey +
                "&client_secret=" + clientSecret +
                "&code=" + code +
                "&grant_type=authorization_code";
        
        // 发送请求并处理响应
        RestTemplate restTemplate = new RestTemplate();
        DouyinTokenResponse response = restTemplate.getForObject(url, DouyinTokenResponse.class);
        
        if (response == null || response.getData() == null) {
            throw new DouyinApiException("Failed to get access token");
        }
        
        // 保存或更新授权信息
        saveDouyinAccount(response.getData());
        
        return buildTokenVO(response.getData());
    }
    
    /**
     * 发布视频
     */
    public DouyinVideoVO createVideo(Long accountId, DouyinVideoDTO dto) {
        // 实现视频发布逻辑
    }
    
    /**
     * 获取视频列表
     */
    public List<DouyinVideoVO> getVideos(Long accountId, Integer page, Integer size) {
        // 实现视频列表获取逻辑
    }
}
```

### 3.2 抖音数据同步

定期同步抖音平台数据，包括：

- 视频数据（播放量、点赞数、评论数）
- 粉丝数据（新增粉丝、粉丝画像）
- 互动数据（评论内容、私信）

```java
@Component
public class DouyinDataSyncJob {

    @Autowired
    private DouyinService douyinService;
    
    @Autowired
    private DouyinDataRepository dataRepository;
    
    /**
     * 每天凌晨2点同步抖音数据
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void syncDouyinData() {
        List<DouyinAccount> accounts = douyinService.getAllActiveAccounts();
        
        for (DouyinAccount account : accounts) {
            try {
                // 同步视频数据
                syncVideoData(account);
                
                // 同步粉丝数据
                syncFansData(account);
                
                // 同步互动数据
                syncInteractionData(account);
                
                // 更新同步状态
                account.setLastSyncTime(new Date());
                douyinService.updateAccount(account);
            } catch (Exception e) {
                log.error("Failed to sync data for douyin account: " + account.getId(), e);
            }
        }
    }
    
    private void syncVideoData(DouyinAccount account) {
        // 实现视频数据同步
    }
    
    private void syncFansData(DouyinAccount account) {
        // 实现粉丝数据同步
    }
    
    private void syncInteractionData(DouyinAccount account) {
        // 实现互动数据同步
    }
}
```

## 4. 小红书平台集成

### 4.1 小红书开放平台授权

通过小红书开放平台实现以下功能：

- 账号授权与管理
- 笔记发布与管理
- 用户数据获取
- 评论管理

### 4.2 小红书数据采集

对于没有完整API的功能，使用爬虫技术采集数据：

```java
@Service
public class XiaohongshuCrawlerService {

    @Autowired
    private WebDriverPool webDriverPool;
    
    @Autowired
    private XiaohongshuDataRepository dataRepository;
    
    /**
     * 抓取笔记数据
     */
    public XiaohongshuNoteVO crawlNote(String noteUrl) {
        WebDriver driver = null;
        try {
            driver = webDriverPool.getDriver();
            
            // 加载页面
            driver.get(noteUrl);
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.className("note-content")));
            
            // 解析数据
            XiaohongshuNoteVO note = new XiaohongshuNoteVO();
            note.setTitle(driver.findElement(By.className("title")).getText());
            note.setContent(driver.findElement(By.className("content")).getText());
            note.setLikes(parseNumber(driver.findElement(By.className("like-count")).getText()));
            note.setCollects(parseNumber(driver.findElement(By.className("collect-count")).getText()));
            note.setComments(parseNumber(driver.findElement(By.className("comment-count")).getText()));
            
            // 获取图片
            List<WebElement> imgElements = driver.findElements(By.cssSelector(".img-container img"));
            List<String> images = new ArrayList<>();
            for (WebElement imgElement : imgElements) {
                String imgUrl = imgElement.getAttribute("src");
                if (imgUrl != null && !imgUrl.isEmpty()) {
                    images.add(imgUrl);
                }
            }
            note.setImages(images);
            
            return note;
        } finally {
            if (driver != null) {
                webDriverPool.returnDriver(driver);
            }
        }
    }
    
    private int parseNumber(String text) {
        // 解析数字，处理"1.2w"这样的格式
    }
}
```

## 5. AI服务集成

### 5.1 OpenAI服务集成

集成OpenAI的GPT模型，实现以下功能：

- 文本内容生成
- 内容摘要与改写
- 智能客服回复
- 情感分析
- 标签提取

```java
@Service
public class OpenAIService {

    @Value("${openai.api-key}")
    private String apiKey;
    
    @Value("${openai.model}")
    private String model;
    
    @Value("${openai.api-url}")
    private String apiUrl;
    
    private final RestTemplate restTemplate;
    
    public OpenAIService() {
        this.restTemplate = new RestTemplate();
    }
    
    /**
     * 生成内容
     */
    public String generateContent(String prompt, int maxTokens) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("Authorization", "Bearer " + apiKey);
        
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("model", model);
        requestBody.put("prompt", prompt);
        requestBody.put("max_tokens", maxTokens);
        requestBody.put("temperature", 0.7);
        
        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);
        
        try {
            ResponseEntity<OpenAIResponse> response = restTemplate.postForEntity(
                    apiUrl + "/completions",
                    entity,
                    OpenAIResponse.class);
            
            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                return response.getBody().getChoices().get(0).getText().trim();
            } else {
                throw new AIServiceException("Failed to generate content");
            }
        } catch (Exception e) {
            throw new AIServiceException("OpenAI service error", e);
        }
    }
    
    /**
     * 内容改写
     */
    public String rewriteContent(String content, String style) {
        String prompt = "Please rewrite the following content in " + style + " style:\n\n" + content;
        return generateContent(prompt, 1000);
    }
    
    /**
     * 情感分析
     */
    public SentimentAnalysisVO analyzeSentiment(String text) {
        String prompt = "Analyze the sentiment of the following text. " +
                "Return result as JSON with sentiment (POSITIVE, NEUTRAL, NEGATIVE) and confidence score (0-100):\n\n" + text;
        
        String result = generateContent(prompt, 500);
        
        // 解析JSON结果
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(result, SentimentAnalysisVO.class);
        } catch (Exception e) {
            throw new AIServiceException("Failed to parse sentiment analysis result", e);
        }
    }
}
```

### 5.2 智谱AI集成

集成智谱AI的中文大模型，实现以下功能：

- 中文内容生成
- 行业知识问答
- 客户意图识别
- 文本分类

```java
@Service
public class ZhipuAIService {

    @Value("${zhipu.api-key}")
    private String apiKey;
    
    @Value("${zhipu.api-url}")
    private String apiUrl;
    
    /**
     * 生成内容
     */
    public String generateContent(String prompt) {
        // 实现智谱AI调用逻辑
    }
    
    /**
     * 行业知识问答
     */
    public String answerQuestion(String question, String domain) {
        // 实现行业知识问答逻辑
    }
}
```

## 6. CRM系统集成

### 6.1 客户数据同步

与企业CRM系统进行客户数据双向同步：

```java
@Service
public class CRMIntegrationService {

    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private CustomerSyncLogRepository syncLogRepository;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Value("${crm.api-url}")
    private String crmApiUrl;
    
    @Value("${crm.api-key}")
    private String crmApiKey;
    
    /**
     * 将客户数据同步到CRM
     */
    @Transactional
    public void syncCustomerToCRM(Long customerId) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException("Customer not found: " + customerId));
        
        if (customer.getLastSyncTime() != null && 
                customer.getUpdateTime().before(customer.getLastSyncTime())) {
            // 数据未修改，无需同步
            return;
        }
        
        // 构建请求数据
        CRMCustomerDTO crmCustomer = buildCRMCustomerDTO(customer);
        
        // 发送同步请求
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("API-Key", crmApiKey);
            
            HttpEntity<CRMCustomerDTO> entity = new HttpEntity<>(crmCustomer, headers);
            
            ResponseEntity<CRMResponse> response;
            if (customer.getCrmId() != null) {
                // 更新已有客户
                response = restTemplate.exchange(
                        crmApiUrl + "/customers/" + customer.getCrmId(),
                        HttpMethod.PUT,
                        entity,
                        CRMResponse.class);
            } else {
                // 创建新客户
                response = restTemplate.exchange(
                        crmApiUrl + "/customers",
                        HttpMethod.POST,
                        entity,
                        CRMResponse.class);
            }
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                // 更新客户CRM ID和同步时间
                customer.setCrmId(response.getBody().getData().getId());
                customer.setLastSyncTime(new Date());
                customerRepository.save(customer);
                
                // 记录同步日志
                CustomerSyncLog log = new CustomerSyncLog();
                log.setCustomerId(customer.getId());
                log.setDirection(SyncDirection.TO_CRM);
                log.setStatus(SyncStatus.SUCCESS);
                log.setSyncTime(new Date());
                syncLogRepository.save(log);
            } else {
                throw new CRMSyncException("Failed to sync customer to CRM");
            }
        } catch (Exception e) {
            // 记录同步失败日志
            CustomerSyncLog log = new CustomerSyncLog();
            log.setCustomerId(customer.getId());
            log.setDirection(SyncDirection.TO_CRM);
            log.setStatus(SyncStatus.FAILED);
            log.setErrorMessage(e.getMessage());
            log.setSyncTime(new Date());
            syncLogRepository.save(log);
            
            throw new CRMSyncException("Failed to sync customer to CRM", e);
        }
    }
    
    /**
     * 从CRM同步客户数据
     */
    @Transactional
    public void syncCustomerFromCRM(String crmId) {
        // 实现从CRM同步客户数据的逻辑
    }
    
    private CRMCustomerDTO buildCRMCustomerDTO(Customer customer) {
        // 构建CRM客户DTO
    }
}
```

### 6.2 订单数据集成

与企业ERP/CRM系统集成订单数据：

```java
@Service
public class OrderIntegrationService {

    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Value("${erp.api-url}")
    private String erpApiUrl;
    
    @Value("${erp.api-key}")
    private String erpApiKey;
    
    /**
     * 从ERP同步订单数据
     */
    @Scheduled(cron = "0 0 */2 * * ?")  // 每2小时执行一次
    public void syncOrdersFromERP() {
        // 获取最后同步时间
        Date lastSyncTime = getLastOrderSyncTime();
        Date now = new Date();
        
        // 构建请求参数
        Map<String, Object> params = new HashMap<>();
        if (lastSyncTime != null) {
            params.put("updatedAfter", formatDate(lastSyncTime));
        }
        
        // 发送请求
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.set("API-Key", erpApiKey);
            
            UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(erpApiUrl + "/orders")
                    .queryParams(convertMapToMultiValueMap(params));
            
            ResponseEntity<ERPOrderListResponse> response = restTemplate.exchange(
                    builder.toUriString(),
                    HttpMethod.GET,
                    new HttpEntity<>(headers),
                    ERPOrderListResponse.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                // 处理订单数据
                processOrders(response.getBody().getData());
                
                // 更新同步时间
                updateOrderSyncTime(now);
            }
        } catch (Exception e) {
            log.error("Failed to sync orders from ERP", e);
        }
    }
    
    private void processOrders(List<ERPOrderDTO> orders) {
        // 处理订单数据
    }
}
```

## 7. 通用集成组件

### 7.1 通用API适配器

为了支持多种外部API的统一调用，实现通用API适配器：

```java
public interface ApiAdapter<T, R> {
    R call(T request);
}

@Component
public class ApiAdapterRegistry {

    private final Map<String, ApiAdapter<?, ?>> adapters = new HashMap<>();
    
    @PostConstruct
    public void init() {
        // 注册适配器
        registerAdapter("wechat.mp", new WechatMpApiAdapter());
        registerAdapter("douyin", new DouyinApiAdapter());
        registerAdapter("xiaohongshu", new XiaohongshuApiAdapter());
        registerAdapter("openai", new OpenAIApiAdapter());
        registerAdapter("crm", new CRMApiAdapter());
    }
    
    public <T, R> void registerAdapter(String type, ApiAdapter<T, R> adapter) {
        adapters.put(type, adapter);
    }
    
    @SuppressWarnings("unchecked")
    public <T, R> ApiAdapter<T, R> getAdapter(String type) {
        return (ApiAdapter<T, R>) adapters.get(type);
    }
}

@Service
public class ApiService {

    @Autowired
    private ApiAdapterRegistry adapterRegistry;
    
    public <T, R> R callApi(String type, T request) {
        ApiAdapter<T, R> adapter = adapterRegistry.getAdapter(type);
        if (adapter == null) {
            throw new ApiAdapterNotFoundException("API adapter not found: " + type);
        }
        
        return adapter.call(request);
    }
}
```

### 7.2 通用Webhook处理

实现通用的Webhook接收与处理框架：

```java
public interface WebhookProcessor {
    void process(String payload, Map<String, String> headers);
}

@Service
public class WebhookService {

    private final Map<String, WebhookProcessor> processors = new HashMap<>();
    
    @PostConstruct
    public void init() {
        // 注册Webhook处理器
        registerProcessor("wechat", new WechatWebhookProcessor());
        registerProcessor("douyin", new DouyinWebhookProcessor());
        registerProcessor("crm", new CRMWebhookProcessor());
    }
    
    public void registerProcessor(String type, WebhookProcessor processor) {
        processors.put(type, processor);
    }
    
    public void processWebhook(String type, String payload, Map<String, String> headers) {
        WebhookProcessor processor = processors.get(type);
        if (processor == null) {
            throw new WebhookProcessorNotFoundException("Webhook processor not found: " + type);
        }
        
        processor.process(payload, headers);
    }
}

@RestController
@RequestMapping("/api/v1/webhook")
public class WebhookController {

    @Autowired
    private WebhookService webhookService;
    
    @PostMapping("/{type}")
    public ResponseEntity<String> handleWebhook(
            @PathVariable String type,
            @RequestBody String payload,
            @RequestHeader Map<String, String> headers) {
        
        try {
            webhookService.processWebhook(type, payload, headers);
            return ResponseEntity.ok("success");
        } catch (Exception e) {
            log.error("Failed to process webhook: " + type, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("error");
        }
    }
}
```

## 8. 安全与授权管理

### 8.1 API密钥管理

```java
@Service
public class ApiKeyService {

    @Autowired
    private ApiKeyRepository apiKeyRepository;
    
    @Autowired
    private EncryptionService encryptionService;
    
    /**
     * 创建API密钥
     */
    public ApiKeyVO createApiKey(ApiKeyDTO dto) {
        // 生成密钥
        String apiKey = generateApiKey();
        String apiSecret = generateApiSecret();
        
        // 创建记录
        ApiKey entity = new ApiKey();
        entity.setName(dto.getName());
        entity.setPlatform(dto.getPlatform());
        entity.setApiKey(apiKey);
        entity.setApiSecret(encryptionService.encrypt(apiSecret));
        entity.setStatus(ApiKeyStatus.ACTIVE);
        entity.setExpiryDate(dto.getExpiryDate());
        entity.setCreateTime(new Date());
        
        ApiKey savedEntity = apiKeyRepository.save(entity);
        
        // 构建返回对象
        ApiKeyVO vo = new ApiKeyVO();
        vo.setId(savedEntity.getId());
        vo.setName(savedEntity.getName());
        vo.setPlatform(savedEntity.getPlatform());
        vo.setApiKey(apiKey);
        vo.setApiSecret(apiSecret);  // 仅在创建时返回明文密钥
        vo.setStatus(savedEntity.getStatus());
        vo.setExpiryDate(savedEntity.getExpiryDate());
        vo.setCreateTime(savedEntity.getCreateTime());
        
        return vo;
    }
    
    /**
     * 验证API密钥
     */
    public boolean verifyApiKey(String apiKey, String apiSecret) {
        ApiKey entity = apiKeyRepository.findByApiKey(apiKey);
        if (entity == null || entity.getStatus() != ApiKeyStatus.ACTIVE) {
            return false;
        }
        
        // 验证过期时间
        if (entity.getExpiryDate() != null && entity.getExpiryDate().before(new Date())) {
            return false;
        }
        
        // 验证密钥
        String decryptedSecret = encryptionService.decrypt(entity.getApiSecret());
        return decryptedSecret.equals(apiSecret);
    }
    
    private String generateApiKey() {
        // 生成API Key
    }
    
    private String generateApiSecret() {
        // 生成API Secret
    }
}
```

### 8.2 授权令牌管理

```java
@Service
public class AuthTokenService {

    @Autowired
    private AuthTokenRepository authTokenRepository;
    
    @Autowired
    private EncryptionService encryptionService;
    
    /**
     * 保存授权令牌
     */
    public void saveAuthToken(AuthTokenDTO dto) {
        AuthToken token = new AuthToken();
        token.setPlatform(dto.getPlatform());
        token.setAccountId(dto.getAccountId());
        token.setAccessToken(encryptionService.encrypt(dto.getAccessToken()));
        token.setRefreshToken(dto.getRefreshToken() != null ? 
                encryptionService.encrypt(dto.getRefreshToken()) : null);
        token.setExpiresIn(dto.getExpiresIn());
        token.setExpiryTime(calculateExpiryTime(dto.getExpiresIn()));
        token.setCreateTime(new Date());
        
        authTokenRepository.save(token);
    }
    
    /**
     * 获取有效令牌
     */
    public String getValidAccessToken(String platform, Long accountId) {
        // 查找最新令牌
        AuthToken token = authTokenRepository.findTopByPlatformAndAccountIdOrderByCreateTimeDesc(
                platform, accountId);
        
        if (token == null) {
            throw new TokenNotFoundException("No token found for platform: " + platform + ", account: " + accountId);
        }
        
        // 检查令牌是否过期
        if (token.getExpiryTime() != null && token.getExpiryTime().before(new Date())) {
            // 令牌已过期，尝试刷新
            if (token.getRefreshToken() != null) {
                return refreshToken(token);
            } else {
                throw new TokenExpiredException("Token expired and no refresh token available");
            }
        }
        
        // 返回解密后的令牌
        return encryptionService.decrypt(token.getAccessToken());
    }
    
    /**
     * 刷新令牌
     */
    private String refreshToken(AuthToken token) {
        // 实现令牌刷新逻辑
    }
    
    private Date calculateExpiryTime(Integer expiresIn) {
        // 计算过期时间
    }
}
```

## 9. 常见问题及解决方案

### 9.1 微信个人号登录失效问题

**问题描述**：微信不定期更新防控策略，可能导致自动化登录失效。

**解决方案**：
1. 实现多账号备份策略，一个账号失效自动切换到备用账号
2. 设置登录状态监控，发现异常立即通知管理员
3. 定期更新设备信息和登录参数，避免被识别为自动化工具
4. 实现手动协助登录流程，必要时由人工介入

### 9.2 抖音/小红书授权过期问题

**问题描述**：第三方平台授权可能到期或被平台撤销。

**解决方案**：
1. 建立授权状态监控，提前通知即将过期的授权
2. 实现自动刷新令牌机制，维持授权有效性
3. 对授权失败的操作实现降级策略，避免业务中断
4. 设置多级告警，确保问题及时处理

### 9.3 API调用频率限制处理

**问题描述**：第三方平台通常有API调用频率限制。

**解决方案**：
1. 实现请求限流和队列机制，控制API调用频率
2. 对高频调用进行合并处理，减少请求次数
3. 实现缓存策略，避免重复调用
4. 针对不同平台设置不同的调用策略和优先级

### 9.4 数据同步冲突解决

**问题描述**：多系统间数据同步可能存在冲突。

**解决方案**：
1. 实现基于时间戳的冲突检测机制
2. 定义明确的数据主导权规则，确定哪个系统的数据优先
3. 对冲突数据建立人工审核流程
4. 保留完整的数据变更日志，支持手动数据修复

## 10. 性能与可靠性

### 10.1 性能优化

1. **API调用批处理**：将多个单独API调用合并为批量请求
2. **异步处理**：非关键路径操作使用消息队列异步处理
3. **缓存策略**：频繁访问的外部数据进行本地缓存
4. **请求超时与重试**：设置合理的超时时间和重试策略
5. **并发控制**：使用线程池控制并发请求数量

### 10.2 可靠性保障

1. **熔断机制**：对不稳定的外部服务实现熔断保护
2. **降级策略**：服务不可用时提供降级方案
3. **完整日志**：记录所有外部调用的请求和响应
4. **监控告警**：对关键接口实现性能监控和异常告警
5. **故障自愈**：设计自动恢复机制，如定期任务检查并修复失败的同步 

---

## 文件 38: 后端-系统设置-后端开发文档.md

*文件大小：7.72 KB*

---

# 存客宝系统设置模块后端开发文档

## 1. 模块概述

系统设置模块负责管理平台的全局配置和各项设置，为系统功能的正常运行提供基础配置。这些设置可能影响用户体验、业务流程、第三方服务对接等方面。通过此模块，管理员可以方便地查看和修改系统级配置，而无需修改代码。

模块功能包括但不限于：系统基础参数、通知配置、第三方服务（如短信、邮件、对象存储、支付接口）配置、功能开关等。

## 2. API接口设计

### 2.1 获取所有系统设置

- **接口路径**：`/api/v1/settings`
- **请求方法**：`GET`
- **接口说明**：获取系统所有的配置项列表。此接口通常仅供管理员使用。
- **权限:** `system:settings:view`
- **请求参数 (Query Parameters):**

| 参数名 | 类型    | 是否必需 | 描述         | 示例值 |
|--------|--------|----------|--------------|--------|
| group  | string | 否       | 按配置分组过滤 | notification |

- **响应数据 (统一格式 `data`字段):** 返回系统配置项列表，敏感信息应已脱敏。

```json
[
  {
    "key": "site.name",
    "value": "存客宝",
    "group": "basic",
    "description": "网站名称",
    "valueType": "string"
  },
  {
    "key": "notification.sms.enabled",
    "value": "true",
    "group": "notification",
    "description": "短信通知是否开启",
    "valueType": "boolean"
  },
   {
    "key": "thirdparty.oss.endpoint",
    "value": "oss-cn-hangzhou.aliyuncs.com", // 敏感信息可能需要脱敏
    "group": "thirdparty",
    "description": "对象存储服务Endpoint",
    "valueType": "string"
  }
  // ... 更多配置项
]
```
- **可能返回状态码:** 200 (成功), 401, 403, 500

### 2.2 获取特定系统设置

- **接口路径**：`/api/v1/settings/{key}`
- **请求方法**：`GET`
- **接口说明**：根据配置项的 key 获取其详细信息和值。此接口通常仅供管理员使用，敏感信息应已脱敏。
- **权限:** `system:settings:view`
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明           | 示例值 |
|--------|--------|----------|----------------|--------|
| key    | string | 是       | 配置项的唯一键 | site.name |

- **响应数据 (统一格式 `data`字段):** 返回单个配置项的详细信息。

```json
{
  "key": "site.name",
  "value": "存客宝",
  "group": "basic",
  "description": "网站名称",
  "valueType": "string",
  "isSensitive": false // 是否敏感信息
  // ... 其他元信息
}
```
- **可能返回状态码:** 200 (成功), 401, 403, 404 (配置项不存在), 500

### 2.3 更新特定系统设置

- **接口路径**：`/api/v1/settings/{key}`
- **请求方法**：`PUT`
- **接口说明**：更新指定配置项的值。此接口仅供管理员使用。
- **权限:** `system:settings:update`
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明           | 示例值 |
|--------|--------|----------|----------------|--------|
| key    | string | 是       | 配置项的唯一键 | site.name |

- **请求体 (Request Body):**

| 参数名 | 类型    | 是否必需 | 描述     | 示例值 |
|--------|--------|----------|----------|--------|
| value  | string | 是       | 新的配置值 | 存客宝私域系统 |

- **响应数据 (统一格式 `data`字段):** 返回更新后的配置项信息（通常包含 key, value, updateTime等）。

```json
{
  "key": "site.name",
  "value": "存客宝私域系统",
  "updateTime": "2023-10-26T16:00:00Z"
  // ... 其他更新后的字段
}
```
- **可能返回状态码:** 200 (更新成功), 400 (参数错误/值格式不匹配), 401, 403, 404, 422 (数据校验失败), 500

## 3. 数据模型设计

系统配置信息存储在一张专门的配置表中。

### 3.1 系统配置表 `t_system_config`

| 字段名        | 类型         | 是否必需 | 说明                                   | 索引        |
|--------------|--------------|----------|----------------------------------------|------------|
| id           | BIGINT (PK)  | 是       | 主键                                   |            |
| `key`        | VARCHAR(255) | 是       | 配置项的唯一键 (如 `site.name`)          | UNIQUE Index |
| `value`      | TEXT         | 是       | 配置项的值。使用 TEXT 类型以便存储较长值。 |            |
| `group`      | VARCHAR(50)  | 否       | 配置项所属分组 (如 `basic`, `notification`) | Index      |
| description  | VARCHAR(500) | 否       | 配置项描述                             |            |
| value_type   | VARCHAR(20)  | 是       | 值的类型 (string, int, boolean, json)    |            |
| is_sensitive | BOOLEAN      | 是       | 是否敏感信息，需要加密存储和脱敏展示     |            |
| create_time  | DATETIME     | 是       | 创建时间                               |            |
| update_time  | DATETIME     | 是       | 更新时间                               |            |

**注意:** `value` 字段的数据类型应根据 `value_type` 进行解析和转换。敏感信息 (`is_sensitive = true`) 在存储时需要加密，在查询返回给前端时需要脱敏处理（例如返回 `********`）。

## 4. 异常处理

- `SettingNotFoundException`: 配置项不存在异常
- `InvalidSettingValueException`: 配置值格式或类型不匹配异常
- `SystemSettingUpdateException`: 系统设置更新失败异常
- `SensitiveDataEncryptionException`: 敏感数据加密解密异常

## 5. 开发注意事项和实现要点

1.  **配置读取和缓存:**
    - 系统在启动时应加载所有配置项到内存中，并使用缓存机制（如 Redis 或本地缓存）提高读取效率。
    - 配置更新后，需要通知缓存进行刷新，确保获取到最新的配置值。
2.  **敏感信息处理:**
    - 对于标记为敏感的信息（如第三方服务密钥、密码等），在存入数据库前必须进行加密。
    - 在从数据库读取并返回给前端时，必须进行脱敏处理，避免泄露敏感信息。
    - 加密密钥需要妥善管理，不能与应用代码一起存储，可以考虑使用密钥管理服务。
3.  **数据验证:**
    - 在更新配置项时，需要根据 `value_type` 对提交的值进行严格的格式和类型验证。
    - 使用 Spring Validation 框架结合注解进行声明式验证。验证失败时，按照 `./前后端接口约定.md` 中的约定返回 422 状态码和详细的错误信息列表。
4.  **权限控制:**
    - 系统设置模块的接口应只对具有特定管理员权限的用户开放。
    - 使用 Spring Security 或类似的权限框架进行接口级别的权限校验。
5.  **错误处理:**
    - 遵循 `./前后端接口约定.md` 中的错误处理规范。
    - 捕获并处理配置项不存在、值格式错误、权限不足等异常，返回统一的错误响应格式。
6.  **日志记录:**
    - 记录所有系统设置的修改操作日志，包括操作人、修改时间、修改前后的值（敏感信息脱敏）。
    - 记录配置读取异常、缓存刷新异常、敏感数据处理异常等日志。
7.  **配置项管理:**
    - 考虑提供配置项的元信息管理，如配置项的类型、默认值、取值范围、是否必需、描述等，方便前端界面生成和后端校验。
    - 如果配置项较多且变动频繁，可以考虑引入外部配置中心（如 Nacos, Apollo）来集中管理和动态刷新配置。
8.  **事务管理:**
    - 配置项的更新操作涉及数据库写入，需要使用 `@Transactional` 注解或其他方式确保操作的原子性。
9.  **版本控制 (可选):**
    - 对于重要的配置项，可以考虑记录配置值的历史版本，以便回溯。

--- 

---

## 文件 39: 后端-营销活动-后端开发文档.md

*文件大小：17.50 KB*

---

# 营销活动模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
营销活动模块是驱动用户增长、提升用户活跃度、促进销售转化的核心业务引擎。它使平台能够设计、配置、执行和管理多样化的营销策略，如优惠券、折扣、满减、秒杀、拼团、积分换购等，以吸引和激励用户参与。

### 1.2 设计目标
- **灵活性与多样性**: 支持创建和组合不同类型的营销活动和规则，满足各种业务场景需求。
- **易用性与可配置性**: 提供直观的活动配置界面和API，方便运营人员快速创建和调整活动。
- **高性能与高并发**: 确保在高并发场景下（如秒杀、大规模领券）活动的稳定运行和规则的准确执行。
- **精准性与可控性**: 能够精确控制活动的目标用户、参与条件、优惠力度、预算和库存。
- **可靠性与一致性**: 保证活动状态的准确流转，以及优惠券、促销等权益在交易过程中的正确应用和核销，确保数据一致性。
- **可观测性与可分析性**: 提供活动参与数据、转化效果等关键指标的统计和分析，支持活动效果评估和优化。
- **可扩展性**: 易于扩展新的活动类型、促销规则和奖励机制。
- **安全性与防刷**: 防止恶意用户利用活动漏洞进行刷单、套利等行为。

## 二、模块概述

本模块负责平台内各类营销活动的全生命周期管理。主要功能包括：活动定义与配置、优惠券模板创建与管理、优惠券的发放与核销、多样化促销规则的实现、活动参与资格校验、活动库存与预算控制、活动状态的自动流转（如定时上下线）、以及活动效果的数据追踪与分析。它旨在为运营团队提供强大的营销工具，驱动业务增长。

## 三、核心概念

- **营销活动 (Activity/Campaign)**: 一项有特定目标、规则、时间范围和目标用户的营销计划。例如："双十一全场满200减20活动"、"新用户注册送20元无门槛优惠券活动"。
- **活动类型 (Activity Type)**: 活动的具体形式，如优惠券活动、折扣活动、满减活动、秒杀、拼团、积分活动、抽奖等。
- **优惠券 (Coupon)**: 一种给予用户在购买商品或服务时减免金额或获得其他权益的凭证。
    - **优惠券模板 (Coupon Template)**: 定义了一类优惠券的规则，如面额、使用门槛、有效期、适用商品/分类、发放总量等。
    - **用户优惠券 (User Coupon)**: 用户实际领取或获得的优惠券实例，有其独立的生命周期（未使用、已使用、已过期）。
- **促销规则 (Promotion Rule)**: 定义了优惠如何生效的逻辑。例如：
    - *订单级促销*: 满X元减Y元、订单满X件打Z折、整单包邮。
    - *商品级促销*: 特定商品打折、买N免M、第二件半价。
- **参与条件/资格 (Participation Condition/Eligibility)**: 用户参与活动或使用优惠所需满足的条件，如用户等级、用户标签、首次购买、指定渠道来源等。
- **奖励/权益 (Reward/Benefit)**: 用户参与活动或使用优惠后获得的具体好处，如价格减免、赠品、积分、免运费等。
- **活动预算与库存 (Budget & Stock)**: 活动的总成本预算、优惠券总发放量、秒杀/特价商品的总库存限制。
- **活动生命周期 (Activity Lifecycle)**: 活动从创建到结束的各个状态，如草稿、待开始、进行中、已暂停、已结束、已归档。
- **核销 (Redemption/Write-off)**: 用户使用优惠券或享受促销优惠的过程，通常在订单支付环节完成。

## 四、核心数据实体/模型

1.  **活动定义 (ActivityDefinition)**
    *   `activity_id` (主键): 活动的唯一标识符。
    *   `name` (字符串, 必填): 活动名称。
    *   `activity_type` (枚举, 必填): 活动类型 (e.g., COUPON_CAMPAIGN, DISCOUNT_SALE, FLASH_SALE, GROUP_BUY)。
    *   `description` (文本, 可选): 活动详细描述。
    *   `start_time` (时间戳, 必填): 活动开始时间。
    *   `end_time` (时间戳, 必填): 活动结束时间。
    *   `status` (枚举: DRAFT, PENDING_START, ACTIVE, PAUSED, ENDED, ARCHIVED): 活动状态。
    *   `target_audience_rules` (JSON, 可选): 目标用户规则 (如用户等级、标签、注册时间段)。
    *   `participation_rules` (JSON, 可选): 参与次数限制、频率限制等。
    *   `budget_total` (十进制, 可选): 活动总预算。
    *   `budget_used` (十进制, 可选): 已使用预算。
    *   `created_by` (外键, 可选): 创建人ID。
    *   `created_at`, `updated_at` (时间戳)。
    *   `activity_specific_config` (JSON, 可选): 存储特定活动类型所需的额外配置 (如秒杀商品ID与价格、拼团人数等)。

2.  **优惠券模板 (CouponTemplate)**
    *   `template_id` (主键): 优惠券模板的唯一标识符。
    *   `activity_id` (外键, 可选): 关联的营销活动ID（如果此模板专属于某活动）。
    *   `name` (字符串, 必填): 优惠券名称 (如 "20元满199减免券")。
    *   `coupon_type` (枚举: CASH_VOUCHER, DISCOUNT_PERCENT, FREE_SHIPPING, GIFT_COUPON): 优惠券类型。
    *   `value` (十进制, 条件必填): 面额（如20元）或折扣率（如0.8代表8折）。
    *   `minimum_spend` (十进制, 可选, 默认0): 最低消费门槛。
    *   `validity_type` (枚举: FIXED_DATE_RANGE, DYNAMIC_DAYS_FROM_ISSUE): 有效期类型。
    *   `valid_from` (时间戳, 条件必填): 固定有效期开始时间。
    *   `valid_to` (时间戳, 条件必填): 固定有效期结束时间。
    *   `days_valid_after_issue` (整数, 条件必填): 领取后有效天数。
    *   `total_quantity` (整数, 可选): 发放总量上限。
    *   `issued_quantity` (整数, 默认0): 已发放数量。
    *   `per_user_limit` (整数, 可选, 默认1): 每用户可领取/使用上限。
    *   `applicable_scope_rules` (JSON, 可选): 适用范围规则 (如指定商品ID、分类、品牌，或排除某些商品)。
    *   `status` (枚举: ACTIVE, INACTIVE, EXPIRED_GENERATION): 模板状态。
    *   `created_at`, `updated_at` (时间戳)。

3.  **用户优惠券 (UserCoupon)**
    *   `user_coupon_id` (主键): 用户优惠券的唯一实例ID。
    *   `user_id` (外键, 必填): 所属用户ID。
    *   `template_id` (外键, 必填): 关联的优惠券模板ID。
    *   `coupon_code` (字符串, 可选, 唯一): (如果需要) 优惠券码。
    *   `status` (枚举: UNUSED, USED, EXPIRED, LOCKED): 优惠券状态。
    *   `issued_at` (时间戳): 发放/领取时间。
    *   `valid_from` (时间戳, 必填): 此券的生效时间 (根据模板计算得出)。
    *   `valid_to` (时间戳, 必填): 此券的失效时间 (根据模板计算得出)。
    *   `used_at` (时间戳, 可选): 使用时间。
    *   `used_order_id` (外键, 可选): 使用该券的订单ID。

4.  **促销规则配置 (PromotionRuleConfig)** (可作为活动定义的一部分或独立实体)
    *   `rule_id` (主键)。
    *   `activity_id` (外键)。
    *   `rule_type` (枚举: ORDER_FIXED_DISCOUNT, ORDER_PERCENT_DISCOUNT, ITEM_SPECIFIC_PRICE, BUY_N_GET_M_FREE)。
    *   `conditions` (JSON): 规则生效条件（如订单总额、商品数量、特定商品）。
    *   `actions` (JSON): 规则匹配后执行的动作（如减免金额、打折、赠送商品）。

5.  **活动参与日志 (ActivityParticipationLog)**
    *   `log_id` (主键)。
    *   `activity_id` (外键)。
    *   `user_id` (外键)。
    *   `participation_time` (时间戳)。
    *   `result` (JSON, 可选): 参与结果（如秒杀成功、拼团状态）。

## 五、功能模块划分

1.  **活动管理模块**
    *   营销活动的创建、配置、编辑、复制、上下线（手动或定时）。
    *   活动状态管理和生命周期控制。
    *   活动目标用户群组的定义和管理。
2.  **优惠券管理模块**
    *   优惠券模板的CRUD操作。
    *   优惠券的生成、发放（主动推送、用户领取、活动触发等）。
    *   用户优惠券列表查询、状态管理（未使用、已使用、已过期）。
    *   优惠券核销逻辑（与订单模块集成）。
    *   优惠券使用条件校验。
3.  **促销规则引擎/应用模块**
    *   定义和管理各类促销规则（满减、折扣、买赠、包邮等）。
    *   在购物车或订单提交流程中，根据当前商品和用户信息，匹配并应用适用的促销规则。
    *   处理多种促销规则叠加或互斥的逻辑。
4.  **活动参与与资格校验模块**
    *   校验用户是否有资格参与特定活动（基于目标用户规则、参与次数限制等）。
    *   处理用户参与活动的请求（如领券、报名参加秒杀）。
5.  **库存与预算控制模块**
    *   活动（如秒杀商品、优惠券）的库存/发放量控制和实时扣减。
    *   活动预算的监控和超限预警/控制。
6.  **定时任务与状态流转模块**
    *   活动定时开始、定时结束。
    *   优惠券定时生效、定时过期检查。
    *   (可选) 周期性活动（如每日签到）的重置。
7.  **数据统计与效果分析模块**
    *   统计活动参与人数、转化率、优惠券使用率、活动带来的订单量/销售额等。
    *   提供API供数据分析或BI工具使用。

## 六、API接口设计指导原则

- **资源**: `activities`, `coupon-templates`, `users/{userId}/coupons`, `promotions/rules`。
- **活动管理API**: (示例)
    - `POST /activities`: 创建新活动。
    - `GET /activities`: 获取活动列表 (可按类型、状态、时间范围筛选)。
    - `GET /activities/{activity_id}`: 获取活动详情。
    - `PUT /activities/{activity_id}`: 更新活动信息。
    - `POST /activities/{activity_id}/publish`: 上线活动。
    - `POST /activities/{activity_id}/pause`: 暂停活动。
    - `POST /activities/{activity_id}/end`: 结束活动。
- **优惠券模板API**: (示例)
    - `POST /coupon-templates`: 创建优惠券模板。
    - `GET /coupon-templates`: 获取模板列表。
    - `GET /coupon-templates/{template_id}`: 获取模板详情。
- **用户优惠券API**: (示例)
    - `POST /users/{user_id}/coupons/issue`: (后台接口) 为用户发放指定模板的优惠券。
    - `POST /users/{user_id}/coupons/claim`: (用户接口) 用户主动领取优惠券（基于活动或公开券码）。
    - `GET /users/{user_id}/coupons`: 获取用户的优惠券列表 (可按状态筛选)。
    - `GET /users/{user_id}/coupons/{user_coupon_id}`: 获取用户单张优惠券详情。
    - `POST /orders/calculate-promotions`: (购物车/订单环节调用) 传入订单信息，返回适用的优惠和最终价格。
- **通用原则**: RESTful, JSON, 标准状态码，统一错误响应，认证授权，审计日志。

## 七、主要业务流程示例

### 1. 创建并发布一个"新用户专享10元无门槛优惠券"活动
    1.  **创建优惠券模板**: 运营人员通过API创建优惠券模板：名称="新用户10元券", 类型=CASH_VOUCHER, 面额=10, 最低消费=0, 发放总量=10000, 每人限领=1, 有效期类型=DYNAMIC_DAYS_FROM_ISSUE, 有效天数=7, 适用范围=全场通用, 目标用户=新用户。
    2.  **创建营销活动**: 运营人员创建活动：名称="新用户见面礼", 类型=COUPON_CAMPAIGN, 开始/结束时间, 关联上述优惠券模板, 目标用户规则配置为"注册时间在7天内且未领取过此券的用户"。
    3.  **发布活动**: 活动状态置为"ACTIVE"。
    4.  **用户触发**: 用户注册成功后，系统检查其是否符合活动目标人群。若符合，则自动为其发放一张该模板的优惠券到其账户 (`UserCoupon`表新增记录)。

### 2. 用户在下单时使用优惠券
    1.  用户在购物车页面或结算页面。系统展示用户可用的优惠券列表。
    2.  用户选择一张优惠券。
    3.  前端将选中的`user_coupon_id`和订单商品信息提交给后端订单服务或促销计算服务。
    4.  后端服务：
        a.  校验`user_coupon_id`的有效性（是否存在、是否属于该用户、是否未使用、是否在有效期内）。
        b.  校验该优惠券是否适用于当前订单中的商品/分类（基于`CouponTemplate`的`applicable_scope_rules`）。
        c.  校验是否满足使用门槛（基于`CouponTemplate`的`minimum_spend`）。
        d.  如果都满足，则计算优惠金额，更新订单总价。
        e.  (可选) 临时锁定该优惠券，防止并发使用。
    5.  用户确认支付后，订单服务在创建订单时，记录所使用的`user_coupon_id`，并将该`UserCoupon`状态更新为`USED`，记录`used_at`和`used_order_id`。

### 3. 商品秒杀活动流程
    1.  **创建秒杀活动**: 运营配置秒杀活动：选择特定商品SKU、设定秒杀价格、秒杀库存量、活动开始/结束时间、用户参与资格（如每人限购1件）。
    2.  **活动开始前**: 前端展示活动预告，用户可订阅提醒。
    3.  **活动开始**: 用户涌入抢购。
        a.  后端接口接收抢购请求，包含用户ID、秒杀活动ID、商品SKU ID。
        b.  **资格校验**: 检查用户是否已抢购过、是否符合其他参与条件。
        c.  **库存校验与扣减 (高并发点)**:
            i.  快速读取秒杀专用库存 (可使用Redis等缓存)。
            ii. 若库存 > 0，则尝试原子性扣减库存 (如Redis `DECR`或Lua脚本)。
            iii.若扣减成功，则认为抢购成功，生成一个唯一的抢购凭证或直接引导用户下单。
            iv. 若库存不足或扣减失败，则返回抢购失败。
        d.  **限流与防刷**: 对接口进行限流，防止系统过载。识别和拦截机器人刷单行为。
    4.  **下单转化**: 抢购成功的用户需在规定时间内凭抢购凭证完成订单支付，否则名额释放。
    5.  **活动结束**: 定时任务将活动状态置为"ENDED"。

## 八、技术考量与开发注意事项

1.  **规则引擎设计**: 对于复杂的促销规则组合（如叠加、互斥、最优选择），可能需要设计或引入轻量级规则引擎。
2.  **高并发处理**: 秒杀、大规模领券等场景对系统并发能力要求极高。
    *   **库存扣减**: 采用Redis等内存数据库配合Lua脚本实现原子性操作，或使用分布式锁，防止超卖。
    *   **请求队列**: 对抢购请求进行排队处理，削峰填谷。
    *   **前端限流与校验**: 前端配合进行部分校验和限流，减轻后端压力。
    *   **数据最终一致性**: 考虑极端情况下的数据同步问题。
3.  **事务管理与数据一致性**: 领券、用券、活动库存扣减等操作需保证事务性。特别是涉及多个服务（如订单、库存、用户）的分布式事务，需要谨慎设计（如采用Saga、TCC或最终一致性方案）。
4.  **定时任务的可靠性与精度**: 活动的自动上下线、优惠券的自动过期等依赖定时任务。需确保定时任务框架的稳定可靠，以及任务执行的准时性。考虑分布式定时任务的选型和配置。
5.  **可扩展性**: 模块设计应易于添加新的活动类型、优惠券类型和促销规则，例如通过策略模式或插件化设计。
6.  **与核心业务模块的紧密集成**: 营销活动模块与产品、用户、订单、支付等模块高度耦合。接口设计和数据交互需清晰高效。
7.  **用户体验**: 优惠信息展示清晰，领取和使用流程便捷。避免复杂的规则让用户困惑。
8.  **性能优化**: 优惠券列表查询、促销规则匹配等操作需要优化性能，避免影响用户交易流程。合理使用缓存。
9.  **活动效果追踪**: 埋点记录用户在活动中的关键行为，以便分析活动效果。

## 九、数据校验与错误处理

1.  **活动配置校验**: 如活动时间设置是否合理、关联商品是否存在、优惠力度是否在允许范围内。
2.  **用户参与资格校验**: 严格校验用户是否满足活动的所有条件。
3.  **优惠券使用条件校验**: 在用户使用优惠券时，再次校验其适用范围、门槛、有效期等。
4.  **库存/预算校验**: 实时检查活动库存或预算是否充足。
5.  **并发冲突处理**: 如多人同时领取最后一张优惠券或抢购最后一件商品，系统应能正确处理冲突，保证只有一个成功。
6.  **错误信息友好提示**: 向用户或运营人员返回清晰明确的错误信息。

## 十、安全性与防刷考量

1.  **防恶意刷券/刷单**: 
    *   设置合理的领取限制（IP、设备、用户每日/总计）。
    *   对异常行为进行监控和识别（如短时间大量相似请求）。
    *   引入验证码、滑块验证等机制增加机器人操作难度。
    *   风控系统介入，对高风险用户或订单进行拦截或审核。
2.  **接口安全**: 保护活动配置、优惠券发放等关键接口不被未授权访问。
3.  **防止条件绕过**: 确保所有参与条件和使用限制在后端都得到严格校验，不能仅依赖前端。
4.  **优惠金额计算安全**: 防止通过篡改请求参数等方式获得不当优惠。
5.  **数据篡改防护**: 保护活动配置、优惠券数据不被非法修改。
6.  **操作审计**: 对重要的营销活动配置变更、优惠券发放等操作记录审计日志。

---
> 本文档为营销活动模块后端开发提供通用设计指南，具体实现需结合业务特性和技术栈进行细化。 

---

## 文件 40: 后端-用户管理-后端开发文档.md

*文件大小：10.20 KB*

---

### 用户管理模块后端开发文档

#### 模块概述

负责平台用户（管理员、运营、普通用户等）相关的管理功能，包括用户信息的增删改查、角色分配与管理等。本模块是认证授权模块的基础数据支撑之一。

#### 后端技术栈

- 主要技术：Spring Boot, MyBatis-Plus
- 数据库：MySQL
- 缓存：Redis (用于缓存用户常用信息、权限等)
- 安全：Spring Security, JWT (与认证授权模块协作)

#### 核心实体与数据表

本模块主要操作认证授权模块中定义的用户、角色、权限及关联表。

- 用户表 (`kr_user`)
- 角色表 (`kr_role`)
- 权限表 (`kr_permission`)
- 用户角色关联表 (`kr_user_role`)
- 角色权限关联表 (`kr_role_permission`)

详细字段定义请参考 **`../../2、架构/数据库设计.md`** 和 **`./认证授权模块开发文档.md`** 中的数据库设计部分。

#### 主要API接口 (`/api/v1/users`)

所有接口遵循 **`./前后端接口约定.md`** 定义的 RESTful 规范、请求响应格式、错误处理和认证授权机制。

##### 1. 获取用户列表

- **URL:** `/api/v1/users`
- **HTTP方法:** `GET`
- **说明:** 分页查询用户列表，支持按条件过滤和排序。
- **权限:** `user:list` 或 `user:view` (根据具体权限粒度定义)
- **请求参数 (Query Parameters):**

| 参数名      | 类型     | 是否必需 | 说明                     | 示例            |
|-------------|----------|----------|--------------------------|-----------------|
| page        | integer  | 否       | 页码，从1开始 (默认: 1)    | 1               |
| size        | integer  | 否       | 每页条数 (默认: 10)      | 10              |
| username    | string   | 否       | 用户名模糊搜索           | admin           |
| realName    | string   | 否       | 真实姓名模糊搜索         | 张三            |
| phone       | string   | 否       | 手机号精确搜索           | 13800138000     |
| status      | integer  | 否       | 用户状态 (0:禁用, 1:启用) | 1               |
| sort        | string   | 否       | 排序字段 (如: createTime)| createTime      |
| order       | string   | 否       | 排序方向 (asc/desc)      | desc            |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "records": [
    {
      "id": 1,
      "username": "admin",
      "realName": "系统管理员",
      "phone": "13811112222",
      "email": "admin@example.com",
      "avatar": "...",
      "status": 1,
      "createTime": "2023-01-01T10:00:00Z",
      "updateTime": "2023-01-01T10:00:00Z"
      // 可能包含角色列表等信息，具体根据需求定义
    }
    // ... 更多用户记录
  ],
  "total": 100,
  "size": 10,
  "current": 1,
  "pages": 10
}
```
- **可能返回状态码:** 200, 400, 401, 403, 422, 500

##### 2. 获取用户详情

- **URL:** `/api/v1/users/{id}`
- **HTTP方法:** `GET`
- **说明:** 根据用户ID获取用户详细信息，包括关联的角色和权限。
- **权限:** `user:view`
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明     | 示例 |
|--------|--------|----------|----------|------|
| id     | integer | 是       | 用户ID   | 1     |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "id": 1,
  "username": "admin",
  "realName": "系统管理员",
  "phone": "13811112222",
  "email": "admin@example.com",
  "avatar": "...",
  "status": 1,
  "createTime": "2023-01-01T10:00:00Z",
  "updateTime": "2023-01-01T10:00:00Z",
  "roles": [
    {"id": 1, "roleName": "管理员", "roleKey": "ADMIN"},
    {"id": 2, "roleName": "运营", "roleKey": "OPERATOR"}
  ],
  "permissions": [
      "user:list", "user:view", "user:create", "user:edit", "user:delete", "role:assign" // 示例权限列表
  ]
}
```
- **可能返回状态码:** 200, 401, 403, 404, 500

##### 3. 创建新用户

- **URL:** `/api/v1/users`
- **HTTP方法:** `POST`
- **说明:** 创建新的平台用户。
- **权限:** `user:create`
- **请求体 (Request Body):**

```json
{
  "username": "newuser",
  "password": "initialPassword123", // 后端接收后进行加密存储
  "realName": "新用户",
  "phone": "13900001111",
  "email": "newuser@example.com",
  "status": 1 // 默认启用
  // 可以在创建时指定角色ID列表
  // "roleIds": [2, 3]
}
```
- **响应数据 (统一格式 `data` 字段):**

```json
{
  "id": 2, // 返回新创建用户的ID
  "username": "newuser"
  // 可能返回其他少量信息
}
```
- **可能返回状态码:** 201, 400, 401, 403, 422, 409 (用户名/手机号/邮箱重复), 500

##### 4. 更新用户信息

- **URL:** `/api/v1/users/{id}`
- **HTTP方法:** `PUT` (全量更新) 或 `PATCH` (部分更新，建议使用 PATCH 更灵活)
- **说明:** 更新指定ID的用户信息。
- **权限:** `user:edit`
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明     | 示例 |
|--------|--------|----------|----------|------|
| id     | integer | 是       | 用户ID   | 1     |

- **请求体 (Request Body):** 包含需要更新的用户字段，与创建用户请求体类似，但不包含ID和敏感字段如密码（应通过单独的修改密码接口）。

```json
{
  "realName": "张三修改",
  "phone": "13899990000",
  "email": "zhangsan_updated@example.com",
  "status": 0 // 更新为禁用状态
}
```
- **响应数据 (统一格式 `data` 字段):** 通常返回更新成功状态，或者更新后的部分关键信息。

```json
{
  "updated": true // 表示更新成功
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 409 (用户名/手机号/邮箱重复), 500

##### 5. 删除用户

- **URL:** `/api/v1/users/{id}`
- **HTTP方法:** `DELETE`
- **说明:** 删除指定ID的用户。考虑逻辑删除而非物理删除。
- **权限:** `user:delete`
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明     | 示例 |
|--------|--------|----------|----------|------|
| id     | integer | 是       | 用户ID   | 1     |

- **响应数据 (统一格式 `data` 字段):**

```json
{
  "deleted": true // 表示删除成功
}
```
- **可能返回状态码:** 204, 401, 403, 404, 500, 400 (如果用户有关联数据无法删除)

##### 6. 分配用户角色

- **URL:** `/api/v1/users/{id}/roles`
- **HTTP方法:** `POST` (或 PUT/PATCH 根据业务语义)
- **说明:** 为指定用户分配或更新角色。
- **权限:** `role:assign` 或 `user:assignRole` (根据具体权限粒度定义)
- **请求参数 (Path Parameters):**

| 参数名 | 类型   | 是否必需 | 说明     | 示例 |
|--------|--------|----------|----------|------|
| id     | integer | 是       | 用户ID   | 1     |

- **请求体 (Request Body):** 包含要分配的角色ID列表。

```json
{
  "roleIds": [1, 2, 3] // 分配的角色ID列表，通常是覆盖用户现有角色
}
```
- **响应数据 (统一格式 `data` 字段):**

```json
{
  "assigned": true // 表示分配成功
}
```
- **可能返回状态码:** 200, 400, 401, 403, 404 (用户或角色不存在), 500

---

#### 开发注意事项和实现要点

1.  **用户密码处理:**
    - 用户密码在接收到后必须使用强加密算法（如 BCrypt）进行散列存储，绝不能明文存储。
    - 在用户更新或创建接口中，不应直接通过普通字段修改密码，应提供单独的"修改密码"接口，且修改密码时需要验证旧密码或通过重置流程。
2.  **权限校验:**
    - 在所有用户相关的敏感操作接口（创建、更新、删除、分配角色等）上，必须使用 `@PreAuthorize` 注解或通过配置 Spring Security 的 intercept-url 来进行权限控制。
    - 权限标识符 (Permission Key) 需与 `./认证授权模块开发文档.md` 中定义的权限体系一致（如 `user:create`, `user:edit`, `user:delete`, `user:view`, `role:assign` 等）。
3.  **数据验证:**
    - 对所有接收到的用户数据进行严格验证，包括但不限于：
        - 用户名、手机号、邮箱格式和唯一性校验。
        - 密码复杂度校验（如果创建或修改密码）。
        - 必填字段校验。
    - 使用 Spring Validation 框架结合注解进行声明式验证。验证失败时，按照 `./前后端接口约定.md` 中的约定返回 422 状态码和详细的错误信息列表。
4.  **日志记录:**
    - 记录所有关键的用户管理操作日志，包括：
        - 用户登录、登出 (在认证模块实现)。
        - 用户创建、更新、删除。
        - 用户角色分配。
        - 记录操作人（用户ID）、操作时间、操作类型、操作对象（用户ID/用户名）以及操作结果。
    - 遵循统一的日志格式规范，使用 ELK 等工具进行日志收集、存储和分析。
5.  **逻辑删除:**
    - 删除用户操作应采用逻辑删除（更新 `deleted` 字段状态），而不是物理删除，以保留数据用于审计和恢复。在查询时，需要过滤掉已逻辑删除的数据。
6.  **与认证授权模块的协作:**
    - 用户创建/更新时，需要确保用户信息与认证授权服务中的用户数据一致性（如果用户服务和认证服务是单独的微服务）。
    - 获取用户详情时，需要能够查询到用户关联的角色和权限信息，这可能需要调用认证授权服务的接口或通过关联表查询。
7.  **事务管理:**
    - 对于创建用户并分配角色等需要操作多个表（`kr_user`, `kr_user_role`）的功能，需要使用 `@Transactional` 注解确保操作的原子性，防止部分操作成功而另一部分失败导致数据不一致。
8.  **接口版本控制:**
    - 当前接口版本为 `/api/v1`。未来若接口发生不兼容变更，需升级版本号并维护旧版本一段过渡期。
9.  **异常处理:**
    - 捕获并处理各种可能发生的异常，如参数校验失败 (`MethodArgumentNotValidException`)、唯一约束冲突 (`DuplicateKeyException`)、资源未找到 (`NotFoundException`)、权限不足 (`AccessDeniedException`) 等。
    - 异常处理程序应返回符合 `./前后端接口约定.md` 中定义的错误响应格式。

---

> 本文档详细说明了存客宝后端用户管理模块的设计与实现要点，开发时请严格遵循上述规范，确保系统功能完善和安全稳定。 

---

## 文件 41: 后端-支付服务-后端开发文档.md

*文件大小：17.28 KB*

---

# 支付服务模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
支付服务模块是任何涉及在线交易的系统的核心金融组件。它负责处理所有与资金收付相关的操作，包括与各种支付网关（如支付宝、微信支付、银行卡支付、PayPal等）的对接、发起支付请求、安全地处理支付回调、执行退款操作、以及记录详细的交易流水以供对账和审计。本模块的稳定、安全和高效运行对平台的商业成功至关重要。

### 1.2 设计目标
- **安全性**: 最高优先级。确保支付过程中的数据传输安全、存储安全、防欺诈、防篡改、防抵赖。符合相关安全标准（如PCI DSS的适用部分）。
- **可靠性与稳定性**: 保证支付服务的高可用性，支付成功率，以及在各种异常情况下的数据一致性。
- **准确性**: 确保金额、手续费、状态等所有金融数据的精确无误。
- **易扩展性**: 方便快捷地集成新的支付渠道和支付方式。
- **易用性 (对内)**: 为其他业务模块提供清晰、简洁、安全的支付和退款接口。
- **可观测性**: 提供全面的支付交易监控、日志、告警和对账支持。
- **合规性**: 满足当地金融法规和支付行业规范。

## 二、模块概述

本模块封装了与外部支付系统交互的所有复杂逻辑，为上层业务（如订单、充值、订阅等）提供统一的支付能力。主要功能包括：管理多种支付渠道的配置，生成支付参数并发起支付，安全地接收和验证支付网关的异步回调通知，处理支付结果，发起和跟踪退款流程，以及记录每一笔支付和退款的详细流水。

## 三、核心概念与架构组件

### 3.1 核心概念
- **支付订单/交易 (Payment Order/Transaction)**: 由业务系统发起的一笔支付请求，关联到具体的业务订单（如商品订单、服务订单）。
- **支付流水号 (Payment Transaction ID)**: 支付服务为每笔支付生成的唯一内部标识。
- **渠道流水号 (Gateway Transaction ID)**: 支付网关返回的该笔支付在其系统中的唯一标识。
- **支付渠道/网关 (Payment Channel/Gateway)**: 提供支付处理服务的第三方机构，如微信支付、支付宝、Stripe、PayPal等。
- **支付方式 (Payment Method)**: 用户实际选择的支付工具，如信用卡、借记卡、支付宝余额、微信零钱、Apple Pay等。
- **预支付 (Pre-payment / Unified Order)**: 向支付网关下单，获取用于调起客户端支付控件的参数（如二维码URL, App支付参数串）。
- **异步回调/通知 (Asynchronous Callback/Notification)**: 支付网关在支付状态发生变化（通常是支付成功或失败）后，通过HTTP请求主动通知商户服务器。
- **同步跳转 (Synchronous Redirect)**: 用户完成支付后，支付网关页面将其浏览器重定向回商户指定的页面。
- **退款订单/交易 (Refund Order/Transaction)**: 由业务系统或运营发起的退款请求。
- **对账 (Reconciliation)**: 将支付服务内部的交易记录与支付网关提供的对账文件进行核对，确保双方数据一致。

### 3.2 关键架构组件考量
- **支付网关适配层 (Gateway Adapter Layer)**: 核心组件。为每种支付渠道实现一个适配器，封装其API调用、签名/验签逻辑、参数转换、错误处理等。使得上层业务逻辑与具体支付渠道解耦。
- **安全组件**: 包括加解密工具、签名生成与验证工具、证书管理等。
- **消息队列 (MQ)**: 广泛用于处理异步回调通知、退款结果通知、触发对账任务等，提高系统的响应速度和可靠性。
- **持久化存储**: 存储支付交易流水、退款记录、支付渠道配置、对账记录等关键数据。通常选用高可靠的关系型数据库。
- **分布式锁 (可选)**: 在处理回调或更新交易状态时，防止并发问题导致数据不一致。
- **配置管理中心**: 集中管理各支付渠道的商户ID、API密钥、证书、回调URL等敏感配置信息。
- **对账引擎**: 负责下载支付渠道对账单，与系统内支付流水进行比对，生成差异报告。
- **风控模块 (可选)**: 集成或自建风险控制服务，对可疑交易进行识别和拦截。

## 四、核心数据实体/模型

1.  **支付交易 (PaymentTransaction)**
    *   `transaction_id` (主键): 支付服务内部唯一交易流水号。
    *   `business_order_id` (字符串, 必填, 索引): 关联的业务订单ID (如商城订单号)。
    *   `business_order_type` (字符串, 可选): 业务订单类型 (如 "GOODS_ORDER", "SUBSCRIPTION_FEE")。
    *   `user_id` (外键, 可选): 支付用户ID。
    *   `payment_channel` (枚举, 必填): 支付渠道 (e.g., ALIPAY, WECHAT_PAY, STRIPE)。
    *   `payment_method` (字符串, 可选): 具体支付方式 (如 "credit_card", "alipay_qr")。
    *   `amount_requested` (十进制, 必填): 请求支付金额。
    *   `amount_paid` (十进制, 可选): 实际支付金额 (可能包含手续费或优惠)。
    *   `currency` (字符串, 必填, e.g., "CNY", "USD")。
    *   `status` (枚举: PENDING_CREATE, PENDING_PAYMENT, PAID_SUCCESS, PAID_FAILED, CLOSED, REFUND_PARTIAL, REFUND_FULL): 支付状态。
    *   `gateway_transaction_id` (字符串, 可选, 索引): 支付网关返回的流水号。
    *   `prepay_info` (JSON/文本, 可选): 预支付信息 (如支付二维码链接、App支付参数)。
    *   `callback_raw_data` (文本, 可选): 支付回调原始数据。
    *   `error_code` (字符串, 可选): 失败时的错误码。
    *   `error_message` (文本, 可选): 失败时的错误描述。
    *   `created_at`, `updated_at`, `paid_at` (时间戳)。

2.  **退款交易 (RefundTransaction)**
    *   `refund_id` (主键): 退款服务内部唯一退款流水号。
    *   `original_transaction_id` (外键, 必填): 关联的原支付交易ID。
    *   `business_refund_id` (字符串, 必填, 索引): 业务系统退款请求ID。
    *   `amount_requested` (十进制, 必填): 请求退款金额。
    *   `amount_refunded` (十进制, 可选): 实际退款金额。
    *   `currency` (字符串, 必填)。
    *   `status` (枚举: PENDING, PROCESSING, SUCCESS, FAILED): 退款状态。
    *   `reason` (文本, 可选): 退款原因。
    *   `gateway_refund_id` (字符串, 可选): 支付网关返回的退款流水号。
    *   `callback_raw_data` (文本, 可选): 退款回调原始数据。
    *   `created_at`, `updated_at`, `refunded_at` (时间戳)。

3.  **支付渠道配置 (PaymentChannelConfig)**
    *   `channel_code` (主键, 枚举): 支付渠道代码。
    *   `merchant_id` (字符串): 商户号。
    *   `app_id` (字符串, 可选): 应用ID。
    *   `api_key_secret` (加密存储): API密钥。
    *   `public_key_platform` (文本, 可选): 支付平台公钥（用于验签）。
    *   `private_key_merchant` (加密存储, 可选): 商户私钥（用于签名）。
    *   `callback_url_payment` (字符串): 支付回调URL。
    *   `callback_url_refund` (字符串, 可选): 退款回调URL。
    *   `is_active` (布尔): 是否启用。

## 五、功能模块划分

1.  **支付核心流程模块**
    *   接收业务方支付请求，创建支付交易记录。
    *   调用相应支付网关适配器，获取预支付信息。
    *   处理支付网关的同步跳转和异步回调通知。
    *   更新支付交易状态，并通知业务方。
2.  **退款核心流程模块**
    *   接收业务方退款请求，创建退款交易记录。
    *   调用相应支付网关适配器，提交退款申请。
    *   处理支付网关的退款结果异步通知。
    *   更新退款交易状态，并通知业务方。
3.  **支付网关适配层**
    *   为每种支付渠道提供统一的接口封装 (发起支付、查询订单、发起退款、验签等)。
    *   处理各渠道特有的参数、签名算法、通讯协议。
4.  **回调处理模块**
    *   提供统一的回调入口点，根据渠道分发给相应处理器。
    *   严格进行签名验证，防止伪造回调。
    *   保证回调处理的幂等性。
    *   使用MQ进行异步解耦和可靠处理。
5.  **交易查询与状态同步模块**
    *   提供查询支付/退款交易状态的接口。
    *   (可选) 定时任务主动向支付网关查询未明确最终状态的交易，进行状态同步（掉单补偿）。
6.  **配置管理模块**
    *   管理各支付渠道的配置信息（商户号、密钥、证书、回调地址等）。
    *   确保配置信息的安全存储和加载。
7.  **对账处理模块**
    *   定时下载支付渠道的对账单。
    *   与系统内支付流水进行匹配和核对。
    *   生成差异报告，辅助人工处理。
8.  **安全与风控模块**
    *   实现或集成签名、验签、加解密工具。
    *   (可选) 与风控系统对接，对高风险交易进行预警或拦截。

## 六、API接口设计指导原则

- **支付API**: (示例)
    - `POST /payments/transactions`: 创建支付交易，请求体包含业务订单ID、金额、支付渠道偏好等。返回预支付信息或重定向URL。
    - `GET /payments/transactions/{transaction_id}`: 查询支付交易详情。
    - `POST /payments/callbacks/{channel_code}`: 供支付网关调用的异步回调接口 (需严格验签和IP白名单)。
- **退款API**: (示例)
    - `POST /refunds/transactions`: 创建退款交易，请求体包含原支付交易ID、退款金额、原因等。
    - `GET /refunds/transactions/{refund_id}`: 查询退款交易详情。
    - `POST /refunds/callbacks/{channel_code}`: (如果渠道支持) 供支付网关调用的退款异步回调接口。
- **通用原则**: 接口设计应简洁明了，参数定义清晰。所有敏感操作需鉴权。返回信息包含明确的状态码和错误提示。

## 七、主要业务流程示例

### 1. 用户扫码支付流程 (以支付宝为例)
    1.  用户在商城选择商品，提交订单，订单服务创建业务订单，状态为"待支付"。
    2.  订单服务调用支付服务的 `POST /payments/transactions`接口，请求创建支付交易，参数包含业务订单ID、金额、渠道(ALIPAY_QR)。
    3.  支付服务：
        a.  创建支付交易记录 `PaymentTransaction`，状态为 `PENDING_CREATE`。
        b.  调用支付宝网关适配器，请求"统一收单下单并支付页面接口"。
        c.  支付宝返回二维码链接。
        d.  支付服务更新 `PaymentTransaction` 状态为 `PENDING_PAYMENT`，并将二维码链接（或预支付信息）返回给订单服务。
    4.  订单服务将二维码展示给用户。
    5.  用户使用支付宝App扫码支付。
    6.  支付宝处理支付，成功后通过HTTP POST异步通知支付服务配置的 `POST /payments/callbacks/alipay` 接口。
    7.  支付服务回调处理模块：
        a.  验证支付宝回调请求的签名和来源IP。
        b.  解析回调参数，获取支付结果（成功）、支付宝交易号、商户订单号（即支付服务内部`transaction_id`）。
        c.  根据 `transaction_id` 查找 `PaymentTransaction` 记录。
        d.  **幂等性检查**：如果该笔交易已是 `PAID_SUCCESS` 状态，则直接返回成功响应给支付宝，不再重复处理。
        e.  更新 `PaymentTransaction` 状态为 `PAID_SUCCESS`，记录支付宝交易号、支付时间等。
        f.  通知订单服务该笔支付已成功（可通过MQ或同步调用）。
        g.  向支付宝返回成功接收回调的响应 (如 "success")。
    8.  订单服务收到支付成功通知，更新业务订单状态为"已支付"，并进行后续发货等处理。

### 2. 发起并处理一笔退款
    1.  用户申请退款，或运营后台发起退款操作。
    2.  业务系统（如订单服务）调用支付服务的 `POST /refunds/transactions` 接口，请求创建退款，参数包含原支付`transaction_id`、退款金额、退款原因等。
    3.  支付服务：
        a.  校验原支付交易状态是否允许退款，退款金额是否合法。
        b.  创建退款交易记录 `RefundTransaction`，状态为 `PENDING`。
        c.  调用原支付渠道（如支付宝）的网关适配器，提交退款申请。
        d.  支付网关接受退款请求，返回处理中或成功/失败的同步响应。
        e.  支付服务根据同步响应更新 `RefundTransaction` 状态为 `PROCESSING` 或最终状态。
    4.  (若渠道有异步退款通知) 支付网关处理完退款后，异步通知支付服务的回调接口。
    5.  支付服务回调处理模块：
        a.  验签并解析退款结果。
        b.  根据退款流水号查找 `RefundTransaction`。
        c.  幂等性检查后，更新 `RefundTransaction` 最终状态（`SUCCESS` 或 `FAILED`）。
        d.  通知业务系统退款结果。

## 八、技术考量与开发注意事项

1.  **安全性是第一要务**: 严格遵守各支付渠道的安全规范。签名、验签、数据加密（特别是API密钥、证书等敏感配置）、防XSS/CSRF、HTTPS传输是标配。考虑敏感数据的加密存储。
2.  **幂等性设计**: 所有外部接口（特别是回调接口、创建支付/退款接口）必须保证幂等性，防止因网络重试或重复请求导致重复扣款或退款。
    *   常用方法：使用唯一的业务请求ID，在处理前检查该ID是否已处理过。
3.  **异步回调处理的可靠性**: 回调接口应设计为轻量级，快速响应支付网关。实际业务处理逻辑应通过消息队列 (MQ) 异步执行，保证即使回调处理失败也能通过MQ重试，不丢失通知。
4.  **交易状态一致性**: 仔细设计交易状态机。对于长时间未收到回调的"中间状态"交易，应有定时任务主动向支付网关查询，进行状态对齐（"掉单"处理）。
5.  **对账机制**: 每日与支付渠道进行对账是必须的，用于发现和处理金额不符、单边账、状态不一致等问题。对账应自动化。
6.  **错误处理与日志**: 详尽记录每一步操作日志、与网关的请求响应报文。错误信息应清晰具体，方便排查问题。定义规范的错误码体系。
7.  **退款流程复杂度**: 退款可能涉及原路退回、退到余额等多种方式。退款可能失败，需有相应处理机制。部分退款、多次退款的逻辑要考虑清楚。
8.  **手续费处理**: 如果涉及手续费，需明确由谁承担、如何计算和记录。
9.  **并发控制**: 在更新余额、扣减库存（如果支付服务也管理虚拟商品库存）等操作时，需考虑高并发场景，使用乐观锁、悲观锁或分布式锁。
10. **配置管理**: 支付渠道的配置（商户号、密钥、证书）非常敏感，需安全存储，并通过配置中心管理，支持动态更新。
11. **监控与告警**: 对支付成功率、失败率、回调处理延迟、对账差异、系统异常等关键指标进行实时监控，并设置告警。
12. **第三方SDK的封装与版本管理**: 谨慎选择和使用支付网关提供的SDK，注意其版本更新和潜在的兼容性问题。最好进行一层封装。
13. **测试**: 支付流程测试复杂，需要模拟支付网关行为的Mock Server或使用支付网关提供的沙箱环境进行充分测试。

## 九、数据校验与错误处理

1.  **请求参数校验**: 对所有入口参数进行严格校验（如金额格式与范围、币种、订单号存在性等）。
2.  **签名与验签**: 所有与支付网关的交互必须进行签名和验签。
3.  **状态校验**: 操作前检查交易的当前状态是否允许执行该操作（如已支付订单不能再发起支付）。
4.  **配置校验**: 检查支付渠道配置是否完整和有效。
5.  **明确的错误码和错误信息**: 定义统一的错误码体系，方便客户端和内部系统理解和处理错误。

## 十、安全性考量 (重点强调)

1.  **传输安全**: 所有涉及支付信息的网络通信必须使用HTTPS/TLS加密。
2.  **数据存储安全**: API密钥、私钥、证书等敏感配置信息必须加密存储，严格控制访问权限。不应明文存储用户完整的银行卡号、CVV码等（如需处理，应符合PCI DSS要求）。
3.  **防API滥用与攻击**: 对外暴露的API接口（如创建支付、回调）需进行速率限制、IP白名单（回调）、防刷等措施。
4.  **防伪造回调**: 严格校验回调请求的签名、来源IP、以及请求参数中的商户ID等信息是否与配置一致。
5.  **防交易篡改**: 关键金额、订单号等信息在生成签名时必须包含在内，防止中间人篡改。
6.  **操作审计**: 对所有敏感操作（如发起支付、退款、修改配置）记录详细审计日志。
7.  **内部权限控制**: 严格控制内部系统和运营人员对支付服务接口和数据的访问权限。
8.  **依赖安全**: 保持第三方SDK和库更新到最新安全版本。

## 十一、合规性与认证 (可选)

-   根据业务所在地和目标市场，可能需要遵守特定的金融法规和数据保护条例（如GDPR, CCPA）。
-   如果处理信用卡信息，可能需要符合支付卡行业数据安全标准 (PCI DSS)。即使通过第三方支付网关处理，也应了解自身的合规责任范围。 

---

## 文件 42: 后端-中台AI知识库功能开发文档.md

*文件大小：17.51 KB*

---

# 存客宝中台 - AI知识库功能后端开发文档\n\n## 1. 模块概述\n\nAI知识库功能旨在构建一个企业内部知识管理平台，支持上传多种类型的文档、图片、网页内容等，并通过AI技术进行智能解析、知识提取、语义搜索和智能问答。后端模块负责知识内容的存储、索引构建、AI模型集成与调用、搜索接口和问答接口的实现。\n\n## 2. API接口设计\n\n### 2.1 上传知识文件/内容\n\n- **接口路径**：`/api/v1/knowledge/upload`\n- **请求方法**：`POST`\n- **接口说明**：接收用户上传的知识文件（如PDF, DOCX, TXT等）、图片或提交的网页链接/文本内容。后端进行预处理、存储，并触发异步的AI解析流程。\n- **权限:** `knowledge:upload`\n- **请求参数 (Request Body):** 使用 multipart/form-data 或 application/json\n\n| 参数名      | 类型           | 是否必需 | 描述           | 示例值 |
|-------------|----------------|----------|----------------|--------|\
| file        | file           | 否       | 上传的文件     | 文件二进制流 |\
| url         | string         | 否       | 网页链接       | \"http://example.com/doc\" |\
| textContent | string         | 否       | 直接提交的文本内容 | \"这是一段文本...\" |\
| contentType | string         | 是       | 内容类型 (FILE, URL, TEXT, IMAGE) | \"FILE\" |\
| folderId    | integer        | 否       | 目标文件夹ID   | 1      |\
| tags        | array<string>  | 否       | 内容标签       | `[\"合同\", \"模板\"]` |\
\n- **响应数据 (统一格式 `data` 字段):** 返回上传/提交成功信息及处理状态。\n\n```json\n{\n  \"knowledgeId\": 8001,\n  \"fileName\": \"示例合同.pdf\", // 或其他标识\n  \"status\": \"PROCESSING\", // UPLOADED, PROCESSING, READY, FAILED\n  \"message\": \"文件已接收，正在进行AI解析\"\n}\n```\n- **可能返回状态码:** 202 (已接受处理), 400, 401, 403, 413 (文件过大), 422, 500\n\n### 2.2 查询知识内容列表\n\n- **接口路径**：`/api/v1/knowledge/list`\n- **请求方法**：`GET`\n- **接口说明**：获取知识库内容列表。支持分页、筛选、按文件夹和标签过滤、按状态过滤。\n- **权限:** `knowledge:view`\n- **请求参数 (Query Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 描述           | 示例值 |
|-----------|--------|----------|----------------|--------|\
| folderId  | integer | 否       | 按文件夹ID过滤 | 1      |\
| tagIds    | array<integer> | 否 | 按标签ID过滤   | `[10, 11]` |\
| status    | string | 否       | 按状态过滤 (UPLOADED, PROCESSING, READY, FAILED) | \"READY\" |\
| keyword   | string | 否       | 按标题或内容关键字搜索 | \"合同\" |\
| page      | integer| 否       | 页码           | 1      |\
| size      | integer| 否       | 每页条数       | 10     |\n\n- **响应数据 (统一格式 `data` 字段):** 返回知识内容列表（支持分页）。\n\n```json\n{\n  \"records\": [\n    {\n      \"knowledgeId\": 8001,\n      \"title\": \"示例合同.pdf\", // 或从内容提取的标题\n      \"contentType\": \"FILE\",\n      \"status\": \"READY\",\n      \"uploadTime\": \"2023-10-26T18:00:00Z\",\n      \"tags\": [\"合同\", \"模板\"]\n    }\n    // ... 更多知识内容\n  ],\n  \"total\": 50,\n  \"size\": 10,\n  \"current\": 1,\n  \"pages\": 5\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n### 2.3 获取知识内容详情\n\n- **接口路径**：`/api/v1/knowledge/{knowledgeId}`\n- **请求方法**：`GET`\n- **接口说明**：获取指定知识内容的详细信息，包括原始内容或解析后的摘要。\n- **权限:** `knowledge:view`\n- **请求参数 (Path Parameters):**\n\n| 参数名      | 类型    | 是否必需 | 说明       | 示例值 |
|-------------|--------|----------|------------|--------|\
| knowledgeId | integer | 是       | 知识内容ID | 8001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回知识内容详情。\n\n```json\n{\n  \"knowledgeId\": 8001,\n  \"title\": \"示例合同.pdf\",\n  \"contentType\": \"FILE\",\n  \"originalUrl\": \"/files/abc.pdf\", // 原始文件或链接\n  \"parsedContent\": \"合同主要内容摘要...\", // AI解析后的摘要或关键信息\n  \"status\": \"READY\",\n  \"uploadTime\": \"2023-10-26T18:00:00Z\",\n  \"tags\": [\"合同\", \"模板\"],\n  \"folderId\": 1,\n  \"parseResult\": { \"sections\": [...] } // 更详细的解析结果\n}\n```\n- **可能返回状态码:** 200, 401, 403, 404 (知识内容不存在), 500\n\n### 2.4 更新知识内容信息（如标签、文件夹）\n\n- **接口路径**：`/api/v1/knowledge/{knowledgeId}`\n- **请求方法**：`PUT`\n- **接口说明**：更新指定知识内容的元信息，如标题、标签、所属文件夹等。\n- **权限:** `knowledge:update`\n- **请求参数 (Path Parameters):**\n\n| 参数名      | 类型    | 是否必需 | 说明       | 示例值 |
|-------------|--------|----------|------------|--------|\
| knowledgeId | integer | 是       | 知识内容ID | 8001   |\n\n- **请求体 (Request Body):**\n\n| 参数名    | 类型           | 是否必需 | 描述       | 示例值 |
|-----------|----------------|----------|------------|--------|\
| title     | string         | 否       | 新标题     | \"更新后的合同文档\" |\
| folderId  | integer        | 否       | 新文件夹ID | 2      |\
| tags      | array<string>  | 否       | 新标签列表 | `[\"协议\"]` |\
\n- **响应数据 (统一格式 `data` 字段):** 返回更新后的知识内容信息。\n\n```json\n{\n  \"knowledgeId\": 8001,\n  \"title\": \"更新后的合同文档\",\n  \"folderId\": 2,\n  \"tags\": [\"协议\"],\n  \"updateTime\": \"2023-10-26T18:15:00Z\"\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 404, 422, 500\n\n### 2.5 删除知识内容\n\n- **接口路径**：`/api/v1/knowledge/{knowledgeId}`\n- **请求方法**：`DELETE`\n- **接口说明**：删除指定知识内容。\n- **权限:** `knowledge:delete`\n- **请求参数 (Path Parameters):**\n\n| 参数名      | 类型    | 是否必需 | 说明       | 示例值 |
|-------------|--------|----------|------------|--------|\
| knowledgeId | integer | 是       | 知识内容ID | 8001   |\n\n- **响应数据 (统一格式 `data` 字段):** 返回成功信息。\n\n```json\n{\n  \"message\": \"知识内容删除成功\"\n}\n```\n- **可能返回状态码:** 200, 401, 403, 404, 500\n\n### 2.6 创建/管理知识文件夹\n\n- **接口路径**：`/api/v1/knowledge/folders`\n- **请求方法**：`POST` (创建), `GET` (列表)\n- **接口说明**：创建新的知识文件夹或获取文件夹列表。\n- **权限:** `knowledge:folder:manage`\n- **请求参数 (POST Request Body):**\n\n| 参数名    | 类型   | 是否必需 | 描述       | 示例值 |
|-----------|--------|----------|------------|--------|\
| folderName| string | 是       | 文件夹名称 | \"公司文档\" |\
| parentId  | integer| 否       | 父文件夹ID | null   |\n\n- **请求参数 (GET Query Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 描述       | 示例值 |
|-----------|--------|----------|------------|--------|\
| parentId  | integer | 否       | 父文件夹ID | null   |\n\n- **响应数据 (统一格式 `data` 字段):**\n    - POST: 返回新创建的文件夹信息\n    ```json\n    {\n      \"folderId\": 1,\n      \"folderName\": \"公司文档\",\n      \"parentId\": null,\n      \"createTime\": \"2023-10-26T18:20:00Z\"\n    }\n    ```\n    - GET: 返回文件夹列表\n    ```json\n    [\n      {\n        \"folderId\": 1,\n        \"folderName\": \"公司文档\",\n        \"parentId\": null,\n        \"itemCount\": 10, // 文件夹内知识内容数量\n        \"subFolderCount\": 2 // 子文件夹数量\n      }\n      // ... 更多文件夹\n    ]\n    ```\n- **可能返回状态码:** 200 (GET), 201 (POST), 400, 401, 403, 404 (父文件夹不存在), 422, 500\n
### 2.7 创建/管理知识标签\n\n- **接口路径**：`/api/v1/knowledge/tags`\n- **请求方法**：`POST` (创建), `GET` (列表)\n- **接口说明**：创建新的知识标签或获取标签列表。\n- **权限:** `knowledge:tag:manage`\n- **请求参数 (POST Request Body):**\n\n| 参数名  | 类型   | 是否必需 | 描述     | 示例值 |
|---------|--------|----------|----------|--------|\
| tagName | string | 是       | 标签名称 | \"财务\" |\
\n- **请求参数 (GET Query Parameters):**\n\n| 参数名    | 类型    | 是否必需 | 描述       | 示例值 |
|-----------|--------|----------|------------|--------|\
| keyword   | string | 否       | 按名称搜索 | \"财\" |\n\n- **响应数据 (统一格式 `data` 字段):**\n    - POST: 返回新创建的标签信息\n    ```json\n    {\n      \"tagId\": 10,\n      \"tagName\": \"财务\",\n      \"createTime\": \"2023-10-26T18:25:00Z\"\n    }\n    ```\n    - GET: 返回标签列表\n    ```json\n    [\n      {\n        \"tagId\": 10,\n        \"tagName\": \"财务\",\n        \"itemCount\": 5 // 关联知识内容数量\n      }\n      // ... 更多标签\n    ]\n    ```\n- **可能返回状态码:** 200 (GET), 201 (POST), 400, 401, 403, 422, 500\n\n### 2.8 智能搜索\n\n- **接口路径**：`/api/v1/knowledge/search`\n- **请求方法**：`POST`\n- **接口说明**：对知识库进行智能搜索，支持关键词、语义匹配。\n- **权限:** `knowledge:search`\n- **请求参数 (Request Body):**\n\n| 参数名  | 类型   | 是否必需 | 描述       | 示例值 |
|---------|--------|----------|------------|--------|\
| query   | string | 是       | 搜索查询   | \"什么是云阿米巴？\" |\
| folderIds| array<integer> | 否 | 在指定文件夹内搜索 | `[1, 2]` |\
| tagIds  | array<integer> | 否 | 过滤特定标签内容 | `[10]` |\
| page    | integer| 否       | 页码       | 1      |\
| size    | integer| 否       | 每页条数   | 10     |\n\n- **响应数据 (统一格式 `data` 字段):** 返回搜索结果列表（相关度排序）。\n\n```json\n{\n  \"records\": [\n    {\n      \"knowledgeId\": 8005,\n      \"title\": \"云阿米巴模式介绍\",\n      \"snippet\": \"...云阿米巴是一种创新的业务模式...\", // 匹配到的内容片段\n      \"score\": 0.95, // 相关度得分\n      \"contentType\": \"ARTICLE\",\n      \"folderName\": \"内部资料\",\n      \"tags\": [\"云阿米巴\", \"管理\"]\n    }\n    // ... 更多结果\n  ],\n  \"total\": 15,\n  \"size\": 10,\n  \"current\": 1,\n  \"pages\": 2\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n### 2.9 智能问答\n\n- **接口路径**：`/api/v1/knowledge/ask`\n- **请求方法**：`POST`\n- **接口说明**：基于知识库内容进行智能问答。\n- **权限:** `knowledge:ask`\n- **请求参数 (Request Body):**\n\n| 参数名   | 类型   | 是否必需 | 描述       | 示例值 |
|----------|--------|----------|------------|--------|\
| question | string | 是       | 用户问题   | \"合同模板在哪里找？\" |\
| folderIds| array<integer> | 否 | 限定在指定文件夹内问答 | `[1]` |\
| tagIds   | array<integer> | 否 | 限定在特定标签内容中问答 | `[10]` |\
\n- **响应数据 (统一格式 `data` 字段):** 返回AI生成的答案及引用的知识来源。\n\n```json\n{\n  \"answer\": \"您可以在 \"公司文档\" 文件夹下的 \"合同\" 标签分类中找到合同模板。\",\n  \"sourceNodes\": [\n    {\n      \"knowledgeId\": 8001,\n      \"title\": \"示例合同.pdf\",\n      \"snippet\": \"...本文件夹包含各类合同模板...\" // 引用片段\n    }\n    // ... 更多引用来源\n  ]\n}\n```\n- **可能返回状态码:** 200, 400, 401, 403, 500\n\n## 3. 数据模型设计\n\n### 3.1 知识内容表 `t_knowledge_content`\n\n存储知识库中的知识内容元信息和处理状态。\n\n| 字段名         | 类型         | 是否必需 | 说明             | 索引        |\n|---------------|--------------|----------|------------------|------------|\
| id            | BIGINT (PK)  | 是       | 主键             |            |\
| user_id       | BIGINT (FK)  | 是       | 上传用户ID       | Index      |\
| title         | VARCHAR(255) | 是       | 内容标题         | Index      |\
| content_type  | VARCHAR(20)  | 是       | 内容类型 (FILE, URL, TEXT, IMAGE) | Index |\
| original_url  | VARCHAR(500) | 否       | 原始文件路径或URL |            |\
| status        | VARCHAR(20)  | 是       | 处理状态 (UPLOADED, PROCESSING, READY, FAILED) | Index |\
| folder_id     | BIGINT (FK)  | 否       | 所属文件夹ID     | Index      |\
| upload_time   | DATETIME     | 是       | 上传时间         |            |\
| process_time  | DATETIME     | 否       | AI处理完成时间   |            |\
| error_message | TEXT         | 否       | 处理失败原因     |            |\
\n### 3.2 知识内容详情/解析表 `t_knowledge_parsed`\n\n存储AI解析后的知识内容细节，用于搜索和问答。\n\n| 字段名         | 类型         | 是否必需 | 说明             | 索引        |\n|---------------|--------------|----------|------------------|------------|\
| id            | BIGINT (PK)  | 是       | 主键             |            |\
| knowledge_id  | BIGINT (FK)  | 是       | 关联的知识内容ID | UNIQUE Index |\
| parsed_content| TEXT         | 否       | AI提取的文本内容或摘要 |            |\
| vector_embedding| BLOB / BYTEA | 否       | 向量嵌入 (用于向量搜索) |            |\
| keywords      | JSON / TEXT  | 否       | 提取的关键词列表 (JSON 数组) |            |\
| sections      | JSON / TEXT  | 否       | 内容分段及结构 (JSON) |            |\
\n### 3.3 知识文件夹表 `t_knowledge_folder`\n\n存储知识库文件夹信息。\n\n| 字段名      | 类型         | 是否必需 | 说明           | 索引        |\n|------------|--------------|----------|----------------|------------|\
| id         | BIGINT (PK)  | 是       | 主键           |            |\
| user_id    | BIGINT (FK)  | 是       | 创建用户ID     | Index      |\
| folder_name| VARCHAR(100) | 是       | 文件夹名称     |            |\
| parent_id  | BIGINT (FK)  | 否       | 父文件夹ID     | Index      |\
| create_time| DATETIME     | 是       | 创建时间       |            |\
| update_time| DATETIME     | 是       | 更新时间       |            |\
\n### 3.4 知识标签表 `t_knowledge_tag`\n\n存储知识标签信息。\n\n| 字段名     | 类型         | 是否必需 | 说明     | 索引        |\n|-----------|--------------|----------|----------|------------|\
| id        | BIGINT (PK)  | 是       | 主键     |            |\
| user_id   | BIGINT (FK)  | 是       | 创建用户ID | Index      |\
| tag_name  | VARCHAR(50)  | 是       | 标签名称 | UNIQUE Index |\
| create_time| DATETIME     | 是       | 创建时间 |            |\
\n### 3.5 知识内容-标签关联表 `t_knowledge_tag_rel`\n\n关联知识内容和标签，实现多对多关系。\n\n| 字段名      | 类型        | 是否必需 | 说明         | 索引        |\n|------------|-------------|----------|--------------|------------|\
| id         | BIGINT (PK) | 是       | 主键         |            |\
| knowledge_id| BIGINT (FK) | 是       | 知识内容ID   | Index      |\
| tag_id     | BIGINT (FK) | 是       | 标签ID       | Index      |\
\n## 4. 异常处理\n\n- `KnowledgeUploadException`: 知识内容上传失败异常\n- `KnowledgeParseException`: AI解析失败异常\n- `KnowledgeNotFoundException`: 知识内容不存在异常\n- `FolderNotFoundException`: 文件夹不存在异常\n- `TagNotFoundException`: 标签不存在异常\n- `KnowledgeSearchException`: 智能搜索异常\n- `KnowledgeAskException`: 智能问答异常\n- `InsufficientPermissionsException`: 权限不足异常\n\n## 5. 开发注意事项和实现要点\n\n1.  **AI 模型集成:**\n    - 集成文本解析、图像识别、向量化等AI能力。可以选择第三方AI服务（如腾讯云、阿里云的NLP/CV服务）或开源模型。\n    - 需要有可靠的AI服务调用接口和错误处理机制。\n2.  **知识存储和索引:**\n    - 存储原始文件和解析后的文本内容。对于向量搜索，需要专门的向量数据库或支持向量索引的数据库（如PostgreSQL + pgvector）。\n    - 构建文本搜索索引（如 Elasticsearch, Solr）和向量索引，提高搜索效率。\n3.  **异步处理:**\n    - 知识内容的上传和AI解析是耗时操作，应采用消息队列和异步任务处理，避免阻塞前端请求。上传成功后立即返回，前端通过轮询或 WebSocket 获取处理状态。\n4.  **搜索和问答逻辑:**\n    - 实现关键词搜索和基于向量相似度的语义搜索。\n    - 实现基于知识库内容的问答系统，将用户问题与知识内容匹配，提取相关信息生成答案。可能需要RAG (Retrieval-Augmented Generation) 架构。\n5.  **权限控制:**\n    - 对知识内容的上传、查看、编辑、删除、文件夹和标签管理、搜索、问答等操作进行权限控制。确保用户只能访问有权限的知识内容。\n6.  **文件安全:**\n    - 上传的文件需要进行安全扫描，防止病毒或恶意内容。\n    - 存储的文件需要有访问控制，防止未经授权的访问。\n7.  **可扩展性:**\n    - 设计易于扩展的架构，方便后续支持更多内容类型、集成更多AI模型或服务。\n8.  **成本控制:**\n    - 调用外部AI服务可能产生费用，需要考虑成本控制和优化。\n9.  **日志记录:**\n    - 记录上传、解析、搜索、问答等关键操作的日志，便于排查问题和监控。\n\n--- 

---

## 文件 43: 后端-自动化任务-后端开发文档.md

*文件大小：12.22 KB*

---

# 自动化任务模块后端开发指南

## 一、引言与目标

### 1.1 模块定位
自动化任务模块是系统中实现业务流程自动化、定时作业和事件驱动行为的核心引擎。它允许用户或系统配置基于特定触发条件（如时间、系统事件、用户行为）的自动化工作流，以执行预定义的动作序列，从而提高运营效率、实现个性化交互和保证系统维护任务的执行。

### 1.2 设计目标
- **灵活性与可配置性**: 支持多样化的触发器、条件判断和动作组合，以适应各种自动化场景。
- **可靠性**: 保证任务按照预定计划准确、可靠地执行，具备失败重试和错误处理机制。
- **高性能与可伸缩性**: 高效处理大量并发任务和复杂规则，系统应能水平扩展以应对负载增长。
- **可观测性**: 提供任务执行状态的实时监控、详细日志和告警功能。
- **易用性**: 提供清晰的接口和管理界面，方便配置和管理自动化规则与任务。
- **安全性**: 确保任务执行过程中的数据安全和权限控制。

## 二、模块概述

本模块负责自动化任务的定义、调度、执行和监控。它使得系统能够根据预设的规则自动响应特定事件或按计划执行操作，例如客户消息触达、营销活动触发、数据同步、报告生成、系统维护等。

## 三、核心概念与架构组件

### 3.1 核心概念
- **自动化规则 (Automation Rule)**: 定义了一个自动化流程的完整逻辑，包括触发条件、判断逻辑和要执行的动作序列。
- **触发器 (Trigger)**: 定义了启动自动化规则的条件。可以是：
    - *时间基准触发器*: 例如，每天特定时间、每周特定日期、Cron表达式定义的周期性任务。
    - *事件基准触发器*: 例如，用户完成注册、订单支付成功、收到新消息、外部系统回调。
    - *条件基准触发器*: 例如，当某个数据指标达到阈值时。
- **条件 (Condition)**: (可选) 在触发器触发后，进一步判断是否应执行后续动作的逻辑表达式。例如，用户标签包含"VIP"且最近登录时间在7天内。
- **动作 (Action)**: 规则被触发且条件满足后，系统执行的具体操作。可以是：
    - *内部动作*: 例如，更新数据库记录、发送内部通知、调用系统内其他服务API。
    - *外部动作*: 例如，发送邮件、发送短信、调用第三方API、推送消息到消息队列。
- **任务 (Task/Job)**: 一个自动化规则在特定时间或事件触发后，被调度执行的实例。
- **执行日志 (Execution Log)**: 记录每个任务的执行历史、状态（成功、失败、进行中）、开始/结束时间、输入/输出及错误信息。

### 3.2 关键架构组件考量
- **任务调度引擎**: 负责管理和执行定时任务（基于时间触发器）。
    - *选型考量*: 持久化、分布式支持、高可用性、错过任务补偿机制 (misfire handling)、丰富的调度策略 (Cron等)、API易用性。常见的有Quartz, Celery Beat, Spring Task Scheduler的分布式扩展等。
- **消息队列 (MQ)**: 用于异步处理事件驱动的任务和解耦动作执行。
    - *选型考量*: 可靠性 (持久化、消息确认机制)、吞吐量、延迟、功能特性 (如延迟消息、死信队列)、集群支持。常见的有RabbitMQ, Kafka, RocketMQ, Pulsar等。
- **规则引擎 (可选)**: 对于复杂的条件判断和动态规则管理，可以引入规则引擎。
    - *选型考量*: 规则表达能力、性能、易用性、与现有系统的集成度。常见的有Drools, Easy Rules等。
- **持久化存储**: 存储自动化规则定义、任务状态、执行日志等。
    - 通常使用关系型数据库或NoSQL数据库，根据数据特性选择。

## 四、核心数据实体/模型

1.  **自动化规则 (AutomationRule)**
    *   `rule_id` (主键): 规则的唯一标识符。
    *   `name` (字符串, 必填): 规则名称。
    *   `description` (文本, 可选): 规则描述。
    *   `trigger_config` (JSON/结构化数据): 触发器配置信息 (如Cron表达式、事件类型、监听的队列等)。
    *   `condition_logic` (JSON/脚本/DSL, 可选): 条件判断逻辑。
    *   `actions_config` (JSON数组/结构化数据): 动作序列配置 (每个动作包含类型、参数等)。
    *   `status` (枚举: enabled, disabled, archived): 规则状态。
    *   `priority` (整数, 可选): 规则执行优先级。
    *   `created_at`, `updated_at` (时间戳)。

2.  **任务执行实例 (TaskExecution)**
    *   `execution_id` (主键): 本次执行的唯一标识符。
    *   `rule_id` (外键):关联的自动化规则ID。
    *   `trigger_event_id` (字符串, 可选): 触发本次执行的事件ID (如果适用)。
    *   `status` (枚举: pending, running, success, failed, retrying, cancelled): 执行状态。
    *   `scheduled_time` (时间戳, 可选): 计划执行时间。
    *   `start_time`, `end_time` (时间戳, 可选): 实际开始和结束时间。
    *   `input_data` (JSON/文本, 可选): 本次执行的输入参数。
    *   `output_data` (JSON/文本, 可选): 本次执行的输出结果。
    *   `error_message` (文本, 可选): 如果失败，记录错误信息。
    *   `retry_count` (整数): 已重试次数。

3.  **动作执行日志 (ActionExecutionLog)** (可选，用于细粒度追踪)
    *   `action_log_id` (主键)。
    *   `execution_id` (外键): 关联的任务执行实例ID。
    *   `action_index` (整数): 动作在规则中的顺序。
    *   `action_type` (字符串): 动作类型。
    *   `status` (枚举: success, failed)。
    *   `start_time`, `end_time` (时间戳)。
    *   `details` (JSON/文本): 动作执行详情。

## 五、功能模块划分

1.  **规则管理模块**
    *   自动化规则的CRUD操作。
    *   规则的启用/禁用/归档。
    *   规则的版本控制 (可选)。
    *   规则的导入/导出 (可选)。
2.  **触发器配置模块**
    *   支持配置不同类型的触发器（时间、事件等）。
    *   事件监听与分发机制。
3.  **条件逻辑模块**
    *   提供配置条件表达式的接口或UI。
    *   与规则引擎集成或实现内部的条件评估逻辑。
4.  **动作配置与执行模块**
    *   支持配置不同类型的动作及其参数。
    *   动作插件化机制，方便扩展新动作类型。
    *   动作的同步/异步执行。
5.  **任务调度与执行模块**
    *   根据规则和触发器创建任务实例。
    *   管理任务队列，控制并发执行。
    *   任务的生命周期管理 (pending -> running -> completed/failed)。
    *   失败任务的重试机制。
6.  **监控与日志模块**
    *   提供任务执行仪表盘，展示整体运行状况。
    *   查询和展示详细的规则执行日志和动作执行日志。
    *   关键指标告警 (如任务失败率、长时间未执行任务等)。

## 六、API接口设计指导原则

- **资源**: `rules` (自动化规则), `executions` (任务执行实例), `logs` (执行日志)。
- **规则管理API**: (示例)
    - `POST /rules`: 创建新规则。
    - `GET /rules`: 获取规则列表 (支持筛选、分页、排序)。
    - `GET /rules/{rule_id}`: 获取特定规则详情。
    - `PUT /rules/{rule_id}`: 更新规则。
    - `DELETE /rules/{rule_id}`: 删除规则。
    - `POST /rules/{rule_id}/enable`: 启用规则。
    - `POST /rules/{rule_id}/disable`: 禁用规则。
    - `POST /rules/{rule_id}/trigger`: (可选) 手动触发某规则进行测试或立即执行。
- **任务执行API**: (示例)
    - `GET /executions`: 获取任务执行历史列表 (支持按规则ID、状态、时间范围筛选)。
    - `GET /executions/{execution_id}`: 获取特定任务执行详情。
    - `POST /executions/{execution_id}/cancel`: (可选) 取消正在执行或待执行的任务。
    - `POST /executions/{execution_id}/retry`: (可选) 手动重试失败的任务。
- **通用原则**: 遵循RESTful风格，使用JSON，标准化HTTP状态码，统一错误响应，支持认证授权，记录审计日志。

## 七、主要业务流程示例

### 1. 创建并启用一个定时自动化规则
    1.  用户通过UI或API提交创建规则的请求，包含名称、Cron表达式触发器、以及一个"发送邮件"的动作配置。
    2.  API接收请求，进行参数校验。
    3.  权限校验通过后，将规则定义持久化到数据库，初始状态为"禁用"。
    4.  用户通过UI或API请求启用该规则。
    5.  API更新规则状态为"启用"。
    6.  任务调度引擎加载此规则，并根据Cron表达式注册一个定时调度任务。

### 2. 事件触发自动化规则执行
    1.  外部系统（如订单系统）产生一个"订单支付成功"事件，并将事件消息发送到指定的消息队列 (MQ) 主题。
    2.  自动化任务模块的事件监听器消费此消息。
    3.  监听器查找是否有自动化规则配置了监听此事件类型的触发器。
    4.  匹配到相应规则后，为该规则创建一个任务执行实例，状态为"待处理"。
    5.  任务执行器从队列中获取此待处理任务。
    6.  (可选) 执行条件判断逻辑。
    7.  条件满足或无条件，则按顺序执行规则中配置的动作（例如：更新CRM客户状态，发送感谢邮件）。
    8.  记录每个动作的执行结果和整个任务的最终状态到执行日志。

## 八、技术考量与开发注意事项

1.  **触发器与动作的可扩展性**: 设计插件式架构，方便添加新的触发器类型和动作类型，无需修改核心逻辑。
2.  **任务执行的并发控制与资源隔离**: 合理配置任务执行线程池大小，避免因个别耗时任务阻塞其他任务。考虑为不同优先级的任务分配不同资源。
3.  **幂等性设计**: 关键动作（如发送通知、修改数据）应设计为幂等的，防止因重试导致重复执行产生副作用。
4.  **任务失败处理**: 定义清晰的重试策略（次数、间隔、指数退避）。对于最终失败的任务，应有通知机制和人工介入处理流程。考虑死信队列处理无法重试的失败任务。
5.  **分布式环境下的任务调度**: 若系统为分布式部署，任务调度器需支持分布式锁或选择具备分布式协调能力的框架，确保任务不被重复调度执行 (如ShedLock)。
6.  **状态管理与一致性**: 确保规则状态、任务状态在分布式环境中的一致性。
7.  **长耗时任务处理**: 对于可能长时间运行的动作，应采用异步执行，并提供查询其进度的能力。避免阻塞调度线程或API请求。
8.  **系统负载与限流**: 监控自动化任务对系统资源的消耗。对高频触发的事件或大量并发任务，考虑限流或错峰执行，防止冲击下游系统。
9.  **配置热加载**: (可选) 支持修改自动化规则配置后，无需重启服务即可生效。
10. **可测试性**: 易于对单个规则、触发器、条件、动作进行单元测试和集成测试。提供手动触发机制方便调试。

## 九、数据校验与错误处理

1.  **输入校验**: 对规则配置（Cron表达式格式、动作参数等）进行严格校验。
2.  **运行时校验**: 任务执行前检查依赖的资源（如模板、外部服务配置）是否可用。
3.  **错误分类与记录**: 清晰区分配置错误、运行时错误、外部依赖错误。日志中记录详细的错误堆栈和上下文信息。
4.  **用户友好提示**: 对于配置错误，向用户提供明确的修正指示。

## 十、安全性考量

1.  **权限控制**: 细化对自动化规则创建、修改、启用/禁用、查看日志的权限。
2.  **输入安全**: 对规则配置中用户可输入的内容（如脚本、模板）进行安全校验或沙箱执行，防止注入攻击。
3.  **动作执行安全**: 动作执行时（尤其是调用外部API或执行系统命令），确保凭证安全管理，遵循最小权限原则。
4.  **敏感数据处理**: 避免在执行日志中记录过多敏感数据。如需记录，应进行脱敏处理。
5.  **防止滥用**: 限制单个用户可创建的规则数量、任务执行频率等，防止恶意消耗系统资源。 

---

## 文件 44: 后端-API获客功能开发文档-修复版.md

*文件大小：10.74 KB*

---

# 外部系统API对接获客模块后端开发指南

## 1. 引言与目标

### 1.1. 模块定位
本模块旨在为外部系统（如合作伙伴、第三方平台、营销自动化工具等）提供一套标准、安全、高效的API接口，用于将潜在客户数据（线索）推送到存客宝系统中。通过此模块，可以实现自动化、程序化的外部数据源接入，丰富和扩展获客渠道。

### 1.2. 设计目标
- **标准化**：提供定义清晰、一致的API接口规范，降低对接难度。
- **安全性**：确保数据传输和接口访问的安全性，防止未授权访问和数据泄露。
- **可靠性**：保证数据接收的稳定性和准确性，具备一定的容错和重试机制。
- **可扩展性**：设计上应考虑未来可能的字段增加、数据格式调整等需求。
- **可监控性**：能够对API调用情况、数据接收情况进行记录和监控。

## 2. 核心概念

- **API密钥 (API Key)**: 用于认证外部系统身份的凭证，通常包含一个`Access Key ID`和`Secret Key`。
- **数据接入点 (Data Ingestion Endpoint)**: 外部系统推送数据的目标API接口。
- **原始数据日志 (Raw Data Log)**: 记录接收到的原始外部数据的日志，用于追溯和问题排查。
- **数据校验 (Data Validation)**: 对接收到的数据进行格式、类型、完整性等方面的校验。
- **数据转换/映射 (Data Transformation/Mapping)**: 将外部系统的数据结构转换为内部系统可识别的客户或线索模型。
- **异步处理 (Asynchronous Processing)**: 对于数据量较大或处理耗时较长的场景，采用异步方式处理，例如通过消息队列。
- **请求签名 (Request Signing)**: 为防止数据篡改和重放攻击，外部系统在调用API时需对请求进行签名。

## 3. 核心数据实体/模型 (Conceptual)

- **`ApiAccessConfiguration` (API访问配置)**
    - `partnerId` (合作伙伴/系统ID)
    - `accessKeyId` (访问密钥ID)
    - `secretKeyHash` (加密存储的密钥)
    - `allowedIpAddresses` (允许的IP白名单，可选)
    - `status` (启用/禁用)
    - `description` (描述)
    - `rateLimit` (频率限制配置，可选)

- **`ExternalRawDataLog` (外部原始数据日志)**
    - `logId` (日志ID)
    - `partnerId` (合作伙伴/系统ID)
    - `receivedTimestamp` (接收时间戳)
    - `requestHeaders` (请求头信息)
    - `requestBody` (原始请求体)
    - `validationStatus` (校验状态：成功/失败)
    - `processingStatus` (处理状态：待处理/处理中/成功/失败)
    - `errorMessage` (错误信息，如果处理失败)

- **（内部）`Lead` / `CustomerProspect` (线索/潜在客户)**
    - (根据实际业务定义的线索字段，如姓名、电话、邮箱、来源、意向产品等)

## 4. 功能模块划分

### 4.1. API密钥管理模块
- **功能**：
    - 创建、查看、更新、禁用API密钥。
    - 安全存储密钥信息。
    - 管理密钥的权限和范围（如果需要）。
- **主要接口 (Conceptual Admin API)**:
    - `POST /admin/api-keys` (创建密钥)
    - `GET /admin/api-keys/{keyId}` (查询密钥详情)
    - `PUT /admin/api-keys/{keyId}` (更新密钥状态或描述)

### 4.2. 数据接收与预处理模块
- **功能**：
    - 提供数据接收的API端点。
    - 验证请求签名和API密钥的有效性。
    - 记录原始请求数据。
    - 对接收的数据进行初步校验（如格式、必填项）。
- **主要接口 (Conceptual Public API)**:
    - `POST /public/v1/leads/ingest` (外部系统推送线索数据接口)

### 4.3. 数据处理与转换模块
- **功能**：
    - 对通过初步校验的数据进行详细业务校验。
    - 将外部数据模型映射到内部线索/客户模型。
    - 执行数据清洗、去重等操作。
    - 将处理后的数据存入业务数据库。
- **内部机制**：
    - 可通过消息队列与数据接收模块解耦，实现异步处理。

### 4.4. 日志与监控模块
- **功能**：
    - 记录API调用日志、数据处理日志、错误日志。
    - 提供监控指标，如API调用频率、成功率、失败率、数据处理延迟等。

## 5. API接口设计指导原则 (Conceptual)

### 5.1. 认证与授权
- **认证方式**：推荐使用基于HMAC（Hash-based Message Authentication Code）的请求签名机制。外部系统使用分配的`Secret Key`对请求的关键部分（如HTTP方法、URI、时间戳、请求体）进行签名，并将签名结果通过请求头传递。
    - 例如，自定义请求头 `X-Signature`。
    - 服务端用同样的`Secret Key`重新计算签名并比对。
- **API Key传递**：`Access Key ID`可通过请求头（如 `X-Access-Key-Id`）或请求参数传递。

### 5.2. 请求与响应
- **数据格式**：推荐使用JSON作为数据交换格式。
- **HTTP方法**：遵循RESTful原则，使用合适的HTTP动词（如`POST`用于创建资源）。
- **版本控制**：在API路径中包含版本号（如 `/v1/`）。
- **响应状态码**：
    - `200 OK` 或 `202 Accepted` (对于异步处理): 请求成功。
    - `400 Bad Request`: 请求参数错误、格式错误、校验失败。
    - `401 Unauthorized`: 认证失败（签名无效、API Key无效）。
    - `403 Forbidden`: 授权失败（API Key无权限）。
    - `429 Too Many Requests`: 超出频率限制。
    - `500 Internal Server Error`: 服务器内部错误。
- **响应体**：
    - 成功时，可返回处理结果或任务ID（对于异步处理）。
    - 失败时，应返回结构化的错误信息，包含错误码、错误描述。
      ```json
      {
        "errorCode": "INVALID_PARAMETER",
        "message": "Field \'email\' is not a valid email address."
      }
      ```

### 5.3. 数据模型 (线索数据示例)
```json
// POST /public/v1/leads/ingest 请求体示例
{
  "externalLeadId": "XYZ-12345", // 外部系统线索ID，用于幂等性或追踪
  "sourceSystem": "PartnerPlatformA",
  "timestamp": "2023-10-27T10:30:00Z",
  "leadData": {
    "name": "张三",
    "phone": "13800138000",
    "email": "zhangsan@example.com",
    "company": "某某公司",
    "city": "厦门",
    "productInterest": ["ProductA", "ServiceB"],
    "notes": "通过市场活动A获取的线索",
    "customFields": {
      "utm_source": "campaign_xyz"
    }
  }
}
```

## 6. 主要业务流程示例

### 6.1. 外部系统推送线索
1. **外部系统**：准备待推送的线索数据。
2. **外部系统**：根据约定的签名算法，使用`Secret Key`对请求内容（或其摘要）进行签名。
3. **外部系统**：构造HTTP POST请求，目标为数据接入点 (e.g., `/public/v1/leads/ingest`)。
    - 请求头中包含 `Access Key ID` 和计算出的签名。
    - 请求体为JSON格式的线索数据。
4. **本模块 (API网关/接入层)**：接收请求。
5. **本模块**：
    - 提取 `Access Key ID`。
    - 根据 `Access Key ID` 查询对应的 `Secret Key`。
    - 验证请求时间戳的有效性（防止重放攻击）。
    - 使用同样的算法重新计算签名，与请求中的签名进行比对。
    - **若签名无效或API Key无效**：返回 `401 Unauthorized`。
6. **本模块 (数据接收与预处理)**：
    - 记录原始请求到 `ExternalRawDataLog`。
    - 对请求体JSON进行基本格式校验和必填项校验。
    - **若校验失败**：更新日志状态，返回 `400 Bad Request` 及错误详情。
7. **本模块**：
    - **同步处理方式**：直接调用数据处理与转换模块。
    - **异步处理方式**：将原始数据（或其引用）发送到消息队列，返回 `202 Accepted` 给外部系统。
8. **本模块 (数据处理与转换，可能异步)**：
    - 从消息队列消费数据（异步时）。
    - 进行详细业务校验、数据清洗、去重、转换。
    - 将数据保存到核心业务系统的线索库。
    - 更新 `ExternalRawDataLog` 中的处理状态和结果。

## 7. 技术考量与开发注意事项

- **幂等性设计**：对于数据创建类接口，需要考虑幂等性。外部系统可能会因为网络问题重试请求。可以通过要求外部系统传递唯一的请求ID或业务ID (`externalLeadId`) 来实现。
- **安全性**：
    - `Secret Key`绝不能在客户端或不安全信道中暴露。
    - 定期审计和更换API密钥。
    - 对输入数据进行严格的清理和验证，防止注入攻击（如SQL注入、XSS）。
    - 考虑对敏感数据在传输和存储时进行加密。
- **日志与监控**：完善的日志记录对于问题排查和审计至关重要。监控API的性能指标和错误率，以便及时发现和处理问题。
- **错误处理**：提供清晰、具体的错误信息给API调用方。
- **文档**：提供详细、准确的API文档给外部开发者，包括认证方式、请求/响应格式、数据模型、错误码等。
- **可测试性**：模块应易于测试，包括单元测试、集成测试和端到端测试。可以提供一个沙箱环境供外部系统测试对接。

## 8. 数据校验与错误处理

### 8.1. 数据校验层级
- **网关/接入层校验**：认证信息校验、签名校验、请求频率限制。
- **基础格式校验**：JSON格式、必填字段、数据类型、长度限制。
- **业务逻辑校验**：枚举值有效性、关联数据存在性、业务规则符合性。

### 8.2. 错误响应规范
- 使用标准的HTTP状态码。
- 响应体中包含 `errorCode` (内部定义的错误码) 和 `message` (可读的错误描述)。
- 可选地包含 `details` 字段，提供更详细的错误信息（例如，哪个字段校验失败及其原因）。

## 9. 安全性考量

- **传输安全**：所有API接口必须使用HTTPS。
- **认证安全**：
    - 签名机制防止请求被篡改。
    - API Key不应硬编码在客户端代码中，应由后端安全管理。
- **访问控制**：
    - IP白名单机制增强安全性。
    - 考虑API Key的权限范围，遵循最小权限原则。
- **数据安全**：
    - 对用户敏感数据（如手机号、邮箱）进行脱敏处理（如果需要在日志或非核心系统中展示）。
    - 防止数据泄露。
- **防攻击**：
    - 输入验证，防止SQL注入、XSS等。
    - 请求频率限制，防止DoS/DDoS攻击。
    - 时间戳校验，防止重放攻击。
- **审计**：记录所有API调用和关键操作，便于安全审计。

## 10. 演进与扩展

- **版本迭代**：通过API版本号管理接口的演进，确保向后兼容性。
- **数据格式扩展**：设计时考虑未来可能增加的字段，例如使用 `customFields` 结构允许外部系统传递自定义数据。
- **回调机制/Webhook**：对于长时间处理的异步任务，可以考虑引入Webhook机制，当数据处理完成后主动通知外部系统。 

---

## 文件 45: 架构-架构-技术选型.MD

*文件大小：2.98 KB*

---

# 存客宝技术选型文档

## 一、前端技术选型
- **Next.js 15 + React 18**：支持服务端渲染（SSR）、静态生成（SSG）、高性能、SEO友好，适合中大型管理平台。
- **Shadcn UI + Tailwind CSS**：快速开发高颜值、响应式、可定制的前端界面，提升开发效率和用户体验。
- **TypeScript**：类型安全，提升代码可维护性和团队协作效率。
- **Vant（移动端补充）**：部分移动端场景采用 Vant 组件库，兼容主流浏览器和移动端。
- **Chart.js/Echarts**：数据可视化，支持多种图表类型，满足运营看板需求。

## 二、后端技术选型
- **Java + Spring Boot**：主力后端开发框架，成熟稳定，生态完善，适合微服务架构。
- **FastAPI（Python）**：AI服务、数据处理等场景，接口开发高效，易于与AI模型集成。
- **微服务架构**：各业务模块独立部署，支持高并发、易扩展、易维护。
- **OpenAPI/Swagger**：接口文档自动生成，便于前后端联调和第三方集成。

## 三、数据库与数据仓库
- **MySQL**：关系型数据库，存储核心业务数据（客户、线索、内容、设备等）。
- **HBase/Hive**：大数据仓库，支持用户画像、标签体系、行为数据的高效存储与分析。
- **Redis**：缓存与高频数据存储，提升系统响应速度。

## 四、AI与数据智能
- **AI模型服务**：基于 FastAPI 部署，支持线索过滤、内容改写、用户画像补全等。
- **NLP/机器学习**：用于内容理解、标签预测、客户意向度分析等。
- **数据标签体系**：支持规则标签、统计标签、预测标签，助力精细化运营。

## 五、消息队列与任务调度
- **Kafka/RabbitMQ**：异步消息队列，支持事件驱动、解耦业务模块。
- **Quartz/Spring Task**：定时任务调度，支持自动化流程编排。

## 六、接口与集成
- **RESTful API**：统一接口风格，便于前后端分离和第三方系统集成。
- **第三方平台对接**：支持微信、抖音、小红书、公众号等平台API对接。
- **企业内部系统集成**：支持与CRM、ERP等系统的数据同步。

## 七、运维与安全
- **Docker + Kubernetes**：容器化部署，支持弹性伸缩、自动化运维。
- **CI/CD（Jenkins/GitHub Actions）**：自动化测试、持续集成与交付。
- **Prometheus + Grafana**：系统监控与告警，保障平台稳定运行。
- **ELK（Elasticsearch + Logstash + Kibana）**：日志收集、分析与可视化。
- **全链路加密与权限控制**：保障数据安全，满足企业合规要求。

## 八、可扩展性与未来规划
- 支持多租户、分布式部署，便于业务扩展和多业务线运营。
- 预留AI能力扩展接口，支持新模型、新算法的快速集成。
- 支持多云/混合云部署，适应不同企业IT环境。

---

> 本文档为存客宝项目技术选型总览，后续如有新技术引入或架构调整请及时补充。



---

## 文件 46: 架构-架构-前后端协作与接口设计规范.md

*文件大小：6.40 KB*

---

# 前后端协作与接口设计规范 (API 优先)

## 1. 核心理念：API 作为前后端的"契约"

在现代 Web 和移动应用开发中，前后端分离已成为主流架构。为了确保高效、顺畅的协作，避免后期集成困难和返工，我们倡导**"API 优先" (API-First) 或"契约先行" (Contract-First)**的设计理念。

这意味着，在前后端团队投入大规模编码之前，首先共同定义和评审一套清晰、稳定、详尽的 API 接口规范。这份规范一旦确立，便成为前后端之间共同遵守的"契约"或"合同"。

**通俗理解：**

- **API 契约**：就像建筑项目的"施工图纸"。在盖房子之前，设计师（API 设计者）、施工队（后端团队）、装修队（前端团队）必须先就图纸达成一致。
- **前端团队**：根据"图纸"了解房屋结构（API 结构），可以开始准备"家具"和"软装"（UI 和交互）。
- **后端团队**：根据"图纸"负责搭建房屋框架和水电煤（API 实现和业务逻辑）。

只要大家都严格遵守这份"图纸"，最终就能顺利地将"家具"搬入"精装房"，而不会出现门太小家具进不去，或者插座位置不对电器没法用的情况。

## 2. "API 优先"带来的价值

- **并行开发，提升效率**：一旦 API 契约确定，前后端团队可以并行独立开发，互不阻塞。前端可以使用 Mock 服务模拟 API 响应，后端则专注于业务逻辑实现。
- **减少集成风险**：由于双方基于同一份"合同"工作，大大降低了后期集成时因接口不匹配、数据结构理解不一致等问题导致的风险和返工成本。
- **职责清晰**：API 契约明确了数据交换的格式、参数、路径等，使得前后端的职责边界更加清晰。
- **更好的 API 设计**：将 API 设计提到项目早期，可以更全面地考虑其可用性、可扩展性、安全性，避免在业务逻辑实现后再去修补 API。
- **促进团队沟通与协作**：共同制定和评审 API 契约的过程本身就是一次重要的团队沟通，有助于对需求的共同理解。
- **可测试性增强**：清晰的 API 规范使得自动化测试（单元测试、集成测试）更容易编写和执行。

## 3. API 契约的核心要素

一份合格的 API 契约应至少包含以下内容：

1.  **HTTP 方法 (HTTP Methods)**：明确每个操作使用的方法（GET, POST, PUT, DELETE, PATCH 等）。
2.  **端点 URL (Endpoints)**：清晰、一致的资源路径命名。
    -   例如：`GET /api/v1/users`, `POST /api/v1/users`, `GET /api/v1/users/{userId}`
3.  **请求参数 (Request Parameters)**：
    -   路径参数 (Path Parameters)：如 `/users/{userId}` 中的 `userId`。
    -   查询参数 (Query Parameters)：如 `/articles?page=1&limit=10`。
    -   请求体 (Request Body)：对于 POST, PUT, PATCH 请求，明确请求体的 JSON 结构、字段名、数据类型、是否必需、校验规则等。
4.  **响应数据 (Response Data)**：
    -   成功响应：明确返回的 JSON 结构、字段名、数据类型。
    -   错误响应：统一错误响应的结构，包含错误码 (code)、错误信息 (message)、可能的详细错误 (details)。
5.  **HTTP 状态码 (HTTP Status Codes)**：正确使用标准 HTTP 状态码来表示操作结果（如 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error）。
6.  **认证与授权 (Authentication & Authorization)**：说明 API 的安全机制，如 Token 类型 (JWT, OAuth2)、Token 如何传递 (Header, Query Param)、权限要求等。
7.  **版本控制 (Versioning)**：明确 API 版本策略（如 URL路径版本 `/api/v1/`, Header 版本）。
8.  **数据格式 (Data Formats)**：通常为 JSON，需明确。
9.  **速率限制 (Rate Limiting)**：(可选) 如果有，需要说明。
10. **分页与排序 (Pagination & Sorting)**：(可选) 对于列表数据，定义统一的分页参数 (如 `page`, `limit` 或 `offset`, `count`) 和排序参数。

## 4. 设计与协作流程建议

1.  **需求分析与初步设计**：产品、前后端负责人共同参与，明确业务需求，初步草拟 API 功能点。
2.  **API 契约详细设计**：
    -   由后端架构师或主要负责人主导，根据核心要素详细设计 API 规范。
    -   使用 API 设计工具（如 OpenAPI/Swagger Editor, Postman Designer, Stoplight）编写规范文档。
3.  **API 评审**：
    -   组织前后端团队、测试团队、产品共同评审 API 设计稿。
    -   确保各方对 API 的理解一致，功能满足需求，设计合理。
4.  **API 文档发布与 Mock 服务生成**：
    -   评审通过后，将 API 规范文档发布到团队共享平台（如 Swagger UI, Confluence）。
    -   基于 API 规范自动生成 Mock Server，供前端团队调用和开发。
5.  **并行开发**：
    -   **前端团队**：基于 API 文档和 Mock 服务进行 UI 和交互开发。
    -   **后端团队**：根据 API 文档实现业务逻辑和数据持久化。
6.  **联调测试**：后端接口开发完成后，前后端进行集成联调。
7.  **持续迭代**：如果需求变更导致 API 修改，必须及时更新 API 文档，并通知所有相关方。

## 5. 推荐工具

- **API 设计与文档化**:
    -   **OpenAPI Specification (formerly Swagger)**: 业界标准，强大的生态系统。
    -   **Swagger Editor/UI**: 编写和展示 OpenAPI 文档。
    -   **Postman**: API 开发、测试、文档、Mock 的综合平台。
    -   **Stoplight Studio**: 可视化的 API 设计工具。
    -   **Apiary, ApiBlueprint**: 其他 API 设计和文档工具。
- **Mock 服务**:
    -   **Swagger Codegen/OpenAPI Generator**: 可根据 OpenAPI 规范生成服务端桩代码和客户端 SDK，也可用于生成简单的 Mock Server。
    -   **Postman Mock Servers**: Postman 内置的 Mock 功能。
    -   **Mockoon, Prism (Stoplight)**: 开源的 Mock 工具。
    -   **Mirage JS, MSW (Mock Service Worker)**: 前端常用的 Mock 库，可在浏览器或 Node.js 环境中拦截请求并返回模拟数据。

## 6. 总结

采用"API 优先"的协作模式，将 API 设计提升到战略高度，是确保复杂项目成功的关键。它不仅仅是一个技术流程，更是一种团队协作文化。通过清晰的契约、有效的工具和规范的流程，可以显著提升开发效率，降低沟通成本，保障产品质量。 

---

## 文件 47: 架构-架构-数据库设计.md

*文件大小：5.15 KB*

---

# 存客宝数据库设计文档

## 一、设计原则
- 满足多渠道获客、客户统一管理、设备联动、内容运营、数据分析等核心业务需求
- 支持分库分表、分布式部署，便于业务扩展和高并发场景
- 数据安全、权限分级、合规可追溯

## 二、核心表结构设计

### 1. 客户表（customer）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| name           | varchar(64)  | 客户姓名           |
| phone          | varchar(32)  | 手机号             |
| wechat         | varchar(64)  | 微信号             |
| source         | varchar(32)  | 来源渠道（电话/抖音/小红书等）|
| scene          | varchar(32)  | 获客场景           |
| tags           | varchar(256) | 标签（逗号分隔）   |
| status         | tinyint      | 状态（0无效/1有效/2黑名单）|
| created_at     | datetime     | 创建时间           |
| updated_at     | datetime     | 更新时间           |

### 2. 线索表（lead）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| customer_id    | bigint       | 客户ID（外键）     |
| phone          | varchar(32)  | 线索手机号         |
| wechat         | varchar(64)  | 线索微信号         |
| name           | varchar(64)  | 线索姓名           |
| source         | varchar(32)  | 来源渠道           |
| scene          | varchar(32)  | 获客场景           |
| assign_to      | bigint       | 分配员工ID         |
| status         | tinyint      | 状态（0无效/1有效/2待复核）|
| tags           | varchar(256) | 标签               |
| created_at     | datetime     | 创建时间           |
| updated_at     | datetime     | 更新时间           |

### 3. 设备表（device）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| name           | varchar(64)  | 设备名称           |
| type           | varchar(32)  | 设备类型（手机/虚拟等）|
| status         | tinyint      | 状态（0离线/1在线）|
| wechat         | varchar(64)  | 绑定微信号         |
| last_active_at | datetime     | 最后活跃时间       |
| created_at     | datetime     | 创建时间           |

### 4. 内容表（content）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| title          | varchar(128) | 内容标题           |
| body           | text         | 内容正文           |
| type           | varchar(32)  | 内容类型（图文/视频等）|
| tags           | varchar(256) | 标签               |
| created_by     | bigint       | 创建人ID           |
| created_at     | datetime     | 创建时间           |
| updated_at     | datetime     | 更新时间           |

### 5. 标签表（tag）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| name           | varchar(64)  | 标签名称           |
| type           | varchar(32)  | 标签类型（规则/统计/预测）|
| created_at     | datetime     | 创建时间           |

### 6. 用户表（user）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| username       | varchar(64)  | 用户名             |
| password       | varchar(128) | 密码（加密存储）   |
| role           | varchar(32)  | 角色（管理员/员工等）|
| status         | tinyint      | 状态（0禁用/1启用）|
| created_at     | datetime     | 创建时间           |

### 7. 操作日志表（operation_log）
| 字段名         | 类型         | 说明               |
| -------------- | ------------ | ------------------ |
| id             | bigint       | 主键，自增         |
| user_id        | bigint       | 操作人ID           |
| action         | varchar(128) | 操作类型           |
| detail         | text         | 操作详情           |
| created_at     | datetime     | 操作时间           |

## 三、主外键关系
- lead.customer_id → customer.id
- content.created_by → user.id
- operation_log.user_id → user.id

## 四、分库分表与扩展性建议
- 大表（如customer、lead）建议按租户/业务线/时间分表，提升查询和写入性能
- 标签、内容等表可按类型或业务线分表
- 支持多租户字段（如tenant_id）扩展，便于SaaS化部署

## 五、数据安全与合规
- 重要字段（如手机号、微信号、密码）加密存储，支持脱敏展示
- 操作日志全链路记录，满足合规与审计要求
- 权限分级，保障数据隔离与安全

---

> 本文档为存客宝项目数据库设计总览，后续如有新业务或扩展请及时补充。 

---

## 文件 48: 架构-架构-系统架构.MD

*文件大小：3.37 KB*

---



# 存客宝系统架构文档

## 一、整体架构概述
存客宝采用分层分布式微服务架构，前后端分离，支持多端接入、弹性扩展和高可用。系统核心由前端展示层、后端服务层、AI智能服务、数据存储层、消息队列、第三方平台集成等组成。

## 二、架构层次结构

### 1. 前端展示层
- **技术栈**：Next.js 15、React 18、Shadcn UI、Tailwind CSS、TypeScript
- **功能**：多端适配（PC/H5）、数据可视化、业务流程操作、权限管理、内容推送等
- **与后端通信**：RESTful API、WebSocket（部分实时场景）

### 2. 后端服务层
- **技术栈**：Java + Spring Boot（主业务）、FastAPI（AI/数据处理）
- **功能**：业务逻辑处理、API网关、权限校验、任务调度、第三方平台对接、日志审计等
- **微服务架构**：各业务模块（客户、线索、设备、内容、标签、用户、统计等）独立部署，支持弹性伸缩

### 3. AI智能服务
- **技术栈**：Python + FastAPI
- **功能**：线索AI过滤、内容AI改写、用户画像补全、标签预测等
- **与主系统通信**：RESTful API/消息队列

### 4. 数据存储层
- **关系型数据库**：MySQL，存储核心业务数据（客户、线索、内容、设备、用户等）
- **大数据仓库**：HBase/Hive，存储用户画像、标签、行为数据等大数据分析需求
- **缓存**：Redis，提升高频数据访问性能

### 5. 消息队列与任务调度
- **Kafka/RabbitMQ**：实现异步解耦、事件驱动、跨服务通信
- **Quartz/Spring Task**：定时任务、自动化流程编排

### 6. 第三方平台集成
- **微信、抖音、小红书、公众号等**：API对接，支持多渠道获客、内容推送、客户同步等
- **企业内部系统**：CRM、ERP等数据同步与集成

### 7. 运维与安全
- **容器化部署**：Docker + Kubernetes，支持弹性伸缩、自动化运维
- **CI/CD**：Jenkins/GitHub Actions，自动化测试与持续交付
- **监控与日志**：Prometheus + Grafana、ELK，系统监控、告警、日志分析
- **安全**：全链路加密、权限分级、数据脱敏、操作审计

## 三、核心模块说明
- **客户与线索管理**：统一存储、标签化、分层、分配、全生命周期管理
- **设备联动与自动加微信**：多设备轮询、加好友、状态监控、结果回传
- **内容库与智能运营**：内容采集、AI改写、多平台推送、矩阵触达
- **AI服务**：线索过滤、内容生成、用户画像、标签预测等
- **数据统计与可视化**：多维度数据分析、可视化看板、报表导出
- **自动化与智能化运营**：线索自动流转、自动分配、自动跟进、自动触达

## 四、数据流转与安全
- 数据从多渠道入口采集，经过AI过滤、业务处理、分配到员工/设备/分组，沉淀到私域客户池
- 全链路数据加密、权限分级、日志审计，保障数据安全与合规
- 支持多租户、分布式部署，便于业务扩展和多业务线运营

## 五、扩展性与高可用
- 微服务架构，支持弹性扩展、故障隔离、灰度发布
- 预留AI能力扩展接口，支持新模型、新算法的快速集成
- 支持多云/混合云部署，适应不同企业IT环境

---

> 本文档为存客宝项目系统架构总览，后续如有新模块或架构调整请及时补充。



---

## 文件 49: 前端-场景获客-电话获客功能.md

*文件大小：2.89 KB*

---

# 场景获客-电话获客功能说明（通俗版）

## 一、功能简介
电话获客就是通过收集客户电话号码，自动加微信、分配给员工、发红包、分销奖励等，帮助企业快速把电话线索变成微信好友，沉淀到私域客户池。整个过程自动化，省时省力。

## 二、主要功能模块

### 1. 电话线索导入
- 支持批量导入（Excel/CSV）和单条录入。
- 可以直接粘贴号码，或上传表格。
- 导入内容：电话、姓名、来源、场景、分销关系、红包奖励等。

### 2. 自动加微信
- 电话打进来，系统自动识别号码。
- 号码会推送到指定设备（如微信手机），自动发起加好友。
- 多台设备轮流加，效率高。
- 加好友结果会实时反馈（成功/失败/待确认）。

### 3. AI 智能过滤
- 系统自动去重、校验号码格式、过滤黑名单。
- 可识别无效或疑似垃圾号码。
- 结果分为：有效、疑似无效、需人工复核。
- 支持一键批量复核。

### 4. 线索分配
- 有效号码自动分配给员工、分组或分销层级。
- 分配规则可自定义（如按来源、场景等）。

### 5. 分销返利与红包
- 线索可绑定分销关系，自动计算返利。
- 支持自动发红包奖励。
- 分销和红包数据实时同步。

### 6. 数据统计
- 实时统计导入、有效、无效、加好友成功、分销返利、红包发放等数据。
- 支持历史记录查询和导出。

### 7. 跟进与转化
- 每条线索可记录跟进情况（如通话、备注、转化状态）。
- 支持自动化任务（如定时提醒、自动分组、自动发红包等）。
- 加微信后可自动推送欢迎语、标签分组等。

---

## 三、前端开发要点
- 用 Shadcn UI + Tailwind CSS 做表单、导入、设备配置、进度展示、分销返利、红包池、跟进记录等页面。
- 设备联动、加微信等通过后端API实现，前端只负责展示进度和结果。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 组件建议拆分：导入表单、设备配置、加微信进度、AI过滤结果、人工复核、分销返利、红包池、统计区块、跟进记录。
- 导入支持 Excel/CSV 文件解析（如用 xlsx.js）。
- 首页入口、数据区块、分销返利、红包池等支持权限控制和自定义显示。

---

## 四、接口说明（前端常用）
- 设备配置：/api/phone/device-config
- 自动加微信：/api/phone/add-wechat
- 加微信结果回传：/api/phone/add-wechat-result
- AI过滤：/api/phone/ai-filter
- 电话导入：/api/phone/import
- 线索分配：/api/phone/assign
- 分销返利：/api/phone/distribution
- 红包池：/api/phone/redpacket
- 跟进记录：/api/phone/followup
- 历史记录：/api/phone/history

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 50: 前端-场景获客-订单获客功能.md

*文件大小：1.70 KB*

---

# 场景获客-订单获客功能说明（通俗版）

## 一、功能简介
订单获客就是把客户的订单信息（如电话、微信号、姓名、场景）导入系统，自动过滤无效订单，分配给员工或分组，方便后续跟进和转化。整个过程自动化，提升效率。

## 二、主要功能模块

### 1. 订单导入
- 支持批量导入（Excel/CSV）和单条录入。
- 可以直接粘贴订单信息，或上传表格。
- 导入内容：电话、微信号、姓名、场景。

### 2. AI 智能过滤
- 系统自动去重、校验号码格式、过滤黑名单。
- 可识别无效或疑似垃圾订单。
- 结果分为：有效、疑似无效、需人工复核。
- 支持一键批量复核。

### 3. 订单分配
- 有效订单自动分配到场景或分组。
- 分配规则可自定义（如按场景、渠道、导入人等）。

### 4. 数据统计
- 实时统计导入、有效、无效、复核等数据。
- 支持历史记录查询和导出。

---

## 三、前端开发要点
- 用 Shadcn UI + Tailwind CSS 做表单、导入、过滤结果、人工复核、统计等页面。
- AI 过滤通过后端API实现，前端只负责展示进度和结果。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 组件建议拆分：导入表单、AI过滤结果、人工复核、统计区块。
- 导入支持 Excel/CSV 文件解析（如用 xlsx.js）。

---

## 四、接口说明（前端常用）
- AI过滤：/api/order/ai-filter
- 订单导入：/api/order/import
- 订单分配：/api/order/assign
- 历史记录：/api/order/history

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 51: 前端-场景获客-抖音获客功能.md

*文件大小：2.64 KB*

---

# 场景获客-抖音获客功能说明（通俗版）

## 一、功能简介
抖音获客就是通过对接抖音平台，把抖音上的客户线索（如私信、评论、表单等）自动采集到系统，分配给员工，自动发分销奖励、红包，数据实时统计，帮助企业高效获取抖音流量并沉淀到私域。

## 二、主要功能模块

### 1. 抖音账号管理
- 支持绑定/解绑多个抖音号。
- 展示账号信息、状态、粉丝数等。
- 支持账号分组、标签、分销层级归属。

### 2. 线索采集与导入
- 自动采集抖音私信、评论、表单等线索。
- 支持手动录入或批量导入（手机号、微信号、昵称、来源视频/直播、分销关系等）。
- 系统自动去重、校验有效性。

### 3. 线索分配与转化
- 线索可自动分配给员工、分组或分销层级。
- 分配规则可自定义（如按来源、时间、标签等）。
- 支持自动推送欢迎语、加微信、分组、分销奖励等。

### 4. 分销返利与红包
- 线索可绑定分销关系，自动计算返利。
- 支持自动发红包奖励。
- 分销和红包数据实时同步。

### 5. 数据统计与分析
- 实时统计抖音获客总量、转化率、各渠道/视频/直播带来的线索数、分销返利、红包发放等。
- 支持多维度筛选（时间、账号、来源、员工、分销层级等）。
- 数据可视化展示（折线图、饼图、柱状图等）。

### 6. 互动与自动化
- 支持自动回复私信、评论，提升互动效率。
- 可配置自动化任务（如定时推送、自动分组、分销奖励、红包发放、AI内容推送等）。

---

## 三、前端开发要点
- 用 Shadcn UI + Tailwind CSS 做账号管理、线索列表、分销返利、红包池、统计报表等页面。
- 抖音授权、数据采集等通过后端API实现，前端只负责展示和交互。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 组件建议拆分：账号管理、线索采集、分配转化、分销返利、红包池、数据统计、自动化配置。
- 数据可视化建议用 Chart.js/Echarts 实现。
- 首页入口、数据区块、分销返利、红包池等支持权限控制和自定义显示。

---

## 四、接口说明（前端常用）
- 抖音账号：/api/douyin/account
- 线索采集：/api/douyin/leads
- 线索分配：/api/douyin/assign
- 分销返利：/api/douyin/distribution
- 红包池：/api/douyin/redpacket
- 数据统计：/api/douyin/stats
- 自动化配置：/api/douyin/automation

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 52: 前端-场景获客-付款码获客功能.md

*文件大小：2.53 KB*

---

# 场景获客-付款码获客功能说明（通俗版）

## 一、功能简介
付款码获客就是通过生成专属收款二维码，用户扫码付款后自动进入私域客户池。支持分销奖励、红包、自动化任务等，扫码付款后可自动触发各种活动，数据实时统计，帮助企业边收款边获客。

## 二、主要功能模块

### 1. 付款码生成与管理
- 支持为不同商品、活动、渠道生成专属收款二维码。
- 可自定义收款金额、用途、备注等。
- 支持批量生成和下载付款码。
- 支持付款码状态管理（启用/停用/作废）。

### 2. 付款与客户自动入库
- 用户扫码付款后，系统自动识别付款信息。
- 付款成功后，自动将用户信息导入客户池。
- 支持自动分配标签、分组、分销层级。
- 可配置付款后自动推送欢迎语、优惠券、分销奖励等。

### 3. 分销返利与红包
- 支持付款码绑定分销关系，自动计算返利。
- 支持自动发放红包奖励。
- 分销和红包数据实时同步。

### 4. 数据统计与追踪
- 实时统计每个付款码的扫码次数、付款金额、转化人数、分销返利、红包发放等。
- 支持多维度筛选和分析。
- 数据可视化展示（折线图、柱状图等）。

### 5. 灵活集成与权限
- 支持多业务线、多场景灵活配置和管理。
- 首页入口、数据区块等支持权限控制和自定义显示。

---

## 三、前端开发要点
- 用 Shadcn UI + Tailwind CSS 做付款码生成、管理、数据统计、分销返利、红包池等页面。
- 付款码生成可用 qrcode.react 或后端接口返回二维码图片。
- 付款、入库、分销等通过后端API实现，前端负责展示进度和结果。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 组件建议拆分：付款码生成、付款码管理、数据统计、分销返利、红包池、客户入库、活动配置。
- 数据可视化建议用 Chart.js/Echarts 实现。
- 首页入口、数据区块、分销返利、红包池等支持权限控制和自定义显示。

---

## 四、接口说明（前端常用）
- 付款码生成：/api/paycode/generate
- 付款码管理：/api/paycode/manage
- 付款回调：/api/paycode/callback
- 客户入库：/api/paycode/import
- 分销返利：/api/paycode/distribution
- 红包池：/api/paycode/redpacket
- 数据统计：/api/paycode/stats

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 53: 前端-场景获客-公众号获客功能.md

*文件大小：2.93 KB*

---

# 场景获客-公众号获客功能说明（重写版）

## 一、功能概述
公众号获客功能，核心是为运营者生成可直接嵌入公众号文章页面的小程序卡片。运营者可自定义卡片标题、引导图片、跳转配置等，用户在公众号文章内点击卡片即可跳转到存客宝小程序，完成留资、获客等动作。无需解绑公众号账号，无需复杂授权，聚焦于"生成-配置-粘贴-获客"全流程极简体验。

## 二、核心功能模块

### 1. 小程序卡片生成
- 支持一键生成适配公众号文章的存客宝小程序卡片代码。
- 可自定义卡片标题、引导文案、引导图片（支持上传/选择模板）。
- 支持配置跳转参数（如活动ID、渠道码、分组等），便于后续数据归因。
- 生成的卡片代码可直接复制粘贴到公众号文章编辑器。

### 2. 配置与预览
- 实时预览卡片在公众号文章内的展示效果。
- 支持多种样式模板选择，适配不同运营场景。
- 可配置点击后跳转的小程序页面（如表单、活动页、内容页等）。

### 3. 数据统计与追踪
- 实时统计每个卡片的点击量、跳转量、转化量。
- 支持按渠道、活动、时间等多维度分析。
- 可导出数据报表，便于运营复盘。

### 4. 灵活集成与权限
- 生成的卡片代码无需复杂开发，直接粘贴即用。
- 支持多账号、多业务线灵活配置和管理。
- 首页入口、数据区块等支持权限控制和自定义显示。

---

## 三、功能流程
1. 进入公众号获客配置页面，选择/上传引导图片，填写标题、引导文案。
2. 配置跳转参数（如活动ID、渠道码、分组等），选择跳转的小程序页面。
3. 实时预览卡片效果，确认无误后生成小程序卡片代码。
4. 复制代码，粘贴到公众号文章编辑器指定位置。
5. 用户阅读公众号文章时，点击卡片自动跳转到存客宝小程序，完成留资/获客。
6. 后台实时统计卡片点击、跳转、转化等数据。

---

## 四、前端实现要点
- 采用 Shadcn UI + Tailwind CSS 实现卡片配置、预览、生成、数据统计等交互。
- 卡片生成支持多模板、图片上传、参数配置、实时预览。
- 生成代码支持一键复制，兼容公众号文章编辑器粘贴。
- 数据统计区块建议用 Chart.js/Echarts 实现。
- 支持Skeleton骨架屏提升加载体验。
- 首页入口、数据区块等支持权限控制和自定义显示。

---

## 五、数据结构与接口
- 卡片配置字段：标题、引导文案、引导图片、跳转参数、跳转页面、生成时间、创建人等。
- 卡片生成接口：/api/mpcard/generate
- 数据统计接口：/api/mpcard/stats
- 模板管理接口：/api/mpcard/templates

---

> 本文档已根据最新需求重写，专注于公众号文章内小程序卡片的生成、配置、粘贴与数据统计。如有新需求请及时补充。 

---

## 文件 54: 前端-场景获客-海报获客功能.md

*文件大小：2.42 KB*

---

# 场景获客-海报获客功能说明（通俗版）

## 一、功能简介
海报获客就是通过生成专属二维码海报，用户扫码后自动进入私域流量池。支持分销奖励、红包、AI内容推送等自动化管理，扫码后可自动触发各种活动，数据实时统计，方便企业高效获客。

## 二、主要功能模块

### 1. 海报模板管理
- 多种海报模板选择和自定义。
- 可上传品牌LOGO、背景图、宣传语等。
- 实时预览海报效果。

### 2. 二维码生成与绑定
- 每个海报自动生成专属二维码。
- 二维码可绑定不同渠道、活动、推广人、分销层级。
- 支持批量生成和下载。

### 3. 渠道追踪与数据统计
- 统计每个海报的扫码次数、转化人数、转化率、分销返利、红包发放等。
- 支持多维度筛选和分析。
- 数据可视化展示（折线图、柱状图等）。

### 4. 用户分层与自动分组
- 新用户扫码后自动分配到指定分组、标签或分销层级。
- 支持自定义分组和分销规则。

### 5. 活动管理与自动化
- 支持为不同海报设置专属活动（如优惠券、抽奖、分销奖励、红包发放、AI内容推送等）。
- 用户扫码后自动触发活动和自动化任务。

### 6. 分享与传播
- 一键生成海报图片，支持保存到本地或直接分享到微信、朋友圈等社交平台。
- 支持生成带参数的短链，便于线上推广。

---

## 三、前端开发要点
- 用 Shadcn UI + Tailwind CSS 做模板选择、表单、预览、分销返利、红包池、活动配置等页面。
- 二维码生成可用 qrcode.react 或后端接口返回图片。
- 数据统计区块建议用 Chart.js/Echarts 实现。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 分享功能需兼容移动端 H5 与 PC。
- 组件建议拆分：模板选择、二维码生成、分销返利、红包池、数据统计、活动配置、分享区块。
- 首页入口、数据区块、分销返利、红包池等支持权限控制和自定义显示。

---

## 四、接口说明（前端常用）
- 海报模板、二维码、活动配置、分销返利、红包池等均通过 /lib/api 统一管理
- 数据统计接口需支持多维度筛选
- 用户分组/标签/分销接口需与后端约定格式

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 55: 前端-场景获客-微信群获客功能.md

*文件大小：3.41 KB*

---

# 场景获客-微信群获客功能说明（重写版）

## 一、功能概述
微信群获客功能聚焦于：客服可在设备上批量寻找多个微信号和微信群，支持选择设备微信号，批量添加/管理微信群，并可自动将微信群内成员批量导入存客宝客户池，实现自动化好友添加、群成员同步、数据统计等，极大提升社群运营效率和私域沉淀能力。

## 二、核心功能模块

### 1. 设备微信号与微信群管理
- 支持在设备上批量绑定多个微信号。
- 客服可选择设备内任意微信号，批量添加/管理微信群。
- 支持按时间节点、微信号、群分组等灵活管理微信群。
- 支持新增微信群、批量导入微信群、群信息同步。

### 2. 群成员自动导入与好友添加
- 支持一键将指定微信群内所有成员批量导入存客宝客户池。
- 支持自动化好友添加：设备微信号可自动向群成员发起加好友请求。
- 支持去重、黑名单过滤、标签分组等。
- 可配置自动化任务（如定时同步、批量添加、分组分配等）。

### 3. 群成员同步与分组管理
- 支持定时/手动同步微信群成员信息。
- 支持按群、微信号、时间节点等多维度分组管理。
- 支持群成员标签、分组、批量操作。

### 4. 数据统计与追踪
- 实时统计每个设备、微信号、微信群的成员数、导入数、加好友成功数等。
- 支持按时间、设备、微信号、群等多维度分析。
- 可导出数据报表，便于运营复盘。

### 5. 灵活集成与权限
- 支持多客服、多设备、多微信号灵活配置和管理。
- 首页入口、数据区块等支持权限控制和自定义显示。

---

## 三、功能流程
1. 客服在设备上批量绑定微信号，批量添加/管理微信群。
2. 选择设备微信号，按需新增/导入微信群。
3. 一键同步微信群成员，自动批量导入存客宝客户池。
4. 设备微信号自动向群成员发起加好友请求，支持去重、分组、标签等。
5. 后台实时统计设备、微信号、群、成员、导入、加好友等数据。

---

## 四、前端实现要点
- 采用 Shadcn UI + Tailwind CSS 实现设备微信号、微信群、成员管理、批量操作、数据统计等交互。
- 支持批量导入、批量操作、定时任务、自动化流程。
- 支持一键同步、一键导入、一键加好友等高效操作。
- 数据统计区块建议用 Chart.js/Echarts 实现。
- 支持Skeleton骨架屏提升加载体验。
- 首页入口、数据区块等支持权限控制和自定义显示。

---

## 五、数据结构与接口
- 设备微信号字段：设备ID、微信号、绑定时间、状态等。
- 微信群字段：群ID、群名称、所属微信号、创建时间、成员数、分组、标签等。
- 群成员字段：成员ID、昵称、微信号、所属群、导入状态、标签、分组等。
- 微信号管理接口：/api/groupwechat/wechat-manage
- 微信群管理接口：/api/groupwechat/group-manage
- 群成员同步接口：/api/groupwechat/member-sync
- 批量导入接口：/api/groupwechat/batch-import
- 批量加好友接口：/api/groupwechat/batch-addfriend
- 数据统计接口：/api/groupwechat/stats

---

> 本文档已根据最新需求重写，聚焦设备微信号、微信群批量管理、群成员自动导入与好友添加、数据统计等。如有新需求请及时补充。 

---

## 文件 56: 前端-场景获客-小红书获客功能.md

*文件大小：2.71 KB*

---

# 场景获客-小红书获客功能说明（通俗版）

## 一、功能简介
小红书获客就是通过对接小红书平台，把小红书上的客户线索（如私信、评论、表单等）自动采集到系统，分配给员工，自动发分销奖励、红包，数据实时统计，帮助企业高效获取小红书流量并沉淀到私域。

## 二、主要功能模块

### 1. 小红书账号管理
- 支持绑定/解绑多个小红书号。
- 展示账号信息、状态、粉丝数等。
- 支持账号分组、标签、分销层级归属。

### 2. 线索采集与导入
- 自动采集小红书私信、评论、表单等线索。
- 支持手动录入或批量导入（手机号、微信号、昵称、来源笔记/直播、分销关系等）。
- 系统自动去重、校验有效性。

### 3. 线索分配与转化
- 线索可自动分配给员工、分组或分销层级。
- 分配规则可自定义（如按来源、时间、标签等）。
- 支持自动推送欢迎语、加微信、分组、分销奖励等。

### 4. 分销返利与红包
- 线索可绑定分销关系，自动计算返利。
- 支持自动发红包奖励。
- 分销和红包数据实时同步。

### 5. 数据统计与分析
- 实时统计小红书获客总量、转化率、各渠道/笔记/直播带来的线索数、分销返利、红包发放等。
- 支持多维度筛选（时间、账号、来源、员工、分销层级等）。
- 数据可视化展示（折线图、饼图、柱状图等）。

### 6. 互动与自动化
- 支持自动回复私信、评论，提升互动效率。
- 可配置自动化任务（如定时推送、自动分组、分销奖励、红包发放、AI内容推送等）。

---

## 三、前端开发要点
- 用 Shadcn UI + Tailwind CSS 做账号管理、线索列表、分销返利、红包池、统计报表等页面。
- 小红书授权、数据采集等通过后端API实现，前端只负责展示和交互。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 组件建议拆分：账号管理、线索采集、分配转化、分销返利、红包池、数据统计、自动化配置。
- 数据可视化建议用 Chart.js/Echarts 实现。
- 首页入口、数据区块、分销返利、红包池等支持权限控制和自定义显示。

---

## 四、接口说明（前端常用）
- 小红书账号：/api/xiaohongshu/account
- 线索采集：/api/xiaohongshu/leads
- 线索分配：/api/xiaohongshu/assign
- 分销返利：/api/xiaohongshu/distribution
- 红包池：/api/xiaohongshu/redpacket
- 数据统计：/api/xiaohongshu/stats
- 自动化配置：/api/xiaohongshu/automation

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 57: 前端-场景获客-API获客功能.md

*文件大小：2.76 KB*

---

# 场景获客-API获客功能说明

## 一、功能简介
API获客是通过开放标准化API接口，允许第三方系统、业务平台、外部应用等将客户线索、用户数据实时推送到存客宝系统，实现自动化客户入库、标签分组、分销返利、数据统计等全流程管理。适用于渠道合作、平台对接、自动化营销等多种场景。

## 二、主要功能模块

### 1. API接入与鉴权
- 提供标准化API接口，支持POST方式推送客户线索。
- 支持API密钥、Token等多种鉴权方式，保障数据安全。
- 支持多渠道、多业务线独立配置API接入参数。

### 2. 客户线索推送与入库
- 支持批量或单条推送客户信息（如手机号、微信号、姓名、来源、标签等）。
- 推送成功后自动入库，支持去重、格式校验、黑名单过滤。
- 可配置自动分配标签、分组、分销层级。

### 3. 分销返利与自动化任务
- 支持API推送线索自动绑定分销关系，自动计算返利。
- 可配置自动发放红包、推送欢迎语、触发自动化任务等。
- 分销与红包数据实时同步。

### 4. 数据统计与追踪
- 实时统计API获客总量、有效数、无效数、分销返利、红包发放等。
- 支持多维度筛选和分析。
- 数据可视化展示（折线图、柱状图等）。

### 5. 灵活集成与权限
- 支持多业务线、多渠道灵活配置和管理API接入。
- 首页入口、数据区块等支持权限控制和自定义显示。

---

## 三、前端开发要点
- 直接复用 scenarioApi（/api/scenarios）相关接口进行API获客场景的创建、数据统计、客户入库等。
- 支持API接入参数配置、密钥管理、推送日志、数据回溯等页面。
- 组件建议拆分：API接入配置、推送日志、数据统计、分销返利、红包池、客户入库、自动化任务配置。
- 用 Shadcn UI + Tailwind CSS 实现表单、配置、数据统计、权限控制等页面。
- 所有加载过程用骨架屏（Skeleton）提升体验。
- 数据可视化建议用 Chart.js/Echarts 实现。
- 首页入口、数据区块、分销返利、红包池等支持权限控制和自定义显示。

---

## 四、接口说明
- 创建API获客场景：POST /api/scenarios
- 查询API获客场景列表：GET /api/scenarios
- 获取API获客场景详情：GET /api/scenarios/{id}
- 推送客户线索（API对接）：POST /api/scenarios/{id}/records
- 获取获客记录：GET /api/scenarios/{id}/records
- 导出获客记录：GET /api/scenarios/{id}/records/export
- 获取场景统计数据：GET /api/scenarios/{id}/stats
- 批量更新标签：POST /api/scenarios/{id}/tags

---

> 本文档持续更新，已结合现有API能力和业务需求，后续如有功能调整请及时补充。 

---

## 文件 58: 前端-场景获客功能描述.md

*文件大小：2.28 KB*

---

# 场景获客功能描述

## 一、功能简介
场景获客模块聚合多种线上线下获客渠道和工具，支持电话、抖音、小红书、海报、订单、公众号、微信群、API等多场景自动化获客，帮助企业高效拓展客户资源。

---

## 二、主要功能模块

### 1. 多渠道获客入口
- 支持电话、抖音、小红书、海报、订单、公众号、微信群、API等多种获客场景。
- 每个场景均有独立的获客流程、数据追踪和自动化配置。

### 2. 获客流程与自动化
- 支持自动化、批量化、动态化的获客流程配置。
- 支持自动加好友、批量加群、自动分配、标签化管理、数据追踪等。
- 支持失败重试、风控策略、权限控制等。

### 3. 数据统计与分析
- 实时统计各渠道获客数据、转化率、活跃度等。
- 支持多维度数据可视化、趋势分析、导出报表。

### 4. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、数据日志查询。
- 获客数据加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要区块包括多渠道入口、获客流程配置、数据统计、日志区等。

### 2. 数据流与接口调用
- 获客相关：
  - 获取渠道列表
  - 获取获客流程配置
  - 获取获客数据
  - 提交获客任务
- 日志与统计相关：
  - 获取操作日志、数据日志
  - 获取统计数据

### 3. 交互细节
- 支持多渠道入口的切换、流程配置的自定义。
- 支持获客流程的自动化、批量化、动态化配置。
- 所有区块、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好各场景入口和流程结构，优先实现主流获客场景和自动化主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如流程自定义、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 59: 前端-工作台-内容多平台分发功能.md

*文件大小：3.06 KB*

---

# 工作台-内容多平台分发前端功能说明

## 一、功能简介
内容多平台分发功能支持用户在内容库中选择任意内容（如图文、图片、视频、链接等），一键分发到全网主流可发朋友圈的平台（如微信朋友圈、视频号、抖音、快手、小红书、微博、B站、QQ空间等），实现内容高效触达和全渠道曝光。

---

## 二、主要功能模块

### 1. 内容选择与分发入口
- 支持在内容库中批量选择内容素材。
- 支持多选、单选、内容预览、内容筛选。
- 提供一键分发入口，支持分发到多个平台。

### 2. 平台账号与分发配置
- 支持绑定和管理各主流平台账号（如微信、抖音、快手、小红书、微博、B站、QQ空间等）。
- 支持分发前选择目标平台、目标账号、分发方式（立即/定时/批量）。
- 支持分发内容的适配（如自动裁剪、格式转换、平台限制提示等）。

### 3. 分发任务管理
- 支持分发任务的创建、编辑、删除、进度跟踪、状态切换。
- 支持分发任务的批量操作、失败重试、分发日志查询。
- 支持分发结果回执、异常提醒。

### 4. 数据统计与分析
- 实时统计各平台分发量、成功率、覆盖人数、互动量等。
- 支持多维度数据可视化、趋势分析、导出报表。
- 主要功能区：统计区块、图表区。

### 5. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、分发日志查询。
- 分发过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括内容选择、平台账号管理、分发配置、分发任务管理、统计分析等。
- 主要功能区包括内容表格、平台账号管理、分发配置区、批量操作区、统计区块、日志区等。

### 2. 数据流与接口调用
- 内容分发相关：
  - 获取内容库列表
  - 获取平台账号列表
  - 创建/编辑/删除分发任务
  - 获取分发进度、分发结果
- 日志与统计相关：
  - 获取分发日志
  - 获取分发统计数据

### 3. 交互细节
- 支持内容的多选、筛选、预览、批量分发。
- 支持分发前的内容适配、平台限制提示、分发方式选择。
- 支持分发任务的进度跟踪、失败重试、异常提醒。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好内容选择、平台账号管理、分发配置、分发任务管理的结构，优先实现主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如内容适配、批量分发、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 60: 前端-工作台-朋友圈同步功能.md

*文件大小：3.83 KB*

---

# 工作台-朋友圈同步前端功能说明

## 一、功能简介
朋友圈同步功能用于将多个设备、多个微信号下的朋友圈内容自动同步到系统工作台，便于统一管理、内容归档、数据分析和后续运营动作。支持多账号、多设备批量同步，支持内容筛选、标签、评论互动等。

---

## 二、主要功能模块

### 1. 朋友圈同步任务管理
- 支持新建、编辑、删除朋友圈同步任务。
- 每个任务可配置同步设备、内容库、同步数量、账号类型、允许时间段、是否启用等。
- 支持任务的启动/暂停、进度展示、状态切换。
- 主要功能区：任务卡片、任务列表、顶部操作栏（新建、搜索、筛选、刷新）。

### 2. 设备与微信号选择
- 支持批量选择设备、微信号，支持状态筛选（在线/离线）。
- 设备信息包括名称、IMEI、微信号、在线状态、已用计划数。
- 设备选择在新建/编辑任务流程中弹窗调用。

### 3. 朋友圈内容同步与展示
- 支持一键同步所有已绑定微信号的朋友圈内容，支持定时自动同步、手动同步、增量同步。
- 内容展示用表格形式展示内容ID、类型、正文、图片、视频、推送时间、状态等。
- 支持内容搜索、筛选、刷新。
- 详情页支持内容编辑、标签管理、归档等。

### 4. 朋友圈内容管理与互动
- 支持内容归档、批量删除、批量标签、批量导出。
- 支持对朋友圈内容进行评论、点赞、转发等互动（后续可扩展）。
- 主要功能区：内容表格、批量操作区、标签编辑器、评论/点赞按钮。

### 5. 数据统计与分析
- 实时统计同步的朋友圈总数、活跃微信号数、互动量等。
- 支持数据可视化展示（折线图、柱状图等）。
- 支持导出朋友圈内容及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、同步日志查询。
- 数据同步过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括任务列表、新建任务、编辑任务、任务详情/内容列表等。
- 主要功能区包括基础配置表单、设备/微信号选择弹窗、朋友圈内容表格展示、标签管理、步骤指示、批量操作区、统计区块、评论/点赞区等。

### 2. 数据流与接口调用
- 朋友圈同步任务相关：
  - 创建任务
  - 获取任务列表
  - 获取任务详情
  - 更新任务
  - 删除任务
  - 启动/暂停任务
- 设备与微信号相关：
  - 获取设备列表
  - 获取微信号列表
- 朋友圈内容相关：
  - 获取内容列表、详情、批量操作、评论、点赞等
- 日志与统计相关：
  - 获取同步日志
  - 数据统计

### 3. 交互细节
- 新建/编辑任务时，先填写基础配置，再选择设备，最后确认并保存。
- 任务列表页支持任务的启动/暂停、编辑、删除、查看详情。
- 详情页支持内容筛选、批量操作、互动（评论/点赞）、内容归档等。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现任务管理、设备选择、内容展示主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 61: 前端-工作台-群发助手功能.md

*文件大小：3.77 KB*

---

# 工作台-群发助手前端功能说明

## 一、功能简介
群发助手用于批量向多个微信群、好友推送内容（文本、图片、视频、链接等），支持多任务、多内容库、多群/好友选择、定时/循环/立即推送等，提升社群运营效率和内容触达率。

---

## 二、主要功能模块

### 1. 群发任务管理
- 支持新建、编辑、删除群发任务。
- 每个任务可配置推送对象（群/好友）、内容库、推送时间段、每日推送数量、推送顺序、是否循环、是否立即推送、是否启用等。
- 支持任务的启动/暂停、进度展示、状态切换。
- 主要功能区：任务卡片、任务列表、顶部操作栏（新建、搜索、筛选、刷新）。

### 2. 群发内容选择与编辑
- 支持选择多个内容库，内容库可管理图文、图片、视频、链接等多种类型内容。
- 支持富文本编辑、图片/视频上传、链接插入、内容预览、字数/数量限制。

### 3. 群发对象选择
- 支持批量选择微信群，支持搜索、筛选、归属客服筛选。
- 支持批量选择好友，支持设备筛选、标签筛选、地区筛选、全选/反选。
- 支持群/好友混合推送，推送对象可灵活配置。

### 4. 群发任务流程与步骤
- 支持多步骤流程（基础设置→内容选择→对象选择→消息编辑→确认发布）。
- 每一步均有表单校验、进度指示、上一步/下一步操作。

### 5. 数据统计与分析
- 实时统计每个任务的推送总数、已推送数、失败数、覆盖群/好友数等。
- 支持数据可视化展示（折线图、柱状图等）。
- 支持导出推送记录及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、推送日志查询。
- 数据推送过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括任务列表、新建任务、编辑任务、任务详情/进度/统计等。
- 主要功能区包括基础配置表单、内容库选择与管理、群发内容编辑、微信群选择、好友选择、多步骤流程指示、批量操作区、统计区块、日志区等。

### 2. 数据流与接口调用
- 群发任务相关：
  - 创建任务
  - 获取任务列表
  - 获取任务详情
  - 更新任务
  - 删除任务
- 内容库相关：
  - 获取内容库列表
  - 获取内容项列表
  - 创建/编辑/删除内容项等
- 群/好友相关：
  - 获取设备/群/好友列表、详情、筛选、批量操作等
- 日志与统计相关：
  - 获取推送日志
  - 数据统计

### 3. 交互细节
- 新建/编辑任务时，按步骤依次填写基础配置、选择内容、选择对象、编辑消息、确认发布。
- 每一步均有表单校验、进度指示、上一步/下一步操作。
- 任务列表页支持任务的启动/暂停、编辑、删除、查看详情。
- 详情页支持进度查看、批量操作、统计分析、日志导出等。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现任务管理、内容选择、对象选择、消息编辑主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 62: 前端-工作台-群同步功能.md

*文件大小：3.70 KB*

---

# 工作台-群同步前端功能说明

## 一、功能简介
群同步功能用于将多个设备、多个微信号下的微信群信息自动同步到系统工作台，便于统一管理、成员归档、数据分析和后续运营动作。支持多账号、多设备批量同步，支持群信息筛选、标签、成员管理等。

---

## 二、主要功能模块

### 1. 群同步任务管理
- 支持新建、编辑、删除群同步任务。
- 每个任务可配置同步设备、同步群类型、同步数量、账号类型、允许时间段、是否启用等。
- 支持任务的启动/暂停、进度展示、状态切换。
- 主要功能区：任务卡片、任务列表、顶部操作栏（新建、搜索、筛选、刷新）。

### 2. 设备与微信号选择
- 支持批量选择设备、微信号，支持状态筛选（在线/离线）。
- 设备信息包括名称、微信号、在线状态、已用计划数。

### 3. 群信息同步与展示
- 支持一键同步所有已绑定微信号的微信群信息，支持定时自动同步、手动同步、增量同步。
- 群信息展示用表格形式展示群ID、群名、成员数、标签、创建时间、状态等。
- 支持群信息搜索、筛选、刷新。
- 详情页支持群成员管理、标签管理、归档等。

### 4. 群管理与互动
- 支持群归档、批量删除、批量标签、批量导出。
- 支持对群进行成员管理、标签管理、互动统计等。
- 主要功能区：群信息表格、批量操作区、标签编辑器、成员管理按钮。

### 5. 数据统计与分析
- 实时统计同步的群总数、活跃群数、成员总数等。
- 支持数据可视化展示（折线图、柱状图等）。
- 支持导出群信息及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、同步日志查询。
- 数据同步过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括任务列表、新建任务、编辑任务、任务详情/群信息列表等。
- 主要功能区包括基础配置表单、设备/微信号选择弹窗、群信息表格展示、标签管理、成员管理、步骤指示、批量操作区、统计区块等。

### 2. 数据流与接口调用
- 群同步任务相关：
  - 创建任务
  - 获取任务列表
  - 获取任务详情
  - 更新任务
  - 删除任务
  - 启动/暂停任务
- 设备与微信号相关：
  - 获取设备列表
  - 获取微信号列表
- 群信息相关：
  - 获取群信息列表、详情、批量操作、成员管理、标签管理等
- 日志与统计相关：
  - 获取同步日志
  - 数据统计

### 3. 交互细节
- 新建/编辑任务时，先填写基础配置，再选择设备，最后确认并保存。
- 任务列表页支持任务的启动/暂停、编辑、删除、查看详情。
- 详情页支持群信息筛选、批量操作、成员管理、标签管理、归档等。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现任务管理、设备选择、群信息展示主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 63: 前端-工作台-自动点赞功能.md

*文件大小：3.60 KB*

---

# 工作台-自动点赞前端功能说明

## 一、功能简介
自动点赞功能用于批量、自动地为指定微信号/设备下的朋友圈内容点赞，提升互动率和客户活跃度。支持多任务、多设备、多账号、定时、批量、标签筛选等自动化配置。

---

## 二、主要功能模块

### 1. 自动点赞任务管理
- 支持新建、编辑、删除自动点赞任务。
- 每个任务可配置点赞设备、目标分组、点赞间隔、每日上限、时间区间、内容类型、目标标签、是否启用等。
- 支持任务的启动/暂停、进度展示、状态切换。
- 主要功能区：任务卡片、任务列表、顶部操作栏（新建、搜索、筛选、刷新）。

### 2. 设备与目标对象选择
- 支持批量选择设备、微信号，支持状态筛选（在线/离线）。
- 支持目标分组、标签筛选，灵活配置目标人群。
- 设备信息包括名称、微信号、在线状态等。

### 3. 点赞内容与规则配置
- 支持配置点赞内容类型（文本、图片、视频等）。
- 支持设置点赞间隔、每日点赞上限、点赞时间段、是否循环、是否启用等。
- 支持标签筛选、分组筛选、优先级设置等。

### 4. 点赞任务流程与步骤
- 支持多步骤流程（基础设置→设备选择→标签筛选→确认发布）。
- 每一步均有表单校验、进度指示、上一步/下一步操作。

### 5. 数据统计与分析
- 实时统计每个任务的点赞总数、已点赞数、失败数、覆盖好友数等。
- 支持数据可视化展示（折线图、柱状图等）。
- 支持导出点赞记录及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、点赞日志查询。
- 点赞过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括任务列表、新建任务、编辑任务、任务详情/进度/统计等。
- 主要功能区包括基础配置表单、设备选择、标签筛选、多步骤流程指示、批量操作区、统计区块、日志区等。

### 2. 数据流与接口调用
- 自动点赞任务相关：
  - 创建任务
  - 获取任务列表
  - 获取任务详情
  - 更新任务
  - 删除任务
- 设备与微信号相关：
  - 获取设备列表
  - 获取微信号列表
- 点赞对象与内容相关：
  - 获取目标分组、标签、内容类型等
- 日志与统计相关：
  - 获取点赞日志
  - 数据统计

### 3. 交互细节
- 新建/编辑任务时，按步骤依次填写基础配置、选择设备、筛选标签、确认发布。
- 每一步均有表单校验、进度指示、上一步/下一步操作。
- 任务列表页支持任务的启动/暂停、编辑、删除、查看详情。
- 详情页支持进度查看、批量操作、统计分析、日志导出等。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现任务管理、设备选择、标签筛选主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 64: 前端-工作台-自动建群功能.md

*文件大小：3.72 KB*

---

# 工作台-自动建群前端功能说明

## 一、功能简介
自动建群功能用于批量、自动地为指定微信号/设备创建微信群，支持多任务、多设备、多账号、定时、批量、标签筛选等自动化配置，提升社群裂变效率和客户分层管理能力。

---

## 二、主要功能模块

### 1. 自动建群任务管理
- 支持新建、编辑、删除自动建群任务。
- 每个任务可配置建群设备、目标分组、建群间隔、每日上限、时间区间、群成员来源、群名称规则、是否启用等。
- 支持任务的启动/暂停、进度展示、状态切换。
- 主要功能区：任务卡片、任务列表、顶部操作栏（新建、搜索、筛选、刷新）。

### 2. 设备与目标对象选择
- 支持批量选择设备、微信号，支持状态筛选（在线/离线）。
- 支持目标分组、标签筛选，灵活配置建群对象。
- 设备信息包括名称、微信号、在线状态等。

### 3. 建群内容与规则配置
- 支持配置群成员来源（标签、分组、导入名单等）。
- 支持设置建群间隔、每日建群上限、建群时间段、群名称规则、是否循环、是否启用等。
- 支持标签筛选、分组筛选、优先级设置等。

### 4. 建群任务流程与步骤
- 支持多步骤流程（基础设置→设备选择→成员筛选→群规则配置→确认发布）。
- 每一步均有表单校验、进度指示、上一步/下一步操作。

### 5. 数据统计与分析
- 实时统计每个任务的建群总数、已建群数、失败数、覆盖成员数等。
- 支持数据可视化展示（折线图、柱状图等）。
- 支持导出建群记录及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、建群日志查询。
- 建群过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括任务列表、新建任务、编辑任务、任务详情/进度/统计等。
- 主要功能区包括基础配置表单、设备选择、成员筛选、群规则配置、多步骤流程指示、批量操作区、统计区块、日志区等。

### 2. 数据流与接口调用
- 自动建群任务相关：
  - 创建任务
  - 获取任务列表
  - 获取任务详情
  - 更新任务
  - 删除任务
- 设备与微信号相关：
  - 获取设备列表
  - 获取微信号列表
- 建群对象与内容相关：
  - 获取目标分组、标签、成员名单、群名称规则等
- 日志与统计相关：
  - 获取建群日志
  - 数据统计

### 3. 交互细节
- 新建/编辑任务时，按步骤依次填写基础配置、选择设备、筛选成员、配置群规则、确认发布。
- 每一步均有表单校验、进度指示、上一步/下一步操作。
- 任务列表页支持任务的启动/暂停、编辑、删除、查看详情。
- 详情页支持进度查看、批量操作、统计分析、日志导出等。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现任务管理、设备选择、成员筛选、群规则配置主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 65: 前端-工作台-AI助手功能.md

*文件大小：2.91 KB*

---

# 工作台-AI助手前端功能说明

## 一、功能简介
AI助手功能为用户提供智能化的内容创作、自动回复、客户分析、运营建议等能力，助力私域运营自动化、智能化和高效化。

---

## 二、主要功能模块

### 1. 智能内容创作
- 支持AI自动生成朋友圈文案、群发内容、营销话术等。
- 支持多种内容风格、场景模板、批量生成、内容润色。
- 支持内容一键导入内容库或直接分发。

### 2. 智能自动回复
- 支持配置关键词自动回复、智能对话、常见问题解答等。
- 支持多轮对话、上下文理解、回复内容自定义。
- 支持自动回复日志、效果统计。

### 3. 客户分析与标签建议
- 支持AI自动分析客户画像、行为轨迹、互动偏好。
- 支持智能标签推荐、客户分层建议、流失预警等。

### 4. 运营策略与建议
- 支持AI根据数据自动生成运营策略、活动建议、内容推送计划等。
- 支持一键采纳、批量应用、效果追踪。

### 5. 数据统计与分析
- 实时统计AI助手使用量、内容生成量、自动回复量、客户分析量等。
- 支持多维度数据可视化、趋势分析、导出报表。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、AI日志查询。
- AI数据处理过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括内容创作、自动回复配置、客户分析、运营建议、统计分析等。
- 主要功能区包括内容生成区、自动回复区、客户分析区、运营建议区、统计区块、日志区等。

### 2. 数据流与接口调用
- AI助手相关：
  - 内容生成接口
  - 自动回复配置接口
  - 客户分析与标签推荐接口
  - 运营建议接口
- 日志与统计相关：
  - 获取AI助手日志
  - 获取AI助手统计数据

### 3. 交互细节
- 支持内容的批量生成、风格切换、模板选择、一键导入/分发。
- 支持自动回复的关键词配置、对话测试、效果追踪。
- 支持客户分析结果的可视化、标签一键应用。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好内容创作、自动回复、客户分析、运营建议等结构，优先实现主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量生成、智能推荐、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 66: 前端-工作台功能描述.md

*文件大小：2.32 KB*

---

# 工作台功能描述

## 一、功能简介
工作台模块聚合了所有自动化运营、批量任务、互动管理等核心能力，是私域流量精细化运营和高效协作的主阵地。

---

## 二、主要功能模块

### 1. 任务管理与自动化
- 支持自动点赞、自动建群、群同步、群发助手、朋友圈同步等多种自动化任务。
- 支持任务的创建、编辑、删除、启动、暂停、进度跟踪、批量操作等。

### 2. 互动与内容管理
- 支持批量互动（点赞、评论、加好友、群发等）。
- 支持内容同步、内容推送、内容归档、标签管理等。

### 3. 数据统计与分析
- 实时统计各类任务的执行进度、成功率、互动量等。
- 支持多维度数据可视化、趋势分析、导出报表。

### 4. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、任务日志查询。
- 任务数据加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要区块包括任务管理、自动化配置、互动管理、内容管理、数据统计、日志区等。

### 2. 数据流与接口调用
- 任务与自动化相关：
  - 获取任务列表
  - 获取任务详情
  - 创建/编辑/删除/启动/暂停任务
- 互动与内容相关：
  - 获取互动数据
  - 获取内容数据
  - 内容推送、归档、标签管理
- 日志与统计相关：
  - 获取操作日志、任务日志
  - 获取统计数据

### 3. 交互细节
- 支持任务的批量操作、进度跟踪、状态切换。
- 支持互动、内容的批量管理、标签化、归档等。
- 所有区块、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好各自动化任务和互动管理的结构，优先实现主流自动化任务和批量管理主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 67: 前端-首页功能.md

*文件大小：5.91 KB*

---

# 首页功能详细文档（通俗版）

## 1. 数据总览

首页的数据总览区域需要清晰地展示关键运营指标，帮助用户快速了解当前平台的运行状态。这些数据通过调用后端 `/api/v1/homepage/overview` 接口获取。

### 1.1 设备数量统计
- 展示当前接入的设备总数。
- 数据字段：`deviceTotalCount`。
- 支持点击跳转到设备管理页面 (`/my/device-management`)。
- 数据来源：后端首页概览接口。

### 1.2 微信号数量统计
- 展示当前接入的微信号总数。
- 数据字段：`wechatAccountTotalCount`。
- 支持点击跳转到微信号管理页面 (`/my/wechat-management`)。
- 数据来源：后端首页概览接口。

### 1.3 在线微信号统计
- 展示当前在线的微信号数量及占比。
- 数据字段：`onlineWechatAccountCount` 和 `onlineWechatAccountRatio`。
- 以进度条或百分比形式直观展示。
- 数据来源：后端首页概览接口。
- 实时性：考虑使用 WebSocket 或短间隔轮询更新此数据，以反映最新状态。

### 1.4 获客趋势图表
- 以折线图形式展示近一周的获客数量变化。
- 数据字段：`acquisitionTrendLastWeek.dates` 和 `acquisitionTrendLastWeek.counts`。
- 支持自定义时间范围（未来迭代考虑）。
- 数据来源：后端首页概览接口。
- 技术实现：使用 Chart.js 或 Echarts 组件根据获取的数据绘制图表。

### 1.5 多平台与分销数据概览
- 展示电话、抖音、小红书、公众号、海报、订单等多渠道的获客数据概览 (`channelAcquisitionOverview`)。
- 展示分销相关数据（我的佣金 `distributionOverview.myCommission`、团队佣金 `distributionOverview.teamCommission`、待结算 `distributionOverview.pendingSettlement`）。
- 展示红包池余额 (`redEnvelopePoolBalance`)、内容库推送统计 (`contentPushStatsLastWeek`) 等。
- 数据来源：后端首页概览接口。
- 前端根据用户权限和配置，有选择地展示这些数据区块。

---

## 2. 场景快捷入口

首页的快捷入口区域提供常用功能的快速访问，这些入口列表通过调用后端 `/api/v1/homepage/quick_access` 接口获取。

- 每个入口对应一个功能或场景（如抖音获客、流量池、内容库、AI助手等）。
- 后端返回的数据包含 `id`, `name`, `icon` (图标标识), `url` (跳转路径), `permission` (所需权限), `dataKey` (关联的数据字段，用于展示数量或统计)。
- 前端根据返回的列表动态渲染快捷入口。
- 点击入口时，根据 `url` 字段进行路由导航。对于关联了 `dataKey` 的入口，前端可以从 `/api/v1/homepage/overview` 返回的数据中提取对应值进行展示。
- 前端根据 `permission` 字段判断用户是否有权限显示该入口。

---

## 3. 通知与导航

### 3.1 顶部导航栏
- 顶部固定导航栏，包含项目LOGO、名称。
- 包含通知按钮，通常带有红点提示未读消息。
- 导航栏可能还包含用户头像/名称、设置等入口。
- 响应式设计，确保在不同屏幕尺寸下的布局和交互。
- AI助手入口和分销/红包池入口也可能集成在此区域，具体取决于原型设计。

### 3.2 通知按钮与通知中心
- 通知按钮通过调用后端接口（如 `/api/v1/notifications/unread_count`）获取未读通知数量，并展示红点。
- 点击通知按钮，弹出通知列表或跳转到通知中心页面。
- 通知内容通过后端接口（如 `/api/v1/notifications/list`）获取，展示系统公告、消息提醒、合规提醒、分销返利通知等。

---

## 4. 前端开发要点与优化

- **技术栈应用:**
    - 使用 React 18 进行组件化开发，构建首页的各个模块。
    - 结合 Shadcn UI 和 Tailwind CSS 进行界面布局和样式设计。 Shadcn UI 提供基础组件，Tailwind CSS 用于布局、颜色、间距、响应式等。
- **iOS 风格优化:**
    - 严格参考提供的 iOS 风格指南（颜色、字体、阴影、圆角、间距），调整 Shadcn UI 组件的样式和自定义元素的样式，以达到更接近 iOS 原生的视觉效果。
    - 字体：配置 Tailwind CSS，使用系统字体栈或接近 San Francisco 的字体。
    - 颜色：从原型或设计稿中精确提取颜色值，并在 Tailwind 配置和自定义样式中使用。
    - 阴影和圆角：使用 Tailwind 的 `shadow-*` 和 `rounded-*` class，或自定义 CSS 属性，模拟 iOS 柔和的阴影和圆角。
    - 间距：精确调整 padding, margin, gap 等属性，使布局比例与设计稿一致。
- **性能与体验优化:**
    - **骨架屏 (Skeleton Screens):** 在数据加载过程中（调用 API 期间），使用 `@/components/ui/skeleton.tsx` (假定 Shadcn UI Skeleton 组件路径) 或类似的 Skeleton 组件作为占位符，避免页面空白，提升感知性能。
    - **懒加载:** 对于非首屏或数据量大的组件，考虑使用 React.lazy 和 Suspense 进行懒加载。
    - **数据缓存:** 对于不经常变动的数据，可以考虑客户端缓存。
- **状态管理:** 使用 React Query, SWR 或 Redux Toolkit Query 等库管理 API 请求状态和数据缓存。
- **路由管理:** 使用 React Router 或 Next.js 的路由功能处理页面导航。
- **代码结构:** 遵循原子设计或类似原则，将 UI 组件、业务逻辑、API 调用分层，提高代码的可维护性和可读性。
- **错误处理:** 在前端统一处理 API 请求错误，向用户提供友好的错误提示。
- **权限控制:** 根据后端返回的权限信息，在前端判断是否渲染某个组件或功能入口。
- **响应式设计:** 使用 Tailwind CSS 的响应式工具类 (`sm:`, `md:`, `lg:`) 实现多端适配。

---

> 本文档持续更新，欢迎补充建议。所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。
> 本文档持续更新，已结合最新需求池优化，后续如有功能调整请及时补充。 

---

## 文件 68: 前端-我的-流量池功能.md

*文件大小：8.94 KB*

---

# 我的-流量池前端功能说明

## 一、功能简介
流量池功能用于统一管理和沉淀所有来源的客户流量，实现客户分层、标签化、动态分组、批量运营和数据分析，提升私域流量的转化和复用效率。

该功能主要通过与后端 `/api/v1/my/customer_pool/*` 系列接口进行交互实现数据的获取和操作。

---

## 二、主要功能模块及接口对应

### 1. 客户流量列表与分组管理

- **功能描述:** 支持展示所有流量客户的基本信息，提供客户分组、批量分组、分组筛选、分组管理功能，以及客户的搜索、筛选、排序、批量操作。
- **对应接口:**
    - 获取客户列表: `GET /api/v1/my/customer_pool/list` (用于获取客户列表数据，支持分页、搜索、筛选、排序)
    - 获取分组列表: `GET /api/v1/my/customer_pool/groups` (用于获取客户分组列表，用于筛选和分组管理)
    - 创建分组: `POST /api/v1/my/customer_pool/groups`
    - 更新分组: `PUT /api/v1/my/customer_pool/groups/{groupId}`
    - 删除分组: `DELETE /api/v1/my/customer_pool/groups/{groupId}`
    - 批量更新客户信息 (含批量分组): `POST /api/v1/my/customer_pool/batch_update`
- **前端实现要点:**
    - 使用 Shadcn UI 的 `DataTable` 或类似的表格组件展示客户列表，支持分页、排序。
    - 实现搜索框和筛选条件的交互，参数变化时调用 `/api/v1/my/customer_pool/list` 接口刷新列表。
    - 使用 Shadcn UI 的 `Dialog` 或 `Sheet` 组件实现分组管理和创建/编辑分组的弹窗。
    - 实现批量选中客户的功能，批量操作按钮（如批量分组）根据选中状态和用户权限显示。

### 2. 客户标签与画像管理

- **功能描述:** 支持客户标签管理、批量打标签、标签筛选、标签分组。支持客户画像展示（基础信息、行为轨迹、互动记录等）。
- **对应接口:**
    - 获取标签列表: `GET /api/v1/my/customer_pool/tags` (用于获取客户标签列表，用于筛选和标签管理)
    - 创建标签: `POST /api/v1/my/customer_pool/tags`
    - 更新标签: `PUT /api/v1/my/customer_pool/tags/{tagId}`
    - 删除标签: `DELETE /api/v1/my/customer_pool/tags/{tagId}`
    - 批量更新客户信息 (含批量打标签): `POST /api/v1/my/customer_pool/batch_update`
    - 获取客户详情 (含画像相关信息): `GET /api/v1/my/customer_pool/detail/{customerId}`
    - 获取客户行为轨迹: `GET /api/v1/my/customer_pool/customer/{customerId}/behavior_trail`
    - 获取客户互动记录: `GET /api/v1/my/customer_pool/customer/{customerId}/interactions`
- **前端实现要点:**
    - 使用 Shadcn UI 组件构建标签管理界面或弹窗。
    - 在客户详情页，使用不同的区域或Tab展示客户基础信息、标签、分组、行为轨迹、互动记录等，分别调用对应的接口获取数据。
    - 实现标签的多选和批量打标签交互。

### 3. 客户状态与动态监控

- **功能描述:** 实时展示客户的活跃状态、最近互动、流转轨迹等。支持客户状态变更提醒、异常客户高亮、健康度评分（可能依赖后端和AI服务）。
- **对应接口:**
    - 获取客户列表 (含状态信息): `GET /api/v1/my/customer_pool/list`
    - 获取客户详情 (含状态、轨迹): `GET /api/v1/my/customer_pool/detail/{customerId}`
    - 获取客户状态/日志相关接口 (如行为轨迹、互动记录): `GET /api/v1/my/customer_pool/customer/{customerId}/...`
- **前端实现要点:**
    - 在客户列表中直观展示客户状态，对异常状态进行高亮。
    - 客户详情页展示客户的活跃状态和动态信息。
    - 实时性要求较高的数据（如在线状态），考虑使用 WebSocket 或短轮询。

### 4. 客户详情与运营操作

- **功能描述:** 支持查看客户详细信息，支持客户备注、分组、标签、批量运营操作（如批量加好友、批量分配、批量群发等）。支持客户归档、移除、导出等操作。
- **对应接口:**
    - 获取客户详情: `GET /api/v1/my/customer_pool/detail/{customerId}`
    - 更新客户信息 (含备注、分组、标签): `PUT /api/v1/my/customer_pool/update/{customerId}`
    - 批量更新客户信息: `POST /api/v1/my/customer_pool/batch_update`
    - 客户批量运营操作接口 (如批量加好友): `POST /api/v1/my/customer_pool/batch_add_friend`
    - 获取操作日志: `GET /api/v1/my/customer_pool/customer/{customerId}/operation_logs`
    - （归档、移除、导出接口待定，需在后端文档中补充）
- **前端实现要点:**
    - 构建客户详情页面，使用 Shadcn UI 组件展示信息和操作按钮。
    - 实现备注、分组、标签等的编辑和更新功能，调用 `PUT /api/v1/my/customer_pool/update/{customerId}` 接口。
    - 实现批量运营操作的交互流程，调用对应的批量操作接口，并处理异步任务的进度和结果反馈。
    - 在客户详情页展示操作日志。

### 5. 数据统计与分析

- **功能描述:** 实时统计流量池客户总数、分组分布、标签分布、活跃度等，支持数据可视化展示，支持导出客户列表及统计数据。
- **对应接口:**
    - 获取流量池统计数据: `GET /api/v1/my/customer_pool/statistics`
    - 获取客户列表 (用于导出): `GET /api/v1/my/customer_pool/list` (获取全量数据或根据筛选条件获取)
    - （导出接口待定，需在后端文档中补充）
- **前端实现要点:**
    - 使用 Chart.js 或 Echarts 组件根据 `/api/v1/my/customer_pool/statistics` 返回的数据绘制饼图、柱状图、折线图等。
    - 在统计区块展示关键数值。
    - 实现数据导出的交互。

### 6. 权限与安全

- **功能描述:** 支持多角色、多账号权限控制。支持操作日志、客户日志查询。客户数据管理过程加密传输，保障数据安全。
- **对应接口:**
    - 操作日志查询接口: `GET /api/v1/my/customer_pool/customer/{customerId}/operation_logs`
    - 后端接口均有权限校验 (在后端文档中已说明)
- **前端实现要点:**
    - 根据后端返回的用户权限信息，控制页面元素的显示与隐藏（如某些操作按钮）。
    - 所有敏感数据（如手机号、微信号）在前端只展示后端脱敏后的数据。
    - 所有与后端交互都应通过 HTTPS。

---

## 三、前端技术实现要点与优化

1.  **技术栈:** 基于 React 18 进行开发，使用 Shadcn UI 和 Tailwind CSS 构建界面。
2.  **UI组件:** 广泛使用 Shadcn UI 提供的表格、表单、弹窗、按钮、下拉框、日期选择器、Tooltip等组件，确保UI风格统一且符合设计规范。
3.  **样式与布局:** 使用 Tailwind CSS 进行灵活的布局、间距、颜色、字体、响应式设计。利用其工具类快速构建复杂界面。
4.  **iOS 风格优化:**
    - **颜色:** 使用 Tailwind 配置中定义的、从原型或设计稿提取的 iOS 风格颜色变量。
    - **字体:** 配置使用系统字体栈 (`font-sans`) 或指定接近 San Francisco 的字体。
    - **阴影与圆角:** 应用 Tailwind 的 `shadow-*` 和 `rounded-*` 类，根据设计稿微调阴影强度和圆角大小。
    - **间距与对齐:** 精确控制 `padding`, `margin`, `gap` 等属性，使元素间距和整体布局符合 iOS 设计细节。
5.  **性能与体验:**
    - **骨架屏 (Skeleton):** 在客户列表、客户详情、统计图表等数据加载期间，使用 Shadcn UI 的 `Skeleton` 组件作为占位符，提升用户体验。
    - **数据加载状态:** 管理 loading 和 error 状态，加载失败时提供友好的错误提示和重试机制。
    - **异步操作反馈:** 批量操作等异步任务，提供明确的状态反馈（如进度条、Toast 提示），避免用户误认为操作无响应。
6.  **状态管理:** 推荐使用 React Query 或 SWR 来管理组件的异步数据请求和缓存。对于全局状态，可以使用 Zustand 或 Jotai 等轻量级状态管理库。
7.  **代码结构:**
    - 采用 Feature-sliced 或类似的架构模式组织代码，按功能（customer-list, customer-detail, group-management, tag-management）划分目录。
    - 将可复用的UI组件放入 `components/ui` 或 `components/shared`。
    - 将 API 调用封装在单独的服务层或 hooks 中。
8.  **交互与动画:** 实现平滑的页面切换动画（如淡入淡出、滑动），提升用户体验。批量操作、状态变更等重要交互应有视觉反馈。
9.  **错误处理:** 统一处理 API 请求返回的错误状态码和错误信息，向用户展示清晰的错误提示。
10. **响应式设计:** 充分利用 Tailwind CSS 的响应式前缀，确保页面在手机、平板、桌面等不同设备上都能良好展示。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。
> 所有功能和接口都以"让前端开发和业务都能一眼看懂"为原则。 

---

## 文件 69: 前端-我的-内容库功能.md

*文件大小：7.87 KB*

---

# 我的-内容库前端功能说明

## 一、功能简介
内容库功能用于统一管理和沉淀所有可用于群发、互动、运营的内容素材，实现内容的分组、标签化、批量管理、智能检索和数据分析，提升内容复用和运营效率。

---

## 二、主要功能模块

### 1. 内容素材列表与分组管理
- 支持展示所有内容素材的基本信息（标题、类型、标签、分组、创建人、状态等）。
- 支持内容分组、批量分组、分组筛选、分组管理。
- 支持内容的搜索、筛选、排序、批量操作。

### 2. 内容标签与分类管理
- 支持内容标签管理、批量打标签、标签筛选、标签分组。
- 支持内容类型分类（文本、图片、视频、链接等）。
- 支持标签自动化规则配置。

### 3. 内容编辑与维护
- 支持内容的新增、编辑、删除、归档、恢复等操作。
- 支持内容的批量导入、导出、批量归档、批量标签。
- 支持内容预览、历史版本管理、内容备注。

### 4. 内容详情与运营操作
- 支持查看内容详细信息（基础信息、标签、历史使用、互动数据等）。
- 支持内容的分组、标签、批量分配、批量推送等运营操作。
- 支持内容归档、移除、导出等操作。

### 5. 数据统计与分析
- 实时统计内容库素材总数、分组分布、标签分布、内容类型分布、使用频率等。
- 支持数据可视化展示（饼图、柱状图、折线图等）。
- 支持导出内容列表及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、内容日志查询。
- 内容数据管理过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括内容素材列表、分组管理、标签管理、内容详情、批量运营等。
- 主要功能区包括内容表格、分组管理、标签管理、批量操作区、统计区块、日志区等。
- **技术栈应用：** 基于 React 构建组件，使用 Shadcn UI 提供基础组件，通过 Tailwind CSS 进行样式和布局设计，遵循原子化 CSS 原则。

### 2. 技术选型与风格指南
- **核心技术栈：** React, TypeScript, Shadcn UI, Tailwind CSS
- **iOS 风格优化：**
    -   **颜色：** 严格遵循 iOS 风格配色方案，特别是灰色系、蓝色主色调和状态色。在 `tailwind.config.js` 中定义并使用定制的颜色变量。
    -   **字体：** 配置字体栈以优先使用系统字体 San Francisco (或相似字体)，精确调整各级文本（标题、正文、标签、按钮）的字号和字重，力求与 iOS 截图一致。
    -   **阴影与圆角：** 模拟 iOS 柔和的阴影效果（如导航栏、卡片），使用 Tailwind 的阴影工具类。精确调整组件（按钮、卡片、输入框）的圆角大小，采用 iOS 偏大的圆角风格。
    -   **布局与间距：** 严格参照原型截图，使用 Tailwind 的 padding, margin, gap 工具类精确控制组件内外边距和元素间距，实现像素级还原。
- **组件库：** 优先使用 Shadcn UI 组件，根据 iOS 风格进行定制和调整。对于复杂或特定 iOS 交互，可能需要基于基础组件进行封装或少量自定义组件。
- **骨架屏：** 数据加载时，使用类似于 Shadcn UI 的 Skeleton 组件展示占位符，提升用户体验。

### 3. 数据流与接口调用
- **数据获取：**
    -   **获取内容列表：** 调用后端 `GET /api/contents` 接口，支持分页、筛选（按分组、标签、类型、状态）、搜索、排序等参数。
        -   请求示例：`GET /api/contents?page=1&pageSize=10&groupId=xxx&tags=a,b&type=image&status=published&search=keyword&sortBy=createdAt&order=desc`
        -   响应示例：包含内容列表、总数、分页信息。
    -   **获取内容详情：** 调用后端 `GET /api/contents/{id}` 接口。
        -   请求示例：`GET /api/contents/123`
        -   响应示例：包含内容所有详细信息、历史使用数据、关联日志等。
    -   **获取分组列表：** 调用后端 `GET /api/content-groups` 接口。
    -   **获取标签列表：** 调用后端 `GET /api/content-tags` 接口。
    -   **获取统计数据：** 调用后端 `GET /api/content-stats` 接口，支持按时间范围、分组、标签等过滤。
- **数据操作：**
    -   **新增内容：** 调用后端 `POST /api/contents` 接口，请求体包含内容数据。
    -   **编辑内容：** 调用后端 `PUT /api/contents/{id}` 接口，请求体包含更新后的内容数据。
    -   **删除内容：** 调用后端 `DELETE /api/contents/{id}` 接口。
    -   **批量操作：** 如批量分组、批量打标签、批量归档、批量删除等，调用相应的后端接口（例如 `POST /api/contents/batch-update`, `POST /api/contents/batch-archive`, `DELETE /api/contents/batch-delete` 等），请求体包含内容ID列表和操作数据。
    -   **导出数据：** 调用后端 `GET /api/contents/export` 接口，支持筛选参数，后端生成并返回文件。
- **数据流处理：**
    -   在 React 组件中，使用状态管理（如 React Context 或 Zustand/Valtio 等轻量状态库）管理页面数据和状态。
    -   使用异步请求库（如 Axios 或 Fetch API）调用后端接口。
    -   在数据加载期间显示 Skeleton 骨架屏。
    -   操作提交时显示 Loading 状态或禁用按钮，操作完成后给予明确的反馈（成功/失败提示）。
    -   错误处理：统一捕获 API 请求错误，向用户显示友好的错误信息。

### 4. 交互细节
- 支持内容的搜索、筛选、排序、分组、标签、批量操作，所有交互均应平滑响应。
- 内容的新增、编辑、归档、批量运营等操作通过模态框 (Modal) 或抽屉 (Drawer) 实现，提供清晰的表单和操作流程。
- 内容状态、使用频率等信息在列表中直观展示，鼠标悬停或点击可查看更多详情。
- 内容详情页通过 Tab 或折叠面板展示基础信息、历史使用、日志等多维度信息。
- 所有表单、弹窗、表格、按钮等遵循 Shadcn UI 和定制的 iOS 风格。
- 数据加载和操作反馈使用 Skeleton 骨架屏和 Loading 状态，提供流畅的过渡体验。
- 路由跳转使用 React Router 等库实现 SPA (Single Page Application) 体验，可考虑添加页面切换动画。
- 权限控制根据后端返回的用户权限数据，动态控制前端元素的显示与隐藏、功能的可用性。
- 表格支持固定表头、列，优化大数据量的展示性能。

### 5. 开发建议
- **组件拆分：** 将复杂页面拆分为更小的、可复用的 React 组件（例如 ContentList, GroupManager, TagManager, ContentDetailModal 等）。
- **状态管理：** 选择合适的状态管理方案，确保数据在组件间高效同步。
- **API 封装：** 统一封装 API 调用逻辑，处理请求、响应、错误和 loading 状态。
- **样式管理：** 充分利用 Tailwind CSS 的优势，保持样式的一致性和可维护性。创建定制的工具类或组件变体来封装 iOS 风格的样式。
- **代码规范：** 遵循 React 和 TypeScript 的最佳实践，保持代码整洁易读。
- **性能优化：** 关注列表渲染性能（如使用虚拟列表）、图片懒加载、减少不必要的重渲染。
- **测试：** 为关键组件和功能编写单元测试和集成测试。
- **文档同步：** 开发过程中，及时更新此文档，特别是接口定义和前端实现细节。

---

> 本文档已结合现有前端代码结构、业务需求和选定技术栈（React, Shadcn UI, Tailwind CSS）进行优化和补充，并纳入了 iOS 风格的开发要点。后续如有功能调整请及时补充。同时，前端接口调用部分需与最新的后端接口文档保持同步。 

---

## 文件 70: 前端-我的-设备管理功能.md

*文件大小：3.30 KB*

---

# 我的-设备管理前端功能说明

## 一、功能简介
设备管理功能用于对接入系统的所有设备（如手机、平板、虚拟设备等）进行统一管理、状态监控、分组、授权和维护，保障业务流程的稳定运行和数据安全。

---

## 二、主要功能模块

### 1. 设备列表与分组管理
- 支持展示所有已接入设备的基本信息（名称、IMEI、微信号、在线状态、分组、授权状态等）。
- 支持设备分组、批量分组、分组筛选、分组管理。
- 支持设备的搜索、筛选、排序、批量操作。

### 2. 设备状态监控
- 实时展示设备的在线/离线状态、运行状态、异常告警等。
- 支持设备状态变更提醒、异常设备高亮、设备健康度评分。

### 3. 设备授权与解绑
- 支持对设备进行授权、解绑、重新绑定等操作。
- 支持批量授权、批量解绑。
- 支持设备授权日志、操作记录查询。

### 4. 设备详情与维护
- 支持查看设备详细信息（硬件信息、系统信息、微信号、历史任务、操作日志等）。
- 支持设备维护操作，如重启、远程控制、升级、恢复出厂设置等。
- 支持设备备注、标签管理。

### 5. 数据统计与分析
- 实时统计设备总数、在线设备数、分组分布、授权状态等。
- 支持数据可视化展示（饼图、柱状图等）。
- 支持导出设备列表及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、设备日志查询。
- 设备管理过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括设备列表、分组管理、设备详情、设备授权/解绑、设备维护等。
- 主要功能区包括设备表格、分组管理、状态监控、批量操作区、统计区块、日志区等。

### 2. 数据流与接口调用
- 设备管理相关：
  - 获取设备列表
  - 获取设备详情
  - 设备分组管理
  - 设备授权/解绑/重新绑定
  - 设备维护操作
- 设备状态与日志相关：
  - 获取设备状态
  - 获取设备日志、操作记录
- 数据统计相关：
  - 获取设备统计数据
  - 导出设备列表及统计数据

### 3. 交互细节
- 支持设备的搜索、筛选、排序、分组、批量操作。
- 支持设备的授权、解绑、维护等操作，均有操作确认和反馈。
- 设备状态、异常、健康度等信息实时展示。
- 详情页支持设备信息、历史任务、日志等多维度展示。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现设备列表、分组管理、设备详情主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 71: 前端-我的-微信号管理功能.md

*文件大小：3.36 KB*

---

# 我的-微信号管理前端功能说明

## 一、功能简介
微信号管理功能用于对接入系统的所有微信号进行统一管理、状态监控、分组、授权和维护，便于多账号运营、风控和数据安全。

---

## 二、主要功能模块

### 1. 微信号列表与分组管理
- 支持展示所有已接入微信号的基本信息（微信号、昵称、绑定设备、在线状态、分组、授权状态等）。
- 支持微信号分组、批量分组、分组筛选、分组管理。
- 支持微信号的搜索、筛选、排序、批量操作。

### 2. 微信号状态监控
- 实时展示微信号的在线/离线状态、运行状态、异常告警等。
- 支持状态变更提醒、异常高亮、健康度评分。

### 3. 微信号授权与解绑
- 支持对微信号进行授权、解绑、重新绑定等操作。
- 支持批量授权、批量解绑。
- 支持微信号授权日志、操作记录查询。

### 4. 微信号详情与维护
- 支持查看微信号详细信息（绑定设备、历史任务、操作日志、标签、备注等）。
- 支持微信号维护操作，如重登、远程控制、升级、恢复初始状态等。
- 支持微信号备注、标签管理。

### 5. 数据统计与分析
- 实时统计微信号总数、在线微信号数、分组分布、授权状态等。
- 支持数据可视化展示（饼图、柱状图等）。
- 支持导出微信号列表及统计数据。
- 主要功能区：统计区块、图表区。

### 6. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、微信号日志查询。
- 微信号管理过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括微信号列表、分组管理、微信号详情、微信号授权/解绑、微信号维护等。
- 主要功能区包括微信号表格、分组管理、状态监控、批量操作区、统计区块、日志区等。

### 2. 数据流与接口调用
- 微信号管理相关：
  - 获取微信号列表
  - 获取微信号详情
  - 微信号分组管理
  - 微信号授权/解绑/重新绑定
  - 微信号维护操作
- 微信号状态与日志相关：
  - 获取微信号状态
  - 获取微信号日志、操作记录
- 数据统计相关：
  - 获取微信号统计数据
  - 导出微信号列表及统计数据

### 3. 交互细节
- 支持微信号的搜索、筛选、排序、分组、批量操作。
- 支持微信号的授权、解绑、维护等操作，均有操作确认和反馈。
- 微信号状态、异常、健康度等信息实时展示。
- 详情页支持微信号信息、历史任务、日志等多维度展示。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好页面结构和功能拆分，优先实现微信号列表、分组管理、微信号详情主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、筛选、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 72: 前端-我的功能描述.md

*文件大小：2.90 KB*

---

# 我的功能描述

## 一、功能简介
"我的"模块聚合了用户的账号信息、设备管理、微信号管理、流量池、内容库、个人设置等功能，是用户进行个性化管理和资源维护的中心。

---

## 二、主要功能模块

### 1. 账号信息与个人设置
- 支持查看和编辑个人信息、账号安全、密码修改、登录日志等。
- 支持多账号切换、权限管理、个性化配置。

### 2. 设备管理
- 支持设备的统一管理、分组、授权、状态监控、维护等。
- 支持设备的批量操作、健康度监控、异常提醒。

### 3. 微信号管理
- 支持微信号的统一管理、分组、授权、状态监控、维护等。
- 支持微信号的批量操作、健康度监控、异常提醒。

### 4. 流量池管理
- 支持客户流量的统一管理、分组、标签、批量运营、数据分析等。
- 支持客户的批量分配、批量加好友、批量群发等。

### 5. 内容库管理
- 支持内容素材的统一管理、分组、标签、批量管理、智能检索等。
- 支持内容的批量导入、导出、归档、推送等。

### 6. 数据统计与分析
- 实时统计各类资源的数量、分布、活跃度等。
- 支持多维度数据可视化、趋势分析、导出报表。

### 7. 权限与安全
- 支持多角色、多账号权限控制。
- 支持操作日志、资源日志查询。
- 个人数据管理过程加密传输，保障数据安全。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要区块包括账号信息、设备管理、微信号管理、流量池、内容库、个人设置、数据统计、日志区等。

### 2. 数据流与接口调用
- 账号与权限相关：
  - 获取账号信息
  - 获取权限配置
  - 修改个人信息、密码
- 设备、微信号、流量池、内容库相关：
  - 获取资源列表
  - 获取资源详情
  - 资源分组、标签、批量操作
- 日志与统计相关：
  - 获取操作日志、资源日志
  - 获取统计数据

### 3. 交互细节
- 支持各类资源的搜索、筛选、排序、分组、标签、批量操作。
- 支持个人信息、资源的编辑、归档、批量管理等操作，均有操作确认和反馈。
- 所有区块、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好各资源管理和个人设置的结构，优先实现主流管理和个性化配置主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量操作、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 73: 前端-中台AI知识库功能.md

*文件大小：3.37 KB*

---

# 中台AI知识库前端功能说明

## 一、功能简介
中台AI知识库为AI手机端和各业务系统提供统一的专业知识、数据问答和智能检索能力。支持将内容库中的专业知识、业务数据、流程规范等沉淀为知识库，供AI助手、业务人员、终端用户随时调用，实现智能问答、业务辅助、内部培训等多场景应用。

---

## 二、主要功能模块

### 1. 知识内容管理与沉淀
- 支持将内容库中的专业知识、业务数据、流程规范、常见问题等一键沉淀为知识库条目。
- 支持知识条目的分组、标签、版本管理、批量导入导出。
- 支持知识内容的全文检索、智能推荐、自动归类。

### 2. AI问答与智能检索
- 支持AI手机端、Web端等多终端通过自然语言提问，智能检索知识库内容并返回专业答案。
- 支持多轮对话、上下文理解、知识引用、答案溯源。
- 支持知识库与内容库、业务数据的联动，自动补充最新知识。

### 3. 权限与多端接入
- 支持多角色、多账号权限控制，按部门/岗位/项目分配知识访问权限。
- 支持AI助手、业务系统、手机端等多端接入知识库API。
- 支持知识库内容的动态更新、权限同步、接口调用统计。

### 4. 数据统计与分析
- 实时统计知识库调用量、问答量、命中率、用户活跃度等。
- 支持多维度数据可视化、趋势分析、导出报表。
- 主要功能区：统计区块、图表区。

### 5. 安全与合规
- 支持知识内容加密存储、接口加密传输。
- 支持操作日志、问答日志、权限变更日志查询。
- 支持知识内容的合规审核、敏感词过滤、数据脱敏。

---

## 三、前端开发要点

### 1. 页面与功能结构
- 主要页面包括知识内容管理、知识条目编辑、AI问答入口、权限配置、统计分析等。
- 主要功能区包括知识表格、标签管理、AI问答区、权限配置区、统计区块、日志区等。

### 2. 数据流与接口调用
- 知识库管理相关：
  - 获取知识条目列表
  - 新增/编辑/删除知识条目
  - 知识分组、标签、版本管理
- AI问答相关：
  - AI提问接口
  - 智能检索接口
  - 多端接入API
- 权限与日志相关：
  - 获取权限配置
  - 获取操作日志、问答日志
- 数据统计相关：
  - 获取知识库统计数据
  - 导出统计报表

### 3. 交互细节
- 支持知识条目的批量管理、标签化、版本切换、全文检索。
- 支持AI问答的多轮对话、上下文理解、知识引用、答案溯源。
- 支持权限的灵活配置、多端接入、动态同步。
- 所有表单、弹窗、表格、按钮等均用统一UI风格。
- 数据加载、操作反馈均用 Skeleton 骨架屏和 Loading 状态。
- 路由跳转用 SPA 体验。
- 权限控制、入口自定义等按业务需求配置。

### 4. 开发建议
- 先梳理好知识内容管理、AI问答、权限配置、多端接入等结构，优先实现主流程。
- 充分利用已有的 UI 组件和 API 封装，减少重复开发。
- 交互细节（如批量管理、智能检索、骨架屏、权限控制）按实际业务需求逐步完善。
- 所有接口调用建议统一封装，便于维护。

---

> 本文档持续更新，已结合现有前端代码结构和业务需求，后续如有功能调整请及时补充。 

---

## 文件 74: 原型-原型-系统架构原型.md

*文件大小：4.25 KB*

---

# 存客宝系统架构原型

## 一、架构分层原型草图（文字描述）
```
┌──────────────────────────────────────────────┐
|                前端展示层（PC/H5/小程序）     |
|  Next.js/React/Shadcn UI/Tailwind/Skeleton   |
└──────────────────────────────────────────────┘
                │   RESTful API/WebSocket
┌──────────────────────────────────────────────┐
|                后端服务层                    |
|  Java+Spring Boot（主业务）                  |
|  FastAPI（AI/数据处理）                      |
|  业务微服务：客户、线索、设备、内容、标签、分销、红包池、公众号API等 |
|  多租户支持、权限分级、日志审计              |
└──────────────────────────────────────────────┘
                │   API/消息队列
┌──────────────────────────────────────────────┐
|                AI智能服务                    |
|  FastAPI/NLP/ML/标签预测/内容改写/AI内容生成/自动化运营 |
└──────────────────────────────────────────────┘
                │   数据同步/缓存
┌──────────────────────────────────────────────┐
|                数据存储层                    |
|  MySQL（核心业务数据，分库分表）             |
|  HBase/Hive（大数据分析/用户画像/标签）       |
|  Redis（缓存）                               |
└──────────────────────────────────────────────┘
                │   事件驱动/异步解耦
┌──────────────────────────────────────────────┐
|                消息队列/任务调度              |
|  Kafka/RabbitMQ/Quartz/自动化任务/分销返利结算|
└──────────────────────────────────────────────┘
                │   API对接/数据同步
┌──────────────────────────────────────────────┐
|                第三方平台集成                |
|  微信/抖音/小红书/公众号/CRM/ERP/支付/红包API等 |
└──────────────────────────────────────────────┘
```

## 二、主要模块与交互说明
- 前端通过RESTful API与后端服务层通信，部分场景用WebSocket实现实时交互。
- 后端服务层负责业务逻辑、权限校验、任务调度、分销体系、红包池管理、公众号API集成、第三方平台对接。
- AI智能服务通过API/消息队列与主系统解耦，支持线索过滤、内容生成、标签预测、自动化运营、AI内容推送等。
- 数据存储层分为关系型数据库（分库分表）、数据仓库和缓存，支撑高并发和大数据分析。
- 消息队列实现服务间异步解耦、事件驱动、自动化任务、分销返利结算、异步通知等。
- 第三方平台集成支持多渠道获客、内容推送、客户同步、支付/红包、公众号API等。

## 三、扩展性与安全说明
- 微服务架构，支持弹性扩展、故障隔离、灰度发布。
- 全链路加密、权限分级、日志审计、数据脱敏，保障数据安全与合规。
- 支持多租户、分布式部署，便于业务扩展和多业务线运营。
- 自动化任务与AI运营支持灵活配置和扩展。

---
> 本文档为系统架构原型草图，已结合最新需求池优化，后续可结合架构图工具进一步细化。 

---

## 文件 75: 原型-原型-系统首页原型.md

*文件大小：2.47 KB*

---

# 存客宝系统首页原型

## 一、页面结构总览
- 顶部导航栏：LOGO、系统名称、通知、用户信息、设置入口、【优化】分销/红包池入口、AI助手入口
- 左侧菜单栏：各核心模块入口（首页、场景获客、内容库、工作台、我的、分销管理、红包池、系统设置等）
- 主内容区：
  - 数据看板（客户总数、今日新增、活跃设备、渠道分布、分销数据、红包池余额、内容库推送统计等）
  - 快捷入口（电话获客、抖音获客、小红书获客、公众号获客、海报获客、订单导入、自动化任务等）
  - 运营公告/通知栏（系统公告、合规提醒、升级通知等）
  - 近期运营动态/任务提醒（线索分配、内容推送、设备状态、分销动态、红包池变动、AI内容推送等）

## 二、核心区块说明
### 1. 数据看板
- 以卡片或图表形式展示关键运营指标（多平台获客、分销、红包池、内容库等）
- 支持自定义筛选（时间、渠道、场景、分销层级等）

### 2. 快捷入口
- 常用获客场景一键直达（电话、抖音、小红书、公众号、海报、订单等）
- 支持自定义排序、权限控制和显示

### 3. 通知与公告
- 展示系统公告、运营通知、合规提醒、分销返利通知、重要提醒
- 支持点击查看详情

### 4. 近期动态/任务
- 展示最近的线索分配、内容推送、设备状态、分销/红包池动态、AI自动化任务等
- 支持任务提醒、快捷操作和异常提示

## 三、原型草图（文字描述）
```
---------------------------------------------------
| LOGO | 存客宝 | 首页 | 场景获客 | 内容库 | 分销 | 红包池 | AI助手 | 用户 | 通知 |
---------------------------------------------------
| 菜单 |   数据看板   |   快捷入口   |   通知公告   |
|      |-------------------------------------------|
|      |   近期动态/任务提醒区                     |
---------------------------------------------------
```

## 四、交互说明
- 所有数据区块支持点击跳转详情页
- 通知、任务、分销、红包池等支持红点提醒
- 菜单栏支持收起/展开，入口权限可配置
- 快捷入口、数据看板、动态区块均支持自定义显示与排序
- AI助手支持一键触发内容生成、线索分析等自动化任务

---
> 本文档为系统首页原型草图，已结合最新需求池优化，后续可结合UI设计进一步细化。 

---

